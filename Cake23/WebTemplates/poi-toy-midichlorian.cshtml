<html>
<head>
	<title>Poi Simulation (with programmable lights) [rock paper scissor] | WebGL GPGPU</title>
	<script src="@(Model.Host.URL)/Scripts/jquery-1.6.4.min.js"></script>
	<script src="@(Model.Host.URL)/Scripts/jquery.signalR-2.2.0.min.js"></script>
	<script src="@(Model.Host.URL)/signalr/hubs"></script>
	<script type="text/javascript">
		$(function () {
			$.connection.hub.url = "@(Model.Host.URL)/signalr"; var kinect = $.connection.kinect2Hub;

			kinect.client.onBody = function (bodyJson, projectionMappedPointsJson) {
				body = JSON.parse(bodyJson);
				// bodysampler = JSON.parse(projectionMappedPointsJson); // this would be the inbuilt mapping of the 3d coordinates to the 1080p video camera
				body.head = {
					x: body.Joints["Head"].Position.X,
					y: body.Joints["Head"].Position.Y,
					z: body.Joints["Head"].Position.Z,
					old: { "x": -1, "y": -1, "z": -1 }
				};
				body.handRight = { old: { "x": -1, "y": -1, "z": -1 }, grab: false, point: false, object: null };
				switch (body.handRight.state = body.HandRightState) {
					case 3:
						body.handRight.grab = true;
						break;
					case 4:
						body.handRight.point = true;
						break;
				}
				body.handRight.id = "hr" + body.TrackingId;
				//if (body.handRight.grab) {
				body.handRight.x = (body.Joints["HandTipRight"].Position.X * 2 + body.Joints["HandRight"].Position.X + body.Joints["ThumbRight"].Position.X * 2) / 5;
				body.handRight.y = (body.Joints["HandTipRight"].Position.Y * 2 + body.Joints["HandRight"].Position.Y + body.Joints["ThumbRight"].Position.Y * 2) / 5;
				body.handRight.z = (body.Joints["HandTipRight"].Position.Z * 2 + body.Joints["HandRight"].Position.Z + body.Joints["ThumbRight"].Position.Z * 2) / 5;
				//} else
				if (body.handRight.point) {
					body.handRight.x = body.Joints["HandTipRight"].Position.X;
					body.handRight.y = body.Joints["HandTipRight"].Position.Y;
					body.handRight.z = body.Joints["HandTipRight"].Position.Z;
				}
				body.handLeft = { old: { "x": -1, "y": -1, "z": -1 }, grab: false, point: false, object: null };
				switch (body.handLeft.state = body.HandLeftState) {
					case 3:
						body.handLeft.grab = true;
						break;
					case 4:
						body.handLeft.point = true;
						break;
				}
				body.handLeft.id = "hl" + body.TrackingId;
				//if (body.handLeft.grab) {
				body.handLeft.x = (body.Joints["HandTipLeft"].Position.X * 2 + body.Joints["HandLeft"].Position.X + body.Joints["ThumbLeft"].Position.X * 2) / 5;
				body.handLeft.y = (body.Joints["HandTipLeft"].Position.Y * 2 + body.Joints["HandLeft"].Position.Y + body.Joints["ThumbLeft"].Position.Y * 2) / 5;
				body.handLeft.z = (body.Joints["HandTipLeft"].Position.Z * 2 + body.Joints["HandLeft"].Position.Z + body.Joints["ThumbLeft"].Position.Z * 2) / 5;
				//} else
				if (body.handLeft.point) {
					body.handLeft.x = body.Joints["HandTipLeft"].Position.X;
					body.handLeft.y = body.Joints["HandTipLeft"].Position.Y;
					body.handLeft.z = body.Joints["HandTipLeft"].Position.Z;
				}
				var trackingObject = getTrackingObject(body.TrackingId);
				if (trackingObject.body == null) {
					trackingObject.body = body;
				} else {
					var oldBody = trackingObject.body;
					body.head.old.x = oldBody.head.x; // collapse?
					body.head.old.y = oldBody.head.y;
					body.head.old.z = oldBody.head.z;
					body.handRight.old.x = oldBody.handRight.x;
					body.handRight.old.y = oldBody.handRight.y;
					body.handRight.old.z = oldBody.handRight.z;
					body.handLeft.old.x = oldBody.handLeft.x;
					body.handLeft.old.y = oldBody.handLeft.y;
					body.handLeft.old.z = oldBody.handLeft.z;
					if (oldBody.handRight.grab) {
						body.handRight.object = oldBody.handRight.object;
					}
					if (oldBody.handLeft.grab) {
						body.handLeft.object = oldBody.handLeft.object;
					}
				}
				trackingObject.body = body; // update
			};
			kinect.client.onBodies = function (trackingIdsJson, frame) {
				var trackingIds = null;
				if (trackingIdsJson != null) {
					trackingIds = JSON.parse(trackingIdsJson);
				}
				onBodies(trackingObjects, trackingIds, frame);
			};
			kinect.client.onFace = onFace;

			var midi = $.connection.midiHub;
			midi.client.onMidi = onMidi;

			$.connection.hub.start().done(function () {
			});

		});

		var trackingObjects = [], bodyFrameIndex;
		function getTrackingObject(id) {
			var hit = null;
			trackingObjects.forEach(function (trackingObject) { // perhaps not the most efficient way, but don't expect too many tracked bodies anyway
				if (trackingObject.id == id) {
					hit = trackingObject;
				}
			});
			if (hit) {
				return hit;
			}
			// create new trackingObject
			console.log("create tracking object " + id);
			var trackingObject = { id: id, body: null }; // init as object that can be easily extended with additional properties
			trackingObjects.push(trackingObject);
			return trackingObject;
		}

		// Kinect body frame arrived
		// TODO: this function should take into account that calls come from varying sites
		var activeTrackingObjects = [];
		function onBodies(trackingObjects, trackedBodyIds, frame, sensorID) {
			bodyFrameIndex = frame;
			var oldActiveTrackingObjects = activeTrackingObjects;
			oldActiveTrackingObjects.forEach(function (trackingObject) {
				if (trackedBodyIds.indexOf(trackingObject.id) == -1) {
					trackingObject.stickman.pop();
				}
			});
			activeTrackingObjects = [];
			trackedBodyIds.forEach(function (id) {
				var trackingObject = getTrackingObject(id);
				activeTrackingObjects.push(trackingObject);
			});
		}

		var midi = [];

		// presets copied from the Chrome console after doodling with the knobs and sliders of my Korg nanoKontrol2

		// light theme
		midi = [0.8582677165354331, 0.8031496062992126, 0.889763779527559, 0, 0.6614173228346457, 0.5196850393700787, 0.6771653543307087, 0, null, null, null, null, null, null, null, null, 0.29133858267716534, 0.25196850393700787, 0.6299212598425197, 0.9212598425196851, 0.031496062992125984, 0.25984251968503935, 0.2125984251968504, 1];
		// dark theme
		//midi = [0.015748031496062992, 0, 0.09448818897637795, 0, 0.3858267716535433, 0.2047244094488189, 0.047244094488188976, 0, null, null, null, null, null, null, null, null, 0.6614173228346457, 0.7795275590551181, 0.8267716535433071, 1, 0.6456692913385826, 0.7165354330708661, 1, 1];

		function onMidi(channel, data1, data2) {
			//for now, just ignore the channel information
			midi[data1] = data2 / 127.;
			console.log("midi msg: channel " + channel + " , data: " + data1 + " => " + data2);
		}

		var faces = [];

		function onFace(verticesJSON, status, TrackingId) {
			var trackingObject = getTrackingObject(TrackingId);
			var before = Date.now();
			var vertices = JSON.parse(verticesJSON);
			var dur = Date.now() - before;
			var face = faces[TrackingId];
			if (face == undefined) {
				face = {
					points2d: []
				};
				for (var i = 0; i < 1347; i++) {
					face.points2d[i] = {};
				}
				faces[TrackingId] = face;
			}

			if (trackingObject.body) {
				var head = trackingObject.body.head;
				if (head) {
					var p2d = {};
					var p3d = {};
					var scale = 1.25;
					for (var i = 0; i < 1347; i++) {

						p3d.x = head.x + (vertices[i * 3 + 0] - head.x) * scale;
						p3d.y = head.y + (vertices[i * 3 + 1] - head.y) * scale;
						p3d.z = head.z + (vertices[i * 3 + 2] - head.z) * scale;

						project(p3d, p2d);

						var shape = face.points2d[i];

						shape.x = p2d.x;
						shape.y = p2d.y;

						if (shape.update) {
							shape.update();
						}
					}
				}
			}
		}

		function getMidi(id) {

			if (midi[id] == undefined)
				midi[id] = 0;

			return midi[id];
		}

		var joints = ["SpineBase", "SpineMid", "Neck", "Head", "ShoulderLeft",
			"ElbowLeft", "WristLeft", "HandLeft", "ShoulderRight", "ElbowRight",
			"WristRight", "HandRight", "HipLeft", "KneeLeft", "AnkleLeft",
			"FootLeft", "HipRight", "KneeRight", "AnkleRight", "FootRight",
			"SpineShoulder", "HandTipLeft", "ThumbLeft", "HandTipRight", "ThumbRight"];

		var members = [
//		["SpineBase", "SpineMid"],
//		["SpineMid", "SpineShoulder"],
			["SpineShoulder", "Neck"],
//		["Neck", "Head"],
			["SpineShoulder", "ShoulderLeft"],
			["ShoulderLeft", "ElbowLeft"],
			["ElbowLeft", "WristLeft"],
			["WristLeft", "HandLeft"],
			["HandLeft", "HandTipLeft"],
			["HandLeft", "ThumbLeft"],
//		["SpineBase", "HipLeft"],
			["SpineBase", "KneeLeft"],
			["SpineBase", "KneeRight"],
//		["HipLeft", "ShoulderLeft"],
			["HipLeft", "KneeLeft"],
			["KneeLeft", "AnkleLeft"],
			["AnkleLeft", "FootLeft"],
			["SpineShoulder", "ShoulderRight"],
			["ShoulderRight", "ElbowRight"],
			["ElbowRight", "WristRight"],
			["WristRight", "HandRight"],
			["HandRight", "HandTipRight"],
			["HandRight", "ThumbRight"],
//		["SpineBase", "HipRight"],
//		["HipRight", "ShoulderRight"],
			["HipRight", "KneeRight"],
			["KneeRight", "AnkleRight"],
			["AnkleRight", "FootRight"],
			["SpineMid", "ShoulderRight"],
			["SpineMid", "ShoulderLeft"],
			["SpineMid", "HipRight"],
			["SpineMid", "HipLeft"]
		];

		// perspective projection (virtual camera) 
		function project(p3d, p2d) {
			p2d.x = p3d.x;
			p2d.y = p3d.y;
			var w = Math.atan2(-p3d.x, -p3d.y);
			var l = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y);
			var d = 3.;
			var zoom = 3;
			var p = Math.tan(Math.PI / 2 + Math.atan2(d + p3d.z, l));
			d = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y + (p3d.z + d) * (p3d.z + d));
			p2d.x = zoom * Math.sin(w) * p / aspectx + 0.5;
			p2d.y = zoom * Math.cos(w) * p / aspecty + 0.5;
			p2d.y = 1 - p2d.y;
			p2d.x *= sizeX;
			p2d.y *= sizeY;
		}

		var Joint = function () {
			this.x = 0.5;
			this.y = 0.5;
			this.z = 1;
			this.state = 0;
			this.old = {};
			this.old.x = 0.5;
			this.old.y = 0.5;
			this.old.z = 1;
			this.old.state = 0;
			this.update = function (pos) {
				this.old.x = this.x;
				this.old.y = this.y;
				this.old.z = this.z;
				this.old.state = this.state;
				this.x = pos.x;
				this.y = pos.y;
				this.z = pos.z;
				this.state = pos.state;
			};
		};

		var Bone = function (joint1, joint2) {
			this.joint1 = joint1;
			this.joint2 = joint2;
		}

		var Stickman = function () {
			this.joints = [];
			this.bones = [];
			var self = this;
			joints.forEach(function (name) {
				self.joints[name] = new Joint();
			});
			members.forEach(function (member) {
				self.bones[member] = new Bone(self.joints[member[0]], self.joints[member[1]]);
			});
			this.leftHandPoiToy = new PoiToy();
			this.rightHandPoiToy = new PoiToy();
			this.pop = function () {
				this.leftHandPoiToy.pop();
				this.rightHandPoiToy.pop();
			}
		};

		function updateStickMen() {
			activeTrackingObjects.forEach(function (trackingObject) {

				var body = trackingObject.body;
				var stickman = trackingObject.stickman;
				if (stickman == null) {
					stickman = new Stickman();
					trackingObject.stickman = stickman;
				}

				joints.forEach(function (id) {
					stickman.joints[id].update({
						x: trackingObject.body.Joints[id].Position.X,
						y: trackingObject.body.Joints[id].Position.Y,
						z: trackingObject.body.Joints[id].Position.Z,
						state: body.Joints[id].TrackingState
					});
				});

				stickman.leftHandPoiToy.x = body.handLeft.x;
				stickman.leftHandPoiToy.y = body.handLeft.y;
				stickman.leftHandPoiToy.z = body.handLeft.z;

				stickman.rightHandPoiToy.x = body.handRight.x;
				stickman.rightHandPoiToy.y = body.handRight.y;
				stickman.rightHandPoiToy.z = body.handRight.z;
			});
		}


		function drawPoiToys(context) {
			activeTrackingObjects.forEach(function (trackingObject) {

				var stickman = trackingObject.stickman;
				if (stickman == null) {
					stickman = new Stickman();
					trackingObject.stickman = stickman;
				}

				stickman.leftHandPoiToy.drawLightStreaks(context);
				stickman.rightHandPoiToy.drawLightStreaks(context);
			});
		}

		function drawStickMen(context) {
			activeTrackingObjects.forEach(function (trackingObject) {

				var stickman = trackingObject.stickman;
				if (stickman == null) {
					stickman = new Stickman();
					trackingObject.stickman = stickman;
				}

				// draw the bones
				context.strokeStyle = "#FFF";
				context.beginPath();

				members.forEach(function (member) {
					var joint1 = stickman.joints[member[0]];
					var joint2 = stickman.joints[member[1]];
					if (joint1.state == 2 && joint2.state == 2) {
						var p1 = {};
						var p2 = {};
						project(joint1, p1);
						project(joint2, p2);
						context.moveTo(p1.x, p1.y);
						context.lineTo(p2.x, p2.y);
					}
				});

				context.lineWidth = 1.25;//64 / 256;
				context.stroke();

				// draw the hands

				var handLeft = {};
				var handRight = {};
				project(trackingObject.body.handLeft, handLeft);
				project(trackingObject.body.handRight, handRight);

				context.beginPath();
				context.strokeStyle = "#FFF";
				if (trackingObject.body.handLeft.grab) {
					context.strokeStyle = "#0F0";
				}
				context.rect(handLeft.x - 25, handLeft.y - 25, 50, 50);
				context.stroke();

				context.beginPath();
				context.strokeStyle = "#FFF";
				if (trackingObject.body.handRight.grab) {
					context.strokeStyle = "#0F0";
				}
				context.rect(handRight.x - 25, handRight.y - 25, 50, 50);
				context.stroke();

				/*
				joints.forEach(function (id) {
					var joint = stickman.joints[id];
				});
				*/

				// draw the face
				context.fillStyle = "#FFF";
				var face = faces[trackingObject.id];
				if (face) {
					face.points2d.forEach(function (p) {
						context.fillRect(p.x, p.y, 1.25, 1.25);
					});
				}

			});
		}

		// B-Spline rendering
		// see https://codepen.io/Flexi/pen/wWvJvO

		var controls = [
			200, 50,
			125, 75,
			125, 190,
			200, 200,
			225, 150,
			255, 150,
			225, 150,
			220, 200,
			255, 200,
			255, 150,
			230, 150,
			260, 155,
			300, 150,
			270, 150,
			270, 200,
			300, 200,
			300, 190,
			310, 50,
			300, 75,
			305, 200,
			305, 190,
			335, 170,
			355, 150,
			330, 150,
			320, 190,
			350, 200,
			370, 180,
			367, 150,
			370, 230,
			367, 200,
			375, 150,
			405, 150,
			400, 180,
			375, 170,
			400, 180,
			445, 150,
			420, 150,
			415, 190,
			440, 200,
			460, 170,
			460, 150,
			460, 200,
			460, 155,
			490, 155,
			490, 200,
		];

		// lambda for iteration over the splines for a set of controls
		function forBezier(controls, i, func) {
			var currentx = controls[i * 2 + 0];
			var currenty = controls[i * 2 + 1];
			var nextx = controls[i * 2 + 2];
			var nexty = controls[i * 2 + 3];
			var helper1x = currentx;
			var helper1y = currenty;
			if (i > 0) {
				helper1x = currentx;
				var previousx = controls[i * 2 - 2];
				var previousy = controls[i * 2 - 1];
				helper1x = currentx + (nextx - previousx) * 0.25;
				helper1y = currenty + (nexty - previousy) * 0.25;
			}
			var helper2x = nextx;
			var helper2y = nexty;
			if (i < controls.length / 2 - 2) {
				var nextnextx = controls[i * 2 + 4];
				var nextnexty = controls[i * 2 + 5];
				helper2x = nextx - (nextnextx - currentx) * 0.25;
				helper2y = nexty - (nextnexty - currenty) * 0.25;
			}
			return func(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, i, controls);
		}

		function forEachBezier(controls, func) {
			if (controls.length > 1) {
				for (var i = 0; i < controls.length / 2 - 1; i++) {
					forBezier(controls, i, func);
				}
			}
		}

		// see http://stackoverflow.com/a/17096947/6036193
		function getCubic(normalizedDistance, a, b, c, d) {
			var t2 = normalizedDistance * normalizedDistance;
			var t3 = t2 * normalizedDistance;
			return a + (-a * 3 + normalizedDistance * (3 * a - a * normalizedDistance)) * normalizedDistance + (3 * b + normalizedDistance * (-6 * b + b * 3 * normalizedDistance)) * normalizedDistance + (c * 3 - c * 3 * normalizedDistance) * t2 + d * t3;
		}

		// returns the point on the spline for a normalized range value
		function getPointOnSpline(controls, index) {
			index *= controls.bezierLength;
			var start = 0;
			for (var i = 0; i < controls.bezierLengths.length; i++) {
				var l = controls.bezierLengths[i];
				if (index >= start && index <= start + l) {
					return forBezier(controls, i, function (currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty) {
						return getPointOnBezier(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, (index - start) / l)
					});
				}
				start += l;
			}
		}

		function getPointOnBezier(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, index) {
			return [getCubic(index, currentx, helper1x, helper2x, nextx), getCubic(index, currenty, helper1y, helper2y, nexty)];
		}

		function getBezierLength(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty) {
			// solve differentially with N segments
			var N = 10;
			var L = 0;
			var start = getPointOnBezier(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, 0);
			for (var i = 1; i <= N; i++) {
				var end = getPointOnBezier(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, i / N);
				L += Math.sqrt((start[0] - end[0]) * (start[0] - end[0]) + (start[1] - end[1]) * (start[1] - end[1]));
				start = end;
			}
			return L;
		}

		function attachBezierLengths(controls) {
			controls.bezierLengths = [];
			forEachBezier(controls, function (currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, i, controls) {
				controls.bezierLengths[i] = getBezierLength(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty);
			});
			controls.bezierLength = controls.bezierLengths.reduce(function (a, b) { return a + b }, 0);
		}

		attachBezierLengths(controls);

		var animationFrameCount = Math.floor(controls.bezierLength / Math.sqrt(2)); // line drawing animation #speed
		var animationFrame = 0;

		function animatePointOnSpline() {
			requestAnimationFrame(animatePointOnSpline);
			if (animationFrame > animationFrameCount) {
				animationFrame = 0;
			}
			var index = animationFrame / animationFrameCount;

			context.globalCompositeOperation = "source-over";

			context.fillStyle = "#000";
			context.fillRect(0, 0, sizeX, sizeY);

			context.strokeStyle = "#F00";
			drawSpline(context, controls);

			var point = getPointOnSpline(controls, index);

			context.fillStyle = "#0F0";
			context.fillRect(point[0] - 1.25, point[1] - 1.25, 2.5, 2.5);

			animationFrame++;
		}

		// animatePointOnSpline();

		function drawSpline(context, controls) {
			forEachBezier(controls, function (currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty) {
				context.beginPath();
				context.moveTo(currentx, currenty);
				context.bezierCurveTo(helper1x, helper1y, helper2x, helper2y, nextx, nexty);
				context.stroke();
			});
		}

		// Poi Toy
		var allPoiToys = [];

		(function advancePoiToys() {
			var before = Date.now();
			allPoiToys.forEach(function (poiToy) {
				poiToy.advance();
			});
			var dur = Date.now() - before;
			if (dur > 10) {
				console.warn('poi sim time: ' + dur);
			}
			setTimeout(advancePoiToys, 10-dur);
		})();

		var PoiToy = function () {
			allPoiToys.push(this);
			this.pop = function () {
				delete allPoiToys[allPoiToys.indexOf(this)];
			}

			this.numLights = 80;
			this.postureIdx = 0;
			this.postureHistory = [];
			this.historyLength = 32;
			this.pushPosture = function (posture) {
				this.postureHistory = [posture].concat(this.postureHistory.slice(0, this.historyLength - 1)); // new posture goes in first, truncate history
			}

			this.force = 0.003;
			this.grav = -0.000;
			this.speedFactor = 0.66;
			this.friction = 30.; // 50
			this.x = 0.5;
			this.y = 0.2;
			this.z = 0.;
			this.points = []; // support points
			for (i = 0; i < 4; i++) {
				this.points[i] = { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0 };
			}

			this.applySpringForce = function (i1, i2) {
				fx = (this.points[i2].x - this.points[i1].x) * this.force;
				fy = (this.points[i2].y - this.points[i1].y) * this.force;
				fz = (this.points[i2].z - this.points[i1].z) * this.force;
				this.points[i1].vx += fx;
				this.points[i2].vx -= fx;
				this.points[i1].vy += fy;
				this.points[i2].vy -= fy;
				this.points[i1].vz += fz;
				this.points[i2].vz -= fz;
			};

			this.frame = 0;
			this.advance = function () {
				for (var n = 0; n < 5; n++) {

					// apply spring forces
					for (i = 1; i < 4; i++) {
						this.applySpringForce(i - 1, i);
						var vx = this.points[i].vx;
						var vy = this.points[i].vy;
						var vz = this.points[i].vz;
						var friction = Math.max(0, 1 - (vx * vx + vy * vy + vz * vz) * this.friction); // nonlinear quadratic
						this.points[i].vx *= friction;
						this.points[i].vy *= friction;
						this.points[i].vz *= friction;
						this.points[i].vy -= this.grav;
						this.points[i].x += vx * this.speedFactor; // Verlet integration
						this.points[i].y += vy * this.speedFactor;
						this.points[i].z += vz * this.speedFactor;
					}

					// pin the first point back to the control position
					this.points[0].x = this.x;
					this.points[0].y = this.y;
					this.points[0].z = this.z;

					// add a new posture to the front of the history
					var newPosture = [];
					x0 = this.points[0].x; // 4 control points
					y0 = this.points[0].y;
					z0 = this.points[0].z;
					x1 = this.points[1].x;
					y1 = this.points[1].y;
					z1 = this.points[1].z;
					x2 = this.points[2].x;
					y2 = this.points[2].y;
					z2 = this.points[2].z;
					x3 = this.points[3].x;
					y3 = this.points[3].y;
					z3 = this.points[3].z;
					for (i = 0; i < this.numLights; i++) {
						t = i / this.numLights;
						u = 1 - t;
						// 6th degree Bernstein polynomial
						var x = (P(t, 5) + 5 * P(t, 4) * u) * x0 + 10 * t * t * t * u * u * x1 + 10 * t * t * u * u * u * x2 + (5 * P(u, 4) * t + P(u, 5)) * x3;
						var y = (P(t, 5) + 5 * P(t, 4) * u) * y0 + 10 * t * t * t * u * u * y1 + 10 * t * t * u * u * u * y2 + (5 * P(u, 4) * t + P(u, 5)) * y3;
						var z = (P(t, 5) + 5 * P(t, 4) * u) * z0 + 10 * t * t * t * u * u * z1 + 10 * t * t * u * u * u * z2 + (5 * P(u, 4) * t + P(u, 5)) * z3;
						newPosture[i] = { x: x, y: y, z: z, frame: this.frame, col: { r: 1, g: 1, b: 1, a: 1 } }; // init white
					}
					this.pushPosture(newPosture);
					this.postureIdx++;

					// advance frame counter
					this.frame++;
				}
			};

			this.patterns = [];
			this.patterns["transparent"] = function (frame, pos, age, col) {
				col.r = 1;
				col.g = 1;
				col.b = 1;
				col.a = 0;
			};
			this.patterns["white"] = function (frame, pos, age, col) {
				col.r = 1;
				col.g = 1;
				col.b = 1;
				col.a = 1;
			};
			this.patterns["white fadeout"] = function (frame, pos, age, col) {
				col.r = 1;
				col.g = 1;
				col.b = 1;
				col.a = (1 - age / this.historyLength);
			};
			this.patterns["white stripes"] = function (frame, pos, age, col) {
				var pattern1 = (pos) % 4 == 0;
				var pattern2 = (pos + 1) % 4 == 0;
				var pattern = Math.max(pattern1, pattern2);
				col.r = pattern;
				col.g = pattern;
				col.b = pattern;
				col.a = (pattern - age / this.historyLength);
			};
			this.patterns["domain map"] = function (frame, pos, age, col) {
				var x = (frame % 64) / 64;
				var y = 2 * pos / this.numLights;
				col.r = x;
				col.g = y;
				col.b = 0;
				col.a = (1 - 0.5 * age / this.historyLength);
			};
			this.patterns["rgb sines"] = function (frame, pos, age, col) {
				var x = (frame % 64) / 64;
				var y = 2 * pos / this.numLights;
				var thickness = 0.05;
				var frequency = 0.25;
				var amplitude = 0.33;
				var sine1 = Math.sin(frame * frequency) * amplitude + 0.5;
				var sine1Mask = (y - sine1 - thickness < 0) * (y - sine1 + thickness > 0);
				var sine2 = Math.sin(frame * frequency + Math.PI * 2 / 3) * amplitude + 0.5;
				var sine2Mask = (y - sine2 - thickness < 0) * (y - sine2 + thickness > 0);
				var sine3 = Math.sin(frame * frequency - Math.PI * 2 / 3) * amplitude + 0.5;
				var sine3Mask = (y - sine3 - thickness < 0) * (y - sine3 + thickness > 0);
				col.r = sine1Mask;
				col.g = sine2Mask;
				col.b = sine3Mask;
				var alphaMask = Math.max(sine1Mask, Math.max(sine2Mask, sine3Mask));
				col.a = alphaMask;
			};
			this.patterns["cmy sines"] = function (frame, pos, age, col) {
				var x = (frame % 64) / 64;
				var y = 2 * pos / this.numLights;
				var thickness = 0.05;
				var frequency = 0.25;
				var amplitude = 0.33;
				var sine1 = Math.sin(frame * frequency) * amplitude + 0.5;
				var sine1Mask = (y - sine1 - thickness < 0) * (y - sine1 + thickness > 0);
				var sine2 = Math.sin(frame * frequency + Math.PI * 2 / 3) * amplitude + 0.5;
				var sine2Mask = (y - sine2 - thickness < 0) * (y - sine2 + thickness > 0);
				var sine3 = Math.sin(frame * frequency - Math.PI * 2 / 3) * amplitude + 0.5;
				var sine3Mask = (y - sine3 - thickness < 0) * (y - sine3 + thickness > 0);
				col.r = sine1Mask + sine2Mask;
				col.g = sine2Mask + sine3Mask;
				col.b = sine3Mask + sine1Mask;
				var alphaMask = Math.max(sine1Mask, Math.max(sine2Mask, sine3Mask));
				col.a = alphaMask;
			};
			this.patterns["compartments"] = function (frame, pos, age, col) {
				var y = pos / this.numLights;
				var bandThickness = 0.05;
				// baseline
				var band1Pos = 0.5;
				var thickness = 0.015;
				var band1Mask = (y - band1Pos - thickness < 0) * (y - band1Pos + thickness > 0);
				// divide
				var width = 24;
				var index = frame % width;
				var divide = (index == 0) ? 1 : 0;
				col.r = band1Mask + divide;
				col.g = band1Mask + divide;
				col.b = band1Mask + divide;
				var alphaMask = Math.max(band1Mask, Math.max(divide, 0));
				col.a = alphaMask;
			};
			this.patterns["heart"] = function (frame, pos, age, col) {
				var y = pos / this.numLights;
				var bandThickness = 0.05;
				var dotMask = (frame % 2 == 0 && pos % 2 == 0) ? 1 : 0;
				// baseline
				var band1Pos = 0.6;
				var thickness = 0.015;
				var band1Mask = (y - band1Pos - thickness < 0) * (y - band1Pos + thickness > 0);
				// divide compartments
				var num = 8;
				var width = 24;
				var index = frame % width;
				var divide = (index == 0) ? 1 : 0;
				var heartFrame = ((frame - index) / width % num == 0) ? 1 : 0;
				var cx = index / width - 0.5;
				var cy = (y - band1Pos) * 3 + Math.abs(index / width - 0.5) * 0.7;
				var d = Math.sqrt(cx * cx + cy * cy);
				var ang = Math.atan2(cy, cx);
				var heartMask = (d < 0.5) ? heartFrame : 0;
				heartFrame = heartMask;
				col.r = band1Mask + divide + heartFrame;
				col.g = band1Mask + divide + heartFrame;
				col.b = band1Mask + divide + heartFrame;
				var alphaMask = Math.max(band1Mask, Math.max(divide, heartFrame * (1 + 0 * dotMask)));
				col.a = alphaMask;
			};

			this.patterns["smiley"] = function (frame, pos, age, col) {
				var width = 16;
				var height = 16;

				var array = [
					[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
					[0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0],
					[0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0],
					[1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0],
					[1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0],
					[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
					[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
					[1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
				];

				var x = (frame % width);
				var offsety = 64;

				var y = pos - offsety;

				var mask = 0;
				if (y >= 0 && y < height) {
					mask = array[y][x];
				}

				col.r = mask;
				col.g = mask;
				col.b = mask;
				col.a = mask;
			};

			this.createTextPatternFn = function (text, bgBlackness) {
				var canvas = document.createElement("canvas");
				var ctx = canvas.getContext("2d");
				var font = "bold italic 18px arial";
				ctx.font = font;
				var l = Math.ceil(ctx.measureText(text).width);
				canvas.width = l;
				canvas.height = 16;

				ctx.fillStyle = "rgba(0,0,0," + bgBlackness + ")";
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				ctx.fillStyle = "#FFF";
				ctx.font = font;
				ctx.fillText(text, 0, 15);
				var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

				var patternFn = function (frame, pos, age, col) {
					var x = (frame % canvas.width);
					var offsety = 32;
					var y = pos - offsety;
					if (y >= 0 && y < canvas.height) {
						var i = (y * canvas.width + x) * 4;
						col.r = data[i + 0] / 256;
						col.g = data[i + 1] / 256;
						col.b = data[i + 2] / 256;
						col.a = data[i + 3] / 256;
					} else {
						col.r = 0;
						col.g = 0;
						col.b = 0;
						col.a = 0;
					}
				};

				return patternFn;
			}

			this.applyColor = this.patterns["rgb sines"]; // replace this anytime at runtime
			this.applyColor = this.createTextPatternFn("3D Web Fest 2016  ", 0.5);

			function P(m, e) {
				return Math.pow(m, e);
			}
			this.lastRenderFrame = 0;
			this.drawLightStreaks = function (context) {
				var framesSinceLastRender = this.frame - this.lastRenderFrame;
				this.lastRenderFrame = this.frame;
				var lightStreakLength = Math.min(this.postureHistory.length, framesSinceLastRender + 1);
				//lightStreakLength = this.postureHistory.length; // draw all history
				var p2d = {};
				for (lightID = 0; lightID < this.numLights; lightID++) {
					for (i = 1; i < lightStreakLength; i++) {
						var preposture = this.postureHistory[i - 1];
						var posture = this.postureHistory[i];
						if (posture[lightID] != undefined && preposture[lightID] != undefined) {
							this.applyColor(posture[lightID].frame, lightID, i, posture[lightID].col);
							var c = posture[lightID].col;
							if (c.a != 0) {
								context.beginPath();
								context.strokeStyle = "rgba(" + Math.floor(256 * c.r) + "," + Math.floor(256 * c.g) + "," + Math.floor(256 * c.b) + "," + c.a + ")";
								project(preposture[lightID], p2d);
								context.moveTo(p2d.x, p2d.y);
								project(posture[lightID], p2d);
								context.lineTo(p2d.x, p2d.y);
								context.stroke();
							}
						}
					}
				}
			}
		}

	</script>

	<script id="shader-vs" type="x-shader/x-vertex"> 
		attribute vec3 aPos;
		attribute vec2 aTexCoord;
		varying   vec2 uv;
		void main(void) {
			gl_Position = vec4(aPos, 1.);
			uv = aTexCoord;
		}
	</script>

	<script id="shader-fs-inc" type="x-shader/x-fragment">
		#ifdef GL_ES
		precision mediump float;
		#endif

		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_prev_n;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_blur2;
		uniform sampler2D sampler_blur3;
		uniform sampler2D sampler_blur4;
		uniform sampler2D sampler_blur5;
		uniform sampler2D sampler_blur6;
		uniform sampler2D sampler_noise;
		uniform sampler2D sampler_noise_n;
		uniform sampler2D sampler_fluid;
		uniform sampler2D sampler_fluid_p;
		uniform sampler2D sampler_particles;
		uniform sampler2D sampler_particle_projection;
		uniform sampler2D sampler_sticky_scene;
		uniform sampler2D sampler_poitoy_scene;

		varying vec2 uv;
		uniform vec2 texSize;
		uniform vec2 pixelSize;
		uniform vec2 aspect;
		uniform vec2 scale;

		uniform vec2 mouse;
		uniform vec2 mouseV;

		uniform float fps;
		uniform float time;
		uniform float frame;

		uniform vec4 rnd;
		uniform vec4 rainbow;

		uniform vec4 mover0;
		uniform int moverState0;
		uniform vec4 mover1;
		uniform int moverState1;
		uniform vec4 mover2;
		uniform int moverState2;
		uniform vec4 mover3;
		uniform int moverState3;
		uniform vec4 mover4;
		uniform int moverState4;
		uniform vec4 mover5;
		uniform int moverState5;
		uniform vec4 mover6;
		uniform int moverState6;
		uniform vec4 mover7;
		uniform int moverState7;
		uniform vec4 mover8;
		uniform int moverState8;
		uniform vec4 mover9;
		uniform int moverState9;
		uniform vec2 head0;
		uniform vec4 col0;
		uniform vec2 head1;
		uniform vec4 col1;
		uniform vec2 head2;
		uniform vec4 col2;
		uniform vec2 head3;
		uniform vec4 col3;
		uniform vec2 head4;
		uniform vec4 col4;
		uniform vec2 head5;
		uniform vec4 col5;
		uniform vec2 head6;
		uniform vec4 col6;
		uniform vec2 head7;
		uniform vec4 col7;
		uniform vec2 head8;
		uniform vec4 col8;
		uniform vec2 head9;
		uniform vec4 col9;

		uniform vec4 midifader1;
		uniform vec4 midifader2;
		uniform vec4 midiknob1;
		uniform vec4 midiknob2;
		
		vec4 BlurA(vec2 uv, int level)
		{
			if(level == 0)
			{
				return texture2D(sampler_prev, fract(uv));
			}
			if(level == 1)
			{
				return texture2D(sampler_blur, fract(uv));
			}
			if(level == 2)
			{
				return texture2D(sampler_blur2, fract(uv));
			}
			if(level == 3)
			{
				return texture2D(sampler_blur3, fract(uv));
			}
			if(level == 4)
			{
				return texture2D(sampler_blur4, fract(uv));
			}
			if(level == 5)
			{
				return texture2D(sampler_blur5, fract(uv));
			}
			return texture2D(sampler_blur6, uv);
		}

		vec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){
			vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);
			vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);
			return vec2( dot(dX, selector), dot(dY, selector) );
		}

		vec2 uv_zoom_exp(vec2 uv, vec2 center, vec2 aspect, float zoom, float zoom_exp, float zoom_factor){
			vec2 uv_correct = 0.5 + (uv -0.5)* aspect;
			vec2 center_correct = 0.5 + ( center - 0.5) * aspect;
			vec2 zoom_distorted = center_correct + (uv_correct - center_correct)*(1. - zoom * pow(zoom_exp, zoom_factor*length(uv_correct-center_correct)));
			return 0.5 + (zoom_distorted - 0.5) / aspect;
		}	
					
		bool is_onscreen(vec2 uv){
			return (uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.);
		}

		float filter(vec2 uv, vec2 pos){
			return clamp( 1.-length((uv-pos)*texSize)/2., 0. , 1.);
		}

		float border(vec2 uv, float border, vec2 texSize){
			uv*=texSize;
			return (uv.x<border || uv.x>texSize.x-border || uv.y<border || uv.y >texSize.y-border) ? 1.:.0;
		}

		#define pi 3.141592653589793238462643383279
		#define pi_inv 0.318309886183790671537767526745
		#define pi2_inv 0.159154943091895335768883763372

		float border(vec2 domain, float thickness){
			 vec2 uv = fract(domain-vec2(0.5));
			 uv = min(uv,1.-uv)*2.;
			 return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);
		}

		float square_mask(vec2 domain){
			return (domain.x <= 1. && domain.x >= 0. && domain.y <= 1. && domain.y >= 0.) ? 1. : 0.; 
		}

		vec2 complex_mul(vec2 factorA, vec2 factorB){
			 return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);
		}

		vec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){
			vec2 uv = domain - center;
			float d = length(uv);
			return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;
		}

		vec2 complex_div(vec2 numerator, vec2 denominator){
			 return vec2( numerator.x*denominator.x + numerator.y*denominator.y,
										numerator.y*denominator.x - numerator.x*denominator.y)/
							vec2(denominator.x*denominator.x + denominator.y*denominator.y);
		}

		// HSL to RGB converter code from http://www.gamedev.net/topic/465948-hsl-shader-glsl-code/
		float Hue_2_RGB(float v1, float v2, float vH )
		{
			float ret;
			 if ( vH < 0.0 )
				 vH += 1.0;
			 if ( vH > 1.0 )
				 vH -= 1.0;
			 if ( ( 6.0 * vH ) < 1.0 )
				 ret = ( v1 + ( v2 - v1 ) * 6.0 * vH );
			 else if ( ( 2.0 * vH ) < 1.0 )
				 ret = ( v2 );
			 else if ( ( 3.0 * vH ) < 2.0 )
				 ret = ( v1 + ( v2 - v1 ) * ( ( 2.0 / 3.0 ) - vH ) * 6.0 );
			 else
				 ret = v1;
			 return ret;
		}

		vec3 hsl2rgb(float H, float S, float L){
			float var_2, var_1, R, G, B;	
			if (S == 0.0)
			{
				 R = L;
				 G = L;
				 B = L;
			}
			else
			{
				 if ( L < 0.5 )
				 {
					 var_2 = L * ( 1.0 + S );
				 }
				 else
				 {
					 var_2 = ( L + S ) - ( S * L );
				 }

				 var_1 = 2.0 * L - var_2;

				 R = Hue_2_RGB( var_1, var_2, H + ( 1.0 / 3.0 ) );
				 G = Hue_2_RGB( var_1, var_2, H );
				 B = Hue_2_RGB( var_1, var_2, H - ( 1.0 / 3.0 ) );
			}
			return vec3(R,G,B);
		}

		float lum(vec4 col){
			return dot(col, vec4(0.3, 0.59, 0.11, 0.));
		}

		vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
			vec4 dX = texture2D(sampler, uv + vec2(1.,0.)*d) - texture2D(sampler, uv - vec2(1.,0.)*d);
			vec4 dY = texture2D(sampler, uv + vec2(0.,1.)*d) - texture2D(sampler, uv - vec2(0.,1.)*d);
			return -vec2( dot(dX, selector), dot(dY, selector) );
		}

		vec2 rot90(vec2 vector){
			return vector.yx*vec2(1,-1);
		}

		float circle(vec2 uv, vec2 aspect, float scale){
			return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);
		}

		float sigmoid(float x) {
			return 2./(1. + exp2(-x)) - 1.;
		}

		float smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){
			return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;
		}

	</script>

	<script id="shader-fs-copy" type="x-shader/x-fragment"> 
		uniform sampler2D source;
		void main(void) {
			gl_FragColor = texture2D(source, uv);
		}
	</script>

	<script id="shader-fs-init" type="x-shader/x-fragment"> 
		void main(void){
			gl_FragColor = vec4(0.);
		}
	</script>

	<script id="shader-fs-move-particles" type="x-shader/x-fragment"> 

		vec4 applyMoverForce(vec4 p, vec2 f00, int moverState, vec4 mover, vec4 col){
			if(col.a == 1. && (moverState == 4 || moverState == 3)){
				vec2 pos = (p.xy - mover.xy);
				float d = length(pos*aspect);

				float area = smoothcircle(p.xy-mover.xy+0.5, aspect, 0.66, 64.);
				float dir = 0.002;
				if( moverState == 3){
					dir = -0.004;
				}
				p.zw += pos * area * dir;
		
				//p.xy += mover.zw * float(d < 0.04); // simple window cleaner
			}
			return p;
		}

		vec4 applyMoverForces(vec4 p, vec2 foo){
			p = applyMoverForce(p, foo, moverState0, mover0, col0); // first person, left hand
			p = applyMoverForce(p, foo, moverState1, mover1, col0); // right hand
			p = applyMoverForce(p, foo, moverState2, mover2, col1); // second person
			p = applyMoverForce(p, foo, moverState3, mover3, col1);
			p = applyMoverForce(p, foo, moverState4, mover4, col2); // third
			p = applyMoverForce(p, foo, moverState5, mover5, col2);
			p = applyMoverForce(p, foo, moverState6, mover6, col3);
			p = applyMoverForce(p, foo, moverState7, mover7, col3);
			p = applyMoverForce(p, foo, moverState8, mover8, col4);
			p = applyMoverForce(p, foo, moverState9, mover9, col4);
			p.xy += foo;
			return p;
		}

		void main(void){
			vec4 p = texture2D(sampler_particles, uv); // residual location and velocity of the particle in the previous frame
			vec2 v = texture2D(sampler_fluid, p.xy).xz; // motion vector for the actual location from the advection field texture
			vec2 noise = texture2D(sampler_noise, uv + rnd.xy).xy;
			p.xy += v*scale;
			p.xy += noise*pixelSize/32.;
			p.xy += gradient(sampler_blur3, p.xy, pixelSize*16., vec4(1.,2,-1.,0.))*pixelSize;
			p.xy += gradient(sampler_blur2, p.xy, pixelSize*8., vec4(-2,2,1.,0.))*pixelSize;
			p.xy += gradient(sampler_blur, p.xy, pixelSize*4., vec4(-4, 2,4.,0.))*pixelSize;
			// reset position when off canvas
			gl_FragColor = mix( p, vec4(fract(p.xyz), 1.) , vec4((p.x < 0. || p.x > 1.)||(p.y < 0. || p.y > 1.)||(p.z < 0. || p.z > 1.)||(p.w < 0. || p.w > 1.)));

			gl_FragColor.zw = p.zw; 
		}
	</script>

	<script id="shader-fs-composite" type="x-shader/x-fragment"> 

		vec4 moverCol(int moverState){
			vec4 red = vec4(1,0,0,0);
			vec4 green = vec4(0,1,0,0);
			vec4 blue = vec4(0,0,1,0);

			vec4 cyan = vec4(0,1,1,0);
			vec4 yellow = vec4(1,1,0,0);

			vec4 purple = vec4(0.5,0,.50,0);

			vec4 col = purple; // unknown

			if(moverState == 1){ // lasso
				col = cyan;
			}
			if(moverState == 2){ // open
				col = red;
			}
			if(moverState == 3){ // closed
				col = green;
			}
			if(moverState == 4){ // pointy
				col = yellow;
			}
			return col;
		}

		void mixInMover(int moverState, vec4 mover, vec4 col){
			if(col.a == 1.){
				gl_FragColor = mix(gl_FragColor, moverCol(moverState), smoothcircle(uv-mover.xy+0.5, aspect, 0.025, 96.));
			}
		}

		void mixInMovers(){
			mixInMover(moverState0, mover0, col0); // first person, left hand
			mixInMover(moverState1, mover1, col0); // right hand

			mixInMover(moverState2, mover2, col1); // second person
			mixInMover(moverState3, mover3, col1);

			mixInMover(moverState4, mover4, col2); // third
			mixInMover(moverState5, mover5, col2);
			mixInMover(moverState6, mover6, col3);
			mixInMover(moverState7, mover7, col3);
			mixInMover(moverState8, mover8, col4);
			mixInMover(moverState9, mover9, col4);
		}

		float mouseFilter(vec2 uv){
			return clamp( 1.-length((uv-mouse)*texSize)/16., 0. , 1.);
		}

		void main(void) {		
			gl_FragColor = midifader1;
			float reserve =  0.5 + 0.5*sigmoid((texture2D(sampler_prev, uv).x-0.95)*16.);
			gl_FragColor = mix(gl_FragColor, midiknob1, reserve*2.); 
				
			vec2 uv_sticky = uv + gradient(sampler_blur, uv, pixelSize*3., vec4(-1024.,0.,0.,0.))*pixelSize*reserve;
		  float sticky = texture2D(sampler_sticky_scene, uv_sticky).g;
			float outline = length(gradient(sampler_prev, uv, pixelSize*1., vec4(4.,0.,0.,0.)))*reserve*96.;
			gl_FragColor = mix(gl_FragColor, midiknob2, sticky*1.5); 
			gl_FragColor = mix(gl_FragColor, midifader2, outline*(1.-sticky));			//mixInMovers();
			gl_FragColor.a = 1.;
		}
	</script>

	<script id="shader-fs-advance" type="x-shader/x-fragment"> 

		void main(void) {
			vec2 uv_orig = uv;
			vec2 fluid = texture2D(sampler_fluid, uv).xz * pixelSize;

			//zooms on head position;

			float zoom = -1.;
			float zoom_exp = 1./8.;
			float zoom_factor = 12.;
			zoom = 2.;
			zoom_exp = 1./10.;
			zoom_factor = 20.;
			vec2 uvr = uv;

			if(col0.a == 1.){
				uvr = uv_zoom_exp(uvr, head0.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col1.a == 1.){
				uvr = uv_zoom_exp(uvr, head1.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col2.a == 1.){
				uvr = uv_zoom_exp(uvr, head2.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col3.a == 1.){
				uvr = uv_zoom_exp(uvr, head3.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col4.a == 1.){
				uvr = uv_zoom_exp(uvr, head4.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col5.a == 1.){
				uvr = uv_zoom_exp(uvr, head5.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
		
			uvr -= fluid;

			float reserve = 0.5 - 0.5*sigmoid((texture2D(sampler_prev, uv).x-0.95)*192.);
		  uvr = mix(uv, uvr, reserve*0.5);

			gl_FragColor = texture2D(sampler_prev, uvr) - 0.004*reserve;
			gl_FragColor.a = 1.;
			gl_FragColor = clamp(gl_FragColor, 0. , 1.);
			gl_FragColor.a = 1.;		
			gl_FragColor = mix(gl_FragColor, vec4(1), texture2D(sampler_poitoy_scene, uv) );
			gl_FragColor = clamp(gl_FragColor, 0. , 1.);
			gl_FragColor.a = 1.;
		}
	</script>

	<script id="shader-fs-blur-horizontal" type="x-shader/x-fragment">
		// original shader from http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
		// horizontal blur fragment shader
		uniform sampler2D src_tex;

		void main(void) // fragment
		{
			float h = pixelSize.x;
			vec4 sum = vec4(0.0);
			sum += texture2D(src_tex, vec2(uv.x - 4.0*h, uv.y) ) * 0.05;
			sum += texture2D(src_tex, vec2(uv.x - 3.0*h, uv.y) ) * 0.09;
			sum += texture2D(src_tex, vec2(uv.x - 2.0*h, uv.y) ) * 0.12;
			sum += texture2D(src_tex, vec2(uv.x - 1.0*h, uv.y) ) * 0.15;
			sum += texture2D(src_tex, vec2(uv.x + 0.0*h, uv.y) ) * 0.16;
			sum += texture2D(src_tex, vec2(uv.x + 1.0*h, uv.y) ) * 0.15;
			sum += texture2D(src_tex, vec2(uv.x + 2.0*h, uv.y) ) * 0.12;
			sum += texture2D(src_tex, vec2(uv.x + 3.0*h, uv.y) ) * 0.09;
			sum += texture2D(src_tex, vec2(uv.x + 4.0*h, uv.y) ) * 0.05;
			gl_FragColor.xyz = sum.xyz/0.98; // normalize
			gl_FragColor.a = 1.;
		} 
	</script>

	<script id="shader-fs-blur-vertical" type="x-shader/x-fragment">
	uniform sampler2D src_tex;

	void main(void) // fragment
	{
		float v = pixelSize.y;
		vec4 sum = vec4(0.0);
		sum += texture2D(src_tex, vec2(uv.x, - 4.0*v + uv.y) ) * 0.05;
		sum += texture2D(src_tex, vec2(uv.x, - 3.0*v + uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x, - 2.0*v + uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x, - 1.0*v + uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x, + 0.0*v + uv.y) ) * 0.16;
		sum += texture2D(src_tex, vec2(uv.x, + 1.0*v + uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x, + 2.0*v + uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x, + 3.0*v + uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x, + 4.0*v + uv.y) ) * 0.05;
		gl_FragColor.xyz = sum.xyz/0.98;
		gl_FragColor.a = 1.;
	}
	</script>

	<script id="shader-fs-add-mouse-motion" type="x-shader/x-fragment"> 

		void main(void){
			vec2 v = texture2D(sampler_fluid, uv).xz;
			if(length(mouseV) > 0.){
				v = mix(v, mouseV, filter(uv, mouse)*0.85);
			}
			float scale = 8.;
			// first person left hand
			if(length(mover0.zw) > 0.){
				v = mix(v, mover0.zw*scale*texSize, filter(uv, mover0.xy)*0.85);
			}
			// first person right hand
			if(length(mover1.zw) > 0.){
				v = mix(v, mover1.zw*scale*texSize, filter(uv, mover1.xy)*0.85);
			}

			// second person left hand
			if(length(mover2.zw) > 0.){
				v = mix(v, mover2.zw*scale*texSize, filter(uv, mover2.xy)*0.85);
			}
			// second person right hand
			if(length(mover3.zw) > 0.){
				v = mix(v, mover3.zw*scale*texSize, filter(uv, mover3.xy)*0.85);
			}
			// third person left hand
			if(length(mover4.zw) > 0.){
				v = mix(v, mover4.zw*scale*texSize, filter(uv, mover4.xy)*0.85);
			}
			// third person right hand
			if(length(mover5.zw) > 0.){
				v = mix(v, mover5.zw*scale*texSize, filter(uv, mover5.xy)*0.85);
			}
			// 4th person left hand
			if(length(mover6.zw) > 0.){
				v = mix(v, mover6.zw*scale*texSize, filter(uv, mover6.xy)*0.85);
			}
			// 4th person right hand
			if(length(mover7.zw) > 0.){
				v = mix(v, mover7.zw*scale*texSize, filter(uv, mover7.xy)*0.85);
			}

			gl_FragColor.xz = v;
		}
	</script>

	<script id="shader-fs-advect" type="x-shader/x-fragment"> 

		const float dt = .0005;

		void main(void){
			vec2 v = texture2D(sampler_fluid, uv).xz;

			vec2 D = -texSize*vec2(v.x, v.y)*dt;

			 vec2 Df = floor(D),   Dd = D - Df;
			 vec2 uv = uv + Df*pixelSize;

			vec2 uv0, uv1, uv2, uv3;

			uv0 = uv + pixelSize*vec2(0.,0.);
			uv1 = uv + pixelSize*vec2(1.,0.);
			uv2 = uv + pixelSize*vec2(0.,1.);
			uv3 = uv + pixelSize*vec2(1.,1.);

			vec2 v0 = texture2D(sampler_fluid, uv0).xz;
			vec2 v1 = texture2D(sampler_fluid, uv1).xz;
			vec2 v2 = texture2D(sampler_fluid, uv2).xz;
			vec2 v3 = texture2D(sampler_fluid, uv3).xz;

			v = mix( mix( v0, v1, Dd.x), mix( v2, v3, Dd.x), Dd.y);

			gl_FragColor.xz = v*(1.-border(uv, 1., texSize));
		}
	</script>

	<script id="shader-fs-p" type="x-shader/x-fragment"> 
		uniform sampler2D sampler_v;
		uniform sampler2D sampler_p;
		const float h = 1./1024.;

		void main(void){

			vec2 v = texture2D(sampler_v, uv).xz;
			float v_x = texture2D(sampler_v, uv - vec2(1.,0.)*pixelSize).r;
			float v_y = texture2D(sampler_v, uv - vec2(0.,1.)*pixelSize).b;

			float n = texture2D(sampler_p, uv- pixelSize*vec2(0.,1.)).r;
			float w = texture2D(sampler_p, uv + pixelSize*vec2(1.,0.)).r;
			float s = texture2D(sampler_p, uv + pixelSize*vec2(0.,1.)).r;
			float e = texture2D(sampler_p, uv - pixelSize*vec2(1.,0.)).r;

			float p = ( n + w + s + e - (v.x - v_x + v.y - v_y)*h ) * .25;

			gl_FragColor.r = p;
			gl_FragColor.ba = vec2(0.); // unused
		}
	</script>

	<script id="shader-fs-div" type="x-shader/x-fragment"> 
		uniform sampler2D sampler_v;
		uniform sampler2D sampler_p;

		void main(void){
			float p = texture2D(sampler_p, uv).r;
			vec2 v = texture2D(sampler_v, uv).xz;
			float p_x = texture2D(sampler_p, uv + vec2(1.,0.)*pixelSize).r;
			float p_y = texture2D(sampler_p, uv + vec2(0.,1.)*pixelSize).r;

			v -= (vec2(p_x, p_y)-p)*512.;

			gl_FragColor.xz = v;
		}
	</script>

	<script type="x-shader/x-vertex" id="shader-particle-renderer-vs"> 
		attribute vec2 uv; // particle position lookup vector
		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_particles; // particle positions in a float texture
		uniform vec2 mouse;
		uniform vec2 pixelSize;
			
		vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
			vec4 dX = 0.5*texture2D(sampler, uv + vec2(1.,0.)*d) - 0.5*texture2D(sampler, uv - vec2(1.,0.)*d);
			vec4 dY = 0.5*texture2D(sampler, uv + vec2(0.,1.)*d) - 0.5*texture2D(sampler, uv - vec2(0.,1.)*d);
			return vec2( dot(dX, selector), dot(dY, selector) );
		}

		void main() {
			gl_Position = (texture2D(sampler_particles, uv) - 0.5)*2.; // pass em flat
			gl_Position.xy += gradient(sampler_blur, gl_Position.xy*0.5+0.5, pixelSize*3., vec4(1,-0.,0,0))*pixelSize*32.;

			gl_Position.zw = vec2(0,1);
			gl_PointSize = 1.;	
		}
	</script>

	<script type="x-shader/x-fragment" id="shader-particle-renderer-fs"> 
		void main() {
			gl_FragColor = vec4(0.6, 0.7, 1.0, 0.4);
		}
	</script>

	<script type="text/javascript">
		function getShader(gl, id, addInc) {
			if (addInc == undefined) {
				addInc = true;
			}

			var shaderScript = document.getElementById(id);
			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					str += k.textContent;
				k = k.nextSibling;
			}

			var fsIncScript = document.getElementById("shader-fs-inc");
			var incStr = "";
			k = fsIncScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					incStr += k.textContent;
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				if (addInc) {
					str = incStr + str;
				}
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex")
				shader = gl.createShader(gl.VERTEX_SHADER);
			else
				return null;
			gl.shaderSource(shader, str);
			gl.compileShader(shader);
			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
				alert("error compiling shader '" + id + "'\n\n" + gl.getShaderInfoLog(shader));
			return shader;
		}

		window.requestAnimFrame = (function () {
			return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame
					|| window.msRequestAnimationFrame || function (callback) {
						window.setTimeout(callback, 1000 / desiredFramerate);
					};
		})();

		var gl;
		var ext;

		var prog_copy;
		var prog_advance;
		var prog_composite;
		var prog_blur_horizontal;
		var prog_blur_vertical;
		var prog_fluid_init;
		var prog_fluid_add_mouse_motion;
		var prog_fluid_advect;
		var prog_fluid_p;
		var prog_fluid_div;
		var prog_move_particles;
		var prog_render_particles;

		var FBO_main;
		var FBO_main2;
		var FBO_noise;
		var FBO_blur;
		var FBO_blur2;
		var FBO_blur3;
		var FBO_blur4;
		var FBO_blur5;
		var FBO_blur6;
		var FBO_helper;
		var FBO_helper2;
		var FBO_helper3;
		var FBO_helper4;
		var FBO_helper5;
		var FBO_helper6;
		var FBO_fluid_v;
		var FBO_fluid_p;
		var FBO_fluid_store;
		var FBO_fluid_backbuffer;
		var FBO_particles; // particle positions in a texture
		var FBO_particles2; // double buffer
		var FBO_particle_projection; // particle render target for projection feedback effects
		var FBO_sticky_scene; // we will copy a 2d drawn scene to a webgl texture using this
		var FBO_poitoy_scene; // 2d drawn scene to webgl texture too

		var texture_main_n; // main, nearest pixel
		var texture_main_l; // main, linear interpolated access on the same buffer
		var texture_main2_n; // main double buffer, nearest
		var texture_main2_l; // main double buffer, linear
		var texture_blur; // full resolution blur result
		var texture_blur2; // double blur
		var texture_blur3; // quad blur
		var texture_blur4; // use low resolutions wisely ;)
		var texture_blur5;
		var texture_blur6;
		var texture_helper; // needed for multi-pass shader programs (2-pass Gaussian blur)
		var texture_helper2; // (1/4 resolution )
		var texture_helper3; // (1/16 resolution )
		var texture_helper4; // (1/256 resolution )
		var texture_helper5;
		var texture_helper6;
		var texture_noise_n; // nearest pixel access
		var texture_noise_l; // linear interpolated
		var texture_fluid_v; // velocities
		var texture_fluid_p; // pressure
		var texture_fluid_store;
		var texture_fluid_backbuffer;
		var texture_particles;
		var texture_particles2;
		var texture_particle_projection;
		var texture_sticky_scene;
		var texture_poitoy_scene;

		// main texture loop dimensions
		var sizeX = 1024; // must be powers of 2
		var sizeY = 512;
		var viewX = sizeX; // viewport size (ideally exactly the texture size)
		var viewY = sizeY;

		// particle positions will be stored in a texture of that size
		var particlesWidth = 1024;
		var particlesHeight = 512;
		var particleCount = particlesWidth * particlesHeight; // can also be set to lower than particlesWidth * particlesHeight

		var useParticles = false;
		var useProjectionFeedback = false; // rendering half a million points can slow things down significantly, don't render to texture if not needed
		var useFluidSimulation = true; // the textures will be initialized anyway
		var simScale = 8; // for better performance, the fluid simulation will be calculated for cells this times bigger than the main texture's pixels (powers of 2)

		var desiredFramerate = 100; // more like a limit
		var startFullpage = true;
		var renderParticlesOnly = false;

		// don't change vars below
		var canvas2d;
		var canvas2dContext;

		var frame = 0; // frame counter to be resetted every 1000ms
		var framecount = 0; // not resetted
		var mainBufferToggle = 1;
		var halted = false;
		var fps, fpsDisplayUpdateTimer;
		var time, starttime = new Date().getTime();

		var mouseX = 0.5;
		var mouseY = 0.5;
		var oldMouseX = 0;
		var oldMouseY = 0;
		var mouseDx = 0;
		var mouseDy = 0;

		var aspectx = 2;
		var aspecty = 1;

		// geometry
		var particleBuffer, squareBuffer, hLineBuffer, vLineBuffer;

		function updateApectRatio() {
			aspectx = Math.max(1, viewX / viewY);
			aspecty = Math.max(1, viewY / viewX);
		}

		function load() {
			clearInterval(fpsDisplayUpdateTimer);
			canvas2d = document.createElement("canvas");
			canvas2d.width = sizeX;
			canvas2d.height = sizeY;
			canvas2dContext = canvas2d.getContext("2d");
			var c = document.getElementById("c");
			try {
				gl = c.getContext("experimental-webgl", {
					depth: false
				});
			} catch (e) {
			}
			if (!gl) {
				alert("Meh! Y u no support experimental WebGL !?!");
				return;
			}

			["OES_texture_float", "OES_standard_derivatives", "OES_texture_float_linear"].forEach(function (name) {
				console.log("check " + name);
				try {
					ext = gl.getExtension(name);
				} catch (e) {
					alert(e);
				}
				if (!ext) {
					alert("Meh! Y u no support " + name + " !?!)");
					return;
				}
				ext = false;
			});

			if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0) {
				alert("Meh! Y u no support vertex shader textures !?!");
				return;
			}

			document.onmousemove = function (evt) {
				mouseX = evt.pageX / viewX;
				mouseY = 1 - evt.pageY / viewY;
			};

			document.addEventListener("orientationchange", window.onresize = function () {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
				c.width = viewX;
				c.height = viewY;
				updateApectRatio();
			});


			if (startFullpage) {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
			}

			c.width = viewX;
			c.height = viewY;

			prog_copy = createAndLinkProgram("shader-fs-copy");
			prog_advance = createAndLinkProgram("shader-fs-advance");
			prog_composite = createAndLinkProgram("shader-fs-composite");
			prog_blur_horizontal = createAndLinkProgram("shader-fs-blur-horizontal");
			prog_blur_vertical = createAndLinkProgram("shader-fs-blur-vertical");
			prog_fluid_init = createAndLinkProgram("shader-fs-init");
			prog_fluid_add_mouse_motion = createAndLinkProgram("shader-fs-add-mouse-motion");
			prog_fluid_advect = createAndLinkProgram("shader-fs-advect");
			prog_fluid_p = createAndLinkProgram("shader-fs-p");
			prog_fluid_div = createAndLinkProgram("shader-fs-div");
			prog_move_particles = createAndLinkProgram("shader-fs-move-particles");

			triangleStripGeometry = {
				vertices: new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]),
				texCoords: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
				vertexSize: 3,
				vertexCount: 4,
				type: gl.TRIANGLE_STRIP
			};

			createTexturedGeometryBuffer(triangleStripGeometry);

			hLineVertices = [];
			hLineTexCoords = [];
			for (var y = 0; y < sizeY; y++) {
				hLineVertices.push(-1, -1 + 2 * y / sizeY, 0, 1, -1 + 2 * y / sizeY, 0);
				hLineTexCoords.push(0. / sizeX, (y - 0.5) / sizeY, (sizeX + 0.) / sizeX, (y - 0.5) / sizeY);
			}
			hLineGeometry = {
				vertices: new Float32Array(hLineVertices),
				texCoords: new Float32Array(hLineTexCoords),
				vertexSize: 3,
				vertexCount: sizeY * 2,
				type: gl.LINES
			};

			vLineVertices = [];
			vLineTexCoords = [];
			for (var x = 0; x < sizeX; x++) {
				vLineVertices.push(-1 + 2 * x / sizeX, -1, 0, -1 + 2 * x / sizeX, 1, 0);
				vLineTexCoords.push((x - 0.5) / sizeX, 0. / sizeY, (x - 0.5) / sizeX, (sizeY + 0.) / sizeY);
			}
			vLineGeometry = {
				vertices: new Float32Array(vLineVertices),
				texCoords: new Float32Array(vLineTexCoords),
				vertexSize: 3,
				vertexCount: sizeX * 2,
				type: gl.LINES
			};

			createTexturedGeometryBuffer(hLineGeometry);
			createTexturedGeometryBuffer(vLineGeometry);

			squareBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer);

			var aPosLoc = gl.getAttribLocation(prog_advance, "aPos");
			var aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");

			gl.enableVertexAttribArray(aPosLoc);
			gl.enableVertexAttribArray(aTexLoc);

			var verticesAndTexCoords = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1, // one square of a quad!
			0, 0, 1, 0, 0, 1, 1, 1] // hello texture, you be full
			);

			gl.bufferData(gl.ARRAY_BUFFER, verticesAndTexCoords, gl.STATIC_DRAW);
			gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 8, 0);
			gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 8, 32);

			var noisePixels = [], pixels = [], simpixels = [], pixels2 = [], pixels3 = [], pixels4 = [], pixels5 = [], pixels6 = [], particles = [], particlesIdx = [];
			var dX = 1 / particlesWidth;
			var dY = 1 / particlesHeight;
			for (var j = 0; j < sizeY; j++) {
				for (var i = 0; i < sizeX; i++) {
					noisePixels.push(Math.random(), Math.random(), Math.random(), Math.random());
					pixels.push(0, 0, 0, 1);
					if (i < sizeX / simScale && j < sizeY / simScale)
						simpixels.push(0, 0, 0, 1);
					if (i < sizeX / 2 && j < sizeY / 2)
						pixels2.push(0, 0, 0, 1);
					if (i < sizeX / 4 && j < sizeY / 4)
						pixels3.push(0, 0, 0, 1);
					if (i < sizeX / 8 && j < sizeY / 8)
						pixels4.push(0, 0, 0, 1);
					if (i < sizeX / 16 && j < sizeY / 16)
						pixels5.push(0, 0, 0, 1);
					if (i < sizeX / 32 && j < sizeY / 32)
						pixels6.push(0, 0, 0, 1);
					if (i < particlesWidth && j < particlesHeight) {
						particles.push(dX / 2 + i * dX, dY / 2 + j * dY, 0, 0); // initial particle positions, here: uniform distribution
					}
				}
			}

			for (var i = 0; i < particlesHeight; i++) {
				for (var j = 0; j < particlesWidth; j++) {
					particlesIdx.push(dX / 2 + j * dX, dY / 2 + i * dY); // coordinate lookup vectors (center of pixels)
				}
			}

			FBO_main = gl.createFramebuffer();
			FBO_main2 = gl.createFramebuffer();
			var glPixels;
			glPixels = new Float32Array(noisePixels);
			texture_main_n = createAndBindTexture(glPixels, 1, FBO_main, gl.NEAREST);
			texture_main2_n = createAndBindTexture(glPixels, 1, FBO_main2, gl.NEAREST);
			glPixels = new Float32Array(noisePixels);
			texture_main_l = createAndBindTexture(glPixels, 1, FBO_main, gl.LINEAR);
			texture_main2_l = createAndBindTexture(glPixels, 1, FBO_main2, gl.LINEAR);

			FBO_fluid_p = gl.createFramebuffer();
			FBO_fluid_v = gl.createFramebuffer();
			FBO_fluid_store = gl.createFramebuffer();
			FBO_fluid_backbuffer = gl.createFramebuffer();
			texture_fluid_v = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_v);
			texture_fluid_p = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_p);
			texture_fluid_store = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_store);
			texture_fluid_backbuffer = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_backbuffer);

			FBO_particle_projection = gl.createFramebuffer();
			texture_particle_projection = createAndBindTexture(new Float32Array(pixels), 1, FBO_particle_projection, gl.LINEAR);

			FBO_helper = gl.createFramebuffer();
			FBO_helper2 = gl.createFramebuffer();
			FBO_helper3 = gl.createFramebuffer();
			FBO_helper4 = gl.createFramebuffer();
			FBO_helper5 = gl.createFramebuffer();
			FBO_helper6 = gl.createFramebuffer();
			texture_helper = createAndBindTexture(new Float32Array(pixels), 1, FBO_helper, gl.NEAREST); // helper buffers for the two-pass Gaussian blur calculation basically
			texture_helper2 = createAndBindTexture(new Float32Array(pixels2), 2, FBO_helper2, gl.NEAREST);
			texture_helper3 = createAndBindTexture(new Float32Array(pixels3), 4, FBO_helper3, gl.NEAREST);
			texture_helper4 = createAndBindTexture(new Float32Array(pixels4), 8, FBO_helper4, gl.NEAREST);
			texture_helper5 = createAndBindTexture(new Float32Array(pixels5), 16, FBO_helper5, gl.NEAREST);
			texture_helper6 = createAndBindTexture(new Float32Array(pixels6), 32, FBO_helper6, gl.NEAREST);

			FBO_blur = gl.createFramebuffer();
			FBO_blur2 = gl.createFramebuffer();
			FBO_blur3 = gl.createFramebuffer();
			FBO_blur4 = gl.createFramebuffer();
			FBO_blur5 = gl.createFramebuffer();
			FBO_blur6 = gl.createFramebuffer();
			texture_blur = createAndBindTexture(new Float32Array(pixels), 1, FBO_blur, gl.LINEAR);
			texture_blur2 = createAndBindTexture(new Float32Array(pixels2), 2, FBO_blur2, gl.LINEAR);
			texture_blur3 = createAndBindTexture(new Float32Array(pixels3), 4, FBO_blur3, gl.LINEAR);
			texture_blur4 = createAndBindTexture(new Float32Array(pixels4), 8, FBO_blur4, gl.LINEAR);
			texture_blur5 = createAndBindTexture(new Float32Array(pixels5), 16, FBO_blur5, gl.LINEAR);
			texture_blur6 = createAndBindTexture(new Float32Array(pixels6), 32, FBO_blur6, gl.LINEAR);

			FBO_sticky_scene = gl.createFramebuffer();
			texture_sticky_scene = createAndBindTexture(new Uint8Array(pixels), 1, FBO_sticky_scene, gl.LINEAR, gl.UNSIGNED_BYTE);

			FBO_poitoy_scene = gl.createFramebuffer();
			texture_poitoy_scene = createAndBindTexture(new Uint8Array(pixels), 1, FBO_poitoy_scene, gl.LINEAR, gl.UNSIGNED_BYTE);

			FBO_noise = gl.createFramebuffer();
			glPixels = new Float32Array(noisePixels);
			texture_noise_n = createAndBindTexture(glPixels, 1, FBO_noise, gl.NEAREST);
			texture_noise_l = createAndBindTexture(glPixels, 1, FBO_noise, gl.LINEAR);

			FBO_particles = gl.createFramebuffer();
			texture_particles = createAndBindParticleTexture(new Float32Array(particles), FBO_particles);

			FBO_particles2 = gl.createFramebuffer();
			texture_particles2 = createAndBindParticleTexture(new Float32Array(particles), FBO_particles2);

			// lesson learned: the (frame) buffer location that we pass to the vertex shader has to be bound to the program before linking!

			var aParticleLoc = 2; // no getAttributeLoc
			prog_render_particles = createAndLinkParticleRenderer(aParticleLoc);

			gl.useProgram(prog_render_particles);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 0);

			gl.enableVertexAttribArray(aParticleLoc);
			particleBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particlesIdx), gl.STATIC_DRAW);
			gl.vertexAttribPointer(aParticleLoc, 2, gl.FLOAT, false, 0, 0);

			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur);
			gl.activeTexture(gl.TEXTURE3);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur2);
			gl.activeTexture(gl.TEXTURE4);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur3);
			gl.activeTexture(gl.TEXTURE5);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur4);
			gl.activeTexture(gl.TEXTURE6);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur5);
			gl.activeTexture(gl.TEXTURE7);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur6);
			gl.activeTexture(gl.TEXTURE8);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_l);
			gl.activeTexture(gl.TEXTURE9);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_n);
			gl.activeTexture(gl.TEXTURE10);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE11);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.activeTexture(gl.TEXTURE12);
			gl.bindTexture(gl.TEXTURE_2D, texture_particles); // to be swapped anyways
			gl.activeTexture(gl.TEXTURE13);
			gl.bindTexture(gl.TEXTURE_2D, texture_particle_projection);
			gl.activeTexture(gl.TEXTURE14);
			gl.bindTexture(gl.TEXTURE_2D, texture_sticky_scene);
			gl.activeTexture(gl.TEXTURE15);
			gl.bindTexture(gl.TEXTURE_2D, texture_poitoy_scene);

			fluidInit(FBO_fluid_v);
			fluidInit(FBO_fluid_p);
			fluidInit(FBO_fluid_store);
			fluidInit(FBO_fluid_backbuffer);

			fpsDisplayUpdateTimer = setInterval(fr, 1000);
			time = new Date().getTime() - starttime;

			gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			gl.clearColor(0, 0, 0, 1);

			anim();
		}

		function createTexturedGeometryBuffer(geometry) {
			geometry.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			geometry.aPosLoc = gl.getAttribLocation(prog_advance, "aPos"); // we could take any program here, they all use the same vertex shader
			gl.enableVertexAttribArray(geometry.aPosLoc);
			geometry.aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");
			gl.enableVertexAttribArray(geometry.aTexLoc);
			geometry.texCoordOffset = geometry.vertices.byteLength;
			gl.bufferData(gl.ARRAY_BUFFER, geometry.texCoordOffset + geometry.texCoords.byteLength, gl.STATIC_DRAW);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, geometry.vertices);
			gl.bufferSubData(gl.ARRAY_BUFFER, geometry.texCoordOffset, geometry.texCoords);
			setGeometryVertexAttribPointers(geometry);
		}

		function setGeometryVertexAttribPointers(geometry) {
			gl.vertexAttribPointer(geometry.aPosLoc, geometry.vertexSize, gl.FLOAT, gl.FALSE, 0, 0);
			gl.vertexAttribPointer(geometry.aTexLoc, 2, gl.FLOAT, gl.FALSE, 0, geometry.texCoordOffset);
		}

		function createAndLinkProgram(fsId) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-vs"));
			gl.attachShader(program, getShader(gl, fsId));
			gl.linkProgram(program);
			return program;
		}

		function createAndLinkParticleRenderer(aParticleLoc) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-vs"));
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-fs", false));
			gl.bindAttribLocation(program, aParticleLoc, "uv"); // can't use getAttribLocation later so we must bind before linking
			gl.linkProgram(program);
			return program;
		}

		function createAndBindTexture(glPixels, scale, fbo, filter, type) {
			if (type == undefined) {
				type = gl.FLOAT;
			}
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / scale, sizeY / scale, 0, gl.RGBA, type, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindParticleTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, particlesWidth, particlesHeight, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindSimulationTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / simScale, sizeY / simScale, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function fluidInit(fbo) {
			gl.viewport(0, 0, sizeX / simScale, sizeY / simScale);
			gl.useProgram(prog_fluid_init);
			renderAsTriangleStrip(fbo);
		}

		function setUniforms(program) {
			gl.uniform4f(gl.getUniformLocation(program, "rnd"), Math.random(), Math.random(), Math.random(), Math.random());
			gl.uniform4f(gl.getUniformLocation(program, "rainbow"), rainbowR, rainbowG, rainbowB, 1);
			gl.uniform2f(gl.getUniformLocation(program, "texSize"), sizeX, sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(program, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(program, "mouseV"), mouseDx, mouseDy);
			gl.uniform1f(gl.getUniformLocation(program, "fps"), fps);
			gl.uniform1f(gl.getUniformLocation(program, "time"), time);
			gl.uniform1f(gl.getUniformLocation(program, "frame"), framecount);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur"), 2);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur2"), 3);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur3"), 4);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur4"), 5);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur5"), 6);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur6"), 7);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise"), 8);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise_n"), 9);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid"), 10);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid_p"), 11);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particles"), 12);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particle_projection"), 13);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_sticky_scene"), 14);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_poitoy_scene"), 15);

			gl.uniform4f(gl.getUniformLocation(program, "midifader1"), getMidi(0), getMidi(1), getMidi(2), getMidi(3));
			gl.uniform4f(gl.getUniformLocation(program, "midifader2"), getMidi(4), getMidi(5), getMidi(6), getMidi(7));
			gl.uniform4f(gl.getUniformLocation(program, "midiknob1"), getMidi(16), getMidi(17), getMidi(18), getMidi(19));
			gl.uniform4f(gl.getUniformLocation(program, "midiknob2"), getMidi(20), getMidi(21), getMidi(22), getMidi(23));

			setMoverUniforms(program);
		}

		var colors = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1], [0, 1, 1]]; // red green blue yellow magenta cyan

		function setMoverUniforms(program) {
			// push it
			var moverIndex = 0;
			var bodyIndex = 0;
			// project it
			var p3d = {};
			var p2d = {};
			activeTrackingObjects.forEach(function (trackingObject) {
				var stickman = trackingObject.stickman;
				var body = trackingObject.body;
				project(body.head, p2d); // current projection
				var x = p2d.x / sizeX;
				var y = 1 - p2d.y / sizeY;
				gl.uniform2f(gl.getUniformLocation(program, "head" + bodyIndex), x, y);
				var col = colors[bodyIndex];
				gl.uniform4f(gl.getUniformLocation(program, "col" + bodyIndex), col[0], col[1], col[2], 1);
				bodyIndex++;
				// left hand
				project(body.handLeft, p2d); // current projection
				var x = p2d.x / sizeX;
				var y = 1 - p2d.y / sizeY;
				project(body.handLeft.old, p2d); // previous projection
				var old = {};
				old.x = p2d.x / sizeX;
				old.y = 1 - p2d.y / sizeY;
				var dx = (x - old.x); // difference = velocity
				var dy = (y - old.y);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				var state = body.handLeft.state;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), x, y, dx, dy);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), state);
				moverIndex++;
				// right hand
				project(body.handRight, p2d);
				x = p2d.x / sizeX;
				y = 1 - p2d.y / sizeY;
				project(body.handRight.old, p2d);
				old.x = p2d.x / sizeX;
				old.y = 1 - p2d.y / sizeY;
				dx = (x - old.x);
				dy = (y - old.y);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				state = body.handRight.state;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), x, y, dx, dy);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), state);
				moverIndex++;
			});
			// init untracked players
			for (var index = moverIndex; index < 12; index++) {
				gl.uniform4f(gl.getUniformLocation(program, "col" + bodyIndex), 0, 0, 0, 0);
				bodyIndex++;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), 0);
				moverIndex++;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), 0);
				moverIndex++
			}
		}

		function useGeometry(geometry) {
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			setGeometryVertexAttribPointers(geometry);
		}

		function renderGeometry(geometry, targetFBO) {
			useGeometry(geometry);
			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.drawArrays(geometry.type, 0, geometry.vertexCount);
			gl.flush();
		}

		function renderAsTriangleStrip(targetFBO) {
			renderGeometry(triangleStripGeometry, targetFBO);
		}

		function renderParticles(targetFBO, clear) {
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);

			if (targetFBO == null)
				gl.viewport(0, 0, viewX, viewY);
			else
				gl.viewport(0, 0, sizeX, sizeY);

			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.useProgram(prog_render_particles);

			gl.activeTexture(gl.TEXTURE12);
			if (mainBufferToggle < 0) {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
			} else {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
			}

			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 12); // input for the vertex shader
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_blur"), 2);

			if (clear == undefined || clear) {
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			}

			gl.enable(gl.BLEND);
			gl.drawArrays(gl.POINTS, 0, particleCount);
			gl.disable(gl.BLEND);

			gl.flush();
		}

		function updateStickySceneTexture() {
			gl.activeTexture(gl.TEXTURE14);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2d);
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_sticky_scene);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_sticky_scene, 0);
		}

		function updatePoiToySceneTexture() {
			gl.activeTexture(gl.TEXTURE15);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2d);
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_poitoy_scene);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_poitoy_scene, 0);
		}

		function calculateBlurTextures(texture_source) {
			calculateBlurTexture(texture_source, texture_blur, FBO_blur, texture_helper, FBO_helper, 1);
			calculateBlurTexture(texture_blur, texture_blur2, FBO_blur2, texture_helper2, FBO_helper2, 2);
			calculateBlurTexture(texture_blur2, texture_blur3, FBO_blur3, texture_helper3, FBO_helper3, 4);
			calculateBlurTexture(texture_blur3, texture_blur4, FBO_blur4, texture_helper4, FBO_helper4, 8);
			calculateBlurTexture(texture_blur4, texture_blur5, FBO_blur5, texture_helper5, FBO_helper5, 16);
			calculateBlurTexture(texture_blur5, texture_blur6, FBO_blur6, texture_helper6, FBO_helper6, 32);
		}

		function calculateBlurTexture(sourceTex, targetTex, targetFBO, helperTex, helperFBO, scale) {
			// copy source
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, sourceTex);
			renderAsTriangleStrip(targetFBO);

			// blur vertically
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_vertical);
			gl.uniform2f(gl.getUniformLocation(prog_blur_vertical, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, targetTex);
			renderAsTriangleStrip(helperFBO);

			// blur horizontally
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_horizontal);
			gl.uniform2f(gl.getUniformLocation(prog_blur_horizontal, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, helperTex);
			renderAsTriangleStrip(targetFBO);

		}

		function stepParticles() {
			gl.viewport(0, 0, particlesWidth, particlesHeight);
			gl.useProgram(prog_move_particles);
			setUniforms(prog_move_particles);

			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				renderAsTriangleStrip(FBO_particles2)
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				renderAsTriangleStrip(FBO_particles);
			}
		}

		function fluidSimulationStep() {
			addMouseMotion();
			advect();
			diffuse();
		}

		function addMouseMotion() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_add_mouse_motion);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			setUniforms(prog_fluid_add_mouse_motion);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "texSize"), (sizeX / simScale), (sizeY / simScale));
			renderAsTriangleStrip(FBO_fluid_backbuffer);
		}

		function advect() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_advect);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "texSize"), (sizeX / simScale), (sizeY / simScale));
			renderAsTriangleStrip(FBO_fluid_v);
		}

		function diffuse() {
			for (var i = 0; i < 8; i++) {
				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_backbuffer);

				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_p);
			}


			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_div);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "texSize"), (sizeX / simScale), (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_v"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_p"), 1);
			renderAsTriangleStrip(FBO_fluid_backbuffer);

			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			renderAsTriangleStrip(FBO_fluid_v);
		}

		// main texture feedback warp
		function advance() {
			gl.viewport(0, 0, sizeX, sizeY);
			gl.useProgram(prog_advance);
			setUniforms(prog_advance);
			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l); // interpolated input
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n); // "nearest" input
				renderAsTriangleStrip(FBO_main2);
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l); // interpolated
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n); // "nearest"
				renderAsTriangleStrip(FBO_main);
			}
			mainBufferToggle = -mainBufferToggle;
		}

		function composite() {
			gl.viewport(0, 0, viewX, viewY);
			gl.useProgram(prog_composite);
			setUniforms(prog_composite);
			if (mainBufferToggle < 0) {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n);
			} else {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n);
			}
			renderAsTriangleStrip(null);
		}

		var rainbowR, rainbowG, rainbowB, w = Math.PI * 2 / 3;

		function anim() {
			setTimeout("requestAnimationFrame(anim)", 1000 / desiredFramerate);

			updateStickMen();

			canvas2dContext.fillStyle = "#000";

			canvas2dContext.fillRect(0, 0, sizeX, sizeY);
			canvas2dContext.strokeStyle = "#FFF";
			//drawSpline(canvas2dContext, controls);
			drawStickMen(canvas2dContext);
			updateStickySceneTexture();

			canvas2dContext.fillStyle = "#000";
			canvas2dContext.fillRect(0, 0, sizeX, sizeY);

			canvas2dContext.lineWidth = 1.5;
			drawPoiToys(canvas2dContext);
			updatePoiToySceneTexture();

			time = new Date().getTime() - starttime;

			var t = time / 150;

			rainbowR = 0.5 + 0.5 * Math.sin(t);
			rainbowG = 0.5 + 0.5 * Math.sin(t + w);
			rainbowB = 0.5 + 0.5 * Math.sin(t - w);

			if (oldMouseX != 0 && oldMouseY != 0) {
				mouseDx = (mouseX - oldMouseX) * viewX;
				mouseDy = (mouseY - oldMouseY) * viewY;
			}

			if (!halted) {

				if (useProjectionFeedback)
					renderParticles(FBO_particle_projection);

				if (useFluidSimulation)
					fluidSimulationStep();

				if (useParticles)
					stepParticles();

				advance();

				var srcTex = (mainBufferToggle < 0) ? texture_main2_l : texture_main_l;

				calculateBlurTextures(srcTex);

				frame++;
				framecount++;
			}

			if (renderParticlesOnly) {
				gl.viewport(0, 0, viewX, viewY);
				gl.useProgram(prog_copy);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_sticky_scene);
				renderAsTriangleStrip(null);
				renderParticles(null, false);
			}
			else {
				composite();
			}
			frames++;

			oldMouseX = mouseX;
			oldMouseY = mouseY;

		}

		function fr() { // updates every second
			document.getElementById("fps").textContent = frame;
			frame = 0; // reset the frame counter
		}

		var hidden = false;
		function hide() {
			hidden = !hidden;
			document.getElementById("desc").style.setProperty('visibility', hidden ? 'hidden' : 'visible');
		}

		function goFull(cb) {
			if (cb.checked) {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
			} else {
				viewX = sizeX;
				viewY = sizeY;
			}
			c.width = viewX;
			c.height = viewY;
			updateApectRatio();
		}

		function setDesiredFps(tb) {
			desiredFramerate = tb.value;
			if (desiredFramerate < 1)
				desiredFPS = 1;
		}

		function switchRenderer(particlesOnly) {
			renderParticlesOnly = particlesOnly;
		}
	</script>
	<style type="text/css">
		body {
			background-color: #000000;
			color: #FFFFFF;
		}

		#c {
			position: absolute;
			top: 0;
			left: 0;
			z-index: -1;
		}

		a {
			color: #FFFFFF;
			font-weight: bold;
		}

		#desc {
			background-color: rgba(0, 0, 0, 0.2);
			width: 1024;
		}
	</style>
</head>
<body onload="load()" ondblclick="hide()">
	<div id="desc">
		Poi Toy with programmable lights. The new frame's light streaks are drawn as canvas 2d lines and then sent to a WebGL texture. fps: <span id="fps"></span>
		<!--
		<br>
		<a href="https://www.ibiblio.org/e-notes/webgl/gpu/fluid.htm" target="evgeny">Fluid Simulation</a> by Evgeny Demidov.<br />
		-->
		<form>
			<!-- 
			limit fps <input type="text" name="desiredFPS" size="3" value="50"
				onKeyUp="setDesiredFps(this)"></input> 
			<br>
			<input type="radio" name="render"
				onclick="switchRenderer(false)" checked="checked">blur
			gradient composite</input>
			<br>
			<input type="radio" name="render"
				onclick="switchRenderer(true)">only particles</input>
			<br>
		 -->
			<input
				type="checkbox" onclick="goFull(this)" checked="checked">full
			</input>
		</form>
	</div>
	<canvas id="c"></canvas>
</body>
</html>
