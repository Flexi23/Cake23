

<html>
<head>
	<title> Here be Dragons </title>
	<script src="@(Model.Host.URL)/Scripts/jquery-1.6.4.min.js"></script>
	<script src="@(Model.Host.URL)/Scripts/jquery.signalR-2.2.0.min.js"></script>
	<script src="@(Model.Host.URL)/signalr/hubs"></script>
	<script type="text/javascript">
		// github.com/Flexi23/Cake23 | WebSocket Hub for Kinect v2 and MIDI controllers
		$(function () {
			$.connection.hub.url = "http://P502:9000/signalr"; var kinect = $.connection.kinect2Hub;

			kinect.client.onBody = function (bodyJson, projectionMappedPointsJson) {
				body = JSON.parse(bodyJson);
				// bodysampler = JSON.parse(projectionMappedPointsJson); // this would be the inbuilt mapping of the 3d coordinates to the 1080p video camera
				body.head = {
					x: body.Joints["Head"].Position.X,
					y: body.Joints["Head"].Position.Y,
					z: body.Joints["Head"].Position.Z,
					old: { "x": -1, "y": -1, "z": -1 }
				};
				body.handRight = { old: { "x": -1, "y": -1, "z": -1 }, grab: false, point: false, object: null };
				switch (body.handRight.state = body.HandRightState) {
					case 3:
						body.handRight.grab = true;
						break;
					case 4:
						body.handRight.point = true;
						break;
				}
				body.handRight.id = "hr" + body.TrackingId;
				//if (body.handRight.grab) {
				body.handRight.x = (body.Joints["HandTipRight"].Position.X * 2 + body.Joints["HandRight"].Position.X + body.Joints["ThumbRight"].Position.X * 2) / 5;
				body.handRight.y = (body.Joints["HandTipRight"].Position.Y * 2 + body.Joints["HandRight"].Position.Y + body.Joints["ThumbRight"].Position.Y * 2) / 5;
				body.handRight.z = (body.Joints["HandTipRight"].Position.Z * 2 + body.Joints["HandRight"].Position.Z + body.Joints["ThumbRight"].Position.Z * 2) / 5;
				//} else
				if (body.handRight.point) {
					body.handRight.x = body.Joints["HandTipRight"].Position.X;
					body.handRight.y = body.Joints["HandTipRight"].Position.Y;
					body.handRight.z = body.Joints["HandTipRight"].Position.Z;
				}
				body.handLeft = { old: { "x": -1, "y": -1, "z": -1 }, grab: false, point: false, object: null };
				switch (body.handLeft.state = body.HandLeftState) {
					case 3:
						body.handLeft.grab = true;
						break;
					case 4:
						body.handLeft.point = true;
						break;
				}
				body.handLeft.id = "hl" + body.TrackingId;
				//if (body.handLeft.grab) {
				body.handLeft.x = (body.Joints["HandTipLeft"].Position.X * 2 + body.Joints["HandLeft"].Position.X + body.Joints["ThumbLeft"].Position.X * 2) / 5;
				body.handLeft.y = (body.Joints["HandTipLeft"].Position.Y * 2 + body.Joints["HandLeft"].Position.Y + body.Joints["ThumbLeft"].Position.Y * 2) / 5;
				body.handLeft.z = (body.Joints["HandTipLeft"].Position.Z * 2 + body.Joints["HandLeft"].Position.Z + body.Joints["ThumbLeft"].Position.Z * 2) / 5;
				//} else
				if (body.handLeft.point) {
					body.handLeft.x = body.Joints["HandTipLeft"].Position.X;
					body.handLeft.y = body.Joints["HandTipLeft"].Position.Y;
					body.handLeft.z = body.Joints["HandTipLeft"].Position.Z;
				}
				var trackingObject = getTrackingObject(body.TrackingId);
				if (trackingObject.body == null) {
					trackingObject.body = body;
				} else {
					var oldBody = trackingObject.body;
					body.head.old.x = oldBody.head.x; // collapse?
					body.head.old.y = oldBody.head.y;
					body.head.old.z = oldBody.head.z;
					body.handRight.old.x = oldBody.handRight.x;
					body.handRight.old.y = oldBody.handRight.y;
					body.handRight.old.z = oldBody.handRight.z;
					body.handLeft.old.x = oldBody.handLeft.x;
					body.handLeft.old.y = oldBody.handLeft.y;
					body.handLeft.old.z = oldBody.handLeft.z;
					if (oldBody.handRight.grab) {
						body.handRight.object = oldBody.handRight.object;
					}
					if (oldBody.handLeft.grab) {
						body.handLeft.object = oldBody.handLeft.object;
					}
				}
				trackingObject.body = body; // update
			};
			kinect.client.onBodies = function (trackingIdsJson, frame) {
				var trackingIds = null;
				if (trackingIdsJson != null) {
					trackingIds = JSON.parse(trackingIdsJson);
				}
				onBodies(trackingObjects, trackingIds, frame);
			};
			kinect.client.onFace = onFace;

			var midi = $.connection.midiHub;
			midi.client.onMidi = onMidi;

			$.connection.hub.start().done(function () {
			});

		});

		var trackingObjects = [], bodyFrameIndex;
		function getTrackingObject(id) {
			var hit = null;
			trackingObjects.forEach(function (trackingObject) { // perhaps not the most efficient way, but don't expect too many tracked bodies anyway
				if (trackingObject.id == id) {
					hit = trackingObject;
				}
			});
			if (hit) {
				return hit;
			}
			// create new trackingObject
			console.log("create tracking object " + id);
			var trackingObject = { id: id, body: null }; // init as object that can be easily extended with additional properties
			trackingObjects.push(trackingObject);
			return trackingObject;
		}

		// Kinect body frame arrived
		// TODO: this function should take into account that calls come from varying sites
		var activeTrackingObjects = [];
		function onBodies(trackingObjects, trackedBodyIds, frame, sensorID) {
			bodyFrameIndex = frame;
			var oldActiveTrackingObjects = activeTrackingObjects;
			oldActiveTrackingObjects.forEach(function (trackingObject) {
				if (trackedBodyIds.indexOf(trackingObject.id) == -1) {
					trackingObject.stickman.pop();
				}
			});
			activeTrackingObjects = [];
			trackedBodyIds.forEach(function (id) {
				var trackingObject = getTrackingObject(id);
				activeTrackingObjects.push(trackingObject);
			});
		}

		var midi = [];

		// presets copied from the Chrome console after doodling with the knobs and sliders of my Korg nanoKontrol2

		// light theme
		midi = [0.8582677165354331, 0.8031496062992126, 0.889763779527559, 0, 0.6614173228346457, 0.5196850393700787, 0.6771653543307087, 0, null, null, null, null, null, null, null, null, 0.29133858267716534, 0.25196850393700787, 0.6299212598425197, 0.9212598425196851, 0.031496062992125984, 0.25984251968503935, 0.2125984251968504, 1];
		// dark theme
		//midi = [0.015748031496062992, 0, 0.09448818897637795, 0, 0.3858267716535433, 0.2047244094488189, 0.047244094488188976, 0, null, null, null, null, null, null, null, null, 0.6614173228346457, 0.7795275590551181, 0.8267716535433071, 1, 0.6456692913385826, 0.7165354330708661, 1, 1];

		function onMidi(channel, data1, data2) {
			//for now, just ignore the channel information
			midi[data1] = data2 / 127.;
			console.log("midi msg: channel " + channel + " , data: " + data1 + " => " + data2);
		}

		var faces = [];

		function onFace(verticesJSON, status, TrackingId) {
			var trackingObject = getTrackingObject(TrackingId);
			var before = Date.now();
			var vertices = JSON.parse(verticesJSON);
			var dur = Date.now() - before;
			var face = faces[TrackingId];
			if (face == undefined) {
				face = {
					points2d: []
				};
				for (var i = 0; i < 1347; i++) {
					face.points2d[i] = {};
				}
				faces[TrackingId] = face;
			}

			if (trackingObject.body) {
				var head = trackingObject.body.head;
				if (head) {
					var p2d = {};
					var p3d = {};
					var scale = 1.25;
					for (var i = 0; i < 1347; i++) {

						p3d.x = head.x + (vertices[i * 3 + 0] - head.x) * scale;
						p3d.y = head.y + (vertices[i * 3 + 1] - head.y) * scale;
						p3d.z = head.z + (vertices[i * 3 + 2] - head.z) * scale;

						project(p3d, p2d);

						var shape = face.points2d[i];

						shape.x = p2d.x;
						shape.y = p2d.y;

						if (shape.update) {
							shape.update();
						}
					}
				}
			}
		}

		function getMidi(id) {

			if (midi[id] == undefined)
				midi[id] = 0;

			return midi[id];
		}

		var joints = ["SpineBase", "SpineMid", "Neck", "Head", "ShoulderLeft",
			"ElbowLeft", "WristLeft", "HandLeft", "ShoulderRight", "ElbowRight",
			"WristRight", "HandRight", "HipLeft", "KneeLeft", "AnkleLeft",
			"FootLeft", "HipRight", "KneeRight", "AnkleRight", "FootRight",
			"SpineShoulder", "HandTipLeft", "ThumbLeft", "HandTipRight", "ThumbRight"];

		var members = [
			//		["SpineBase", "SpineMid"],
			//		["SpineMid", "SpineShoulder"],
			["SpineShoulder", "Neck"],
			//		["Neck", "Head"],
			["SpineShoulder", "ShoulderLeft"],
			["ShoulderLeft", "ElbowLeft"],
			["ElbowLeft", "WristLeft"],
			["WristLeft", "HandLeft"],
			["HandLeft", "HandTipLeft"],
			["HandLeft", "ThumbLeft"],
			//		["SpineBase", "HipLeft"],
			["SpineBase", "KneeLeft"],
			["SpineBase", "KneeRight"],
			//		["HipLeft", "ShoulderLeft"],
			["HipLeft", "KneeLeft"],
			["KneeLeft", "AnkleLeft"],
			["AnkleLeft", "FootLeft"],
			["SpineShoulder", "ShoulderRight"],
			["ShoulderRight", "ElbowRight"],
			["ElbowRight", "WristRight"],
			["WristRight", "HandRight"],
			["HandRight", "HandTipRight"],
			["HandRight", "ThumbRight"],
			//		["SpineBase", "HipRight"],
			//		["HipRight", "ShoulderRight"],
			["HipRight", "KneeRight"],
			["KneeRight", "AnkleRight"],
			["AnkleRight", "FootRight"],
			["SpineMid", "ShoulderRight"],
			["SpineMid", "ShoulderLeft"],
			["SpineMid", "HipRight"],
			["SpineMid", "HipLeft"]
		];

		// perspective projection (virtual camera)
		function project(p3d, p2d) {
			p2d.x = p3d.x;
			p2d.y = p3d.y;
			var w = Math.atan2(-p3d.x, -p3d.y);
			var l = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y);
			var d = 0.5;
			var zoom = 1.;
			var p = Math.tan(Math.PI / 2 + Math.atan2(d + p3d.z, l));
			d = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y + (p3d.z + d) * (p3d.z + d));
			p2d.x = zoom * Math.sin(w) * p / aspectx + 0.5;
			p2d.y = zoom * Math.cos(w) * p / aspecty + 0.5;
			p2d.y = 1 - p2d.y;
			p2d.x *= sizeX;
			p2d.y *= sizeY;
		}

		var Joint = function () {
			this.x = 0.5;
			this.y = 0.5;
			this.z = 1;
			this.state = 0;
			this.old = {};
			this.old.x = 0.5;
			this.old.y = 0.5;
			this.old.z = 1;
			this.old.state = 0;
			this.update = function (pos) {
				this.old.x = this.x;
				this.old.y = this.y;
				this.old.z = this.z;
				this.old.state = this.state;
				this.x = pos.x;
				this.y = pos.y;
				this.z = pos.z;
				this.state = pos.state;
			};
		};

		var Bone = function (joint1, joint2) {
			this.joint1 = joint1;
			this.joint2 = joint2;
		}

		var Stickman = function () {
			this.joints = [];
			this.bones = [];
			var self = this;
			joints.forEach(function (name) {
				self.joints[name] = new Joint();
			});
			members.forEach(function (member) {
				self.bones[member] = new Bone(self.joints[member[0]], self.joints[member[1]]);
			});
			this.leftHandPoiToy = new PoiToy();
			this.rightHandPoiToy = new PoiToy();
			this.pop = function () {
				this.leftHandPoiToy.pop();
				this.rightHandPoiToy.pop();
			}
		};

		function updateStickMen() {
			activeTrackingObjects.forEach(function (trackingObject) {

				var body = trackingObject.body;
				var stickman = trackingObject.stickman;
				if (stickman == null) {
					stickman = new Stickman();
					trackingObject.stickman = stickman;
				}

				joints.forEach(function (id) {
					stickman.joints[id].update({
						x: trackingObject.body.Joints[id].Position.X,
						y: trackingObject.body.Joints[id].Position.Y,
						z: trackingObject.body.Joints[id].Position.Z,
						state: body.Joints[id].TrackingState
					});
				});

				stickman.leftHandPoiToy.x = body.handLeft.x;
				stickman.leftHandPoiToy.y = body.handLeft.y;
				stickman.leftHandPoiToy.z = body.handLeft.z;

				stickman.rightHandPoiToy.x = body.handRight.x;
				stickman.rightHandPoiToy.y = body.handRight.y;
				stickman.rightHandPoiToy.z = body.handRight.z;
			});
		}


		function drawPoiToys(context) {
			activeTrackingObjects.forEach(function (trackingObject) {

				var stickman = trackingObject.stickman;
				if (stickman == null) {
					stickman = new Stickman();
					trackingObject.stickman = stickman;
				}

				stickman.leftHandPoiToy.drawLightStreaks(context);
				stickman.rightHandPoiToy.drawLightStreaks(context);
			});

			poiToy.drawLightStreaks(context);
		}

		function drawStickMen(context) {
			activeTrackingObjects.forEach(function (trackingObject) {

				var stickman = trackingObject.stickman;
				if (stickman == null) {
					stickman = new Stickman();
					trackingObject.stickman = stickman;
				}

				// draw the bones
				/*
				context.strokeStyle = "#FFF";
				context.beginPath();

				members.forEach(function (member) {
					var joint1 = stickman.joints[member[0]];
					var joint2 = stickman.joints[member[1]];
					if (joint1.state == 2 && joint2.state == 2) {
						var p1 = {};
						var p2 = {};
						project(joint1, p1);
						project(joint2, p2);
						context.moveTo(p1.x, p1.y);
						context.lineTo(p2.x, p2.y);
					}
				});

				context.lineWidth = 1.25;//64 / 256;
				context.stroke();
				*/

				// draw the outline

				// calculate support vectors

				// clockwise winding around the bones
				var outlineControls = [];
				var p = {};
				function addMember(memberName) { // todo: is obsolete?
					var joint = stickman.joints[memberName];
					if (joint.state == 2) {
						project(joint, p);
						outlineControls.push(p.x, p.y);
					}
				}
				function getNormal(p1, p2) {
					return { x: p2.y - p1.y, y: p1.x - p2.x };
				}
				function addSupport(m1, m2, m3, w) {
					if (w == 0) {
						addMember(m2);
						return;
					}
					var j2 = stickman.joints[m2];
					if (j2.state == 2) {
						var j1 = stickman.joints[m1];
						var j3 = stickman.joints[m3];
						var p1 = {}; var p2 = {}; var p3 = {};
						project(j1, p1); // it feels wrong to calculate the projection of some members several times
						project(j2, p2); // there should be an index. todo: attach pre-projected 2D locations to joints
						project(j3, p3);
						var n1 = getNormal(p1, p2);
						var n2 = getNormal(p2, p3);
						var n = { x: (n1.x + n2.x) / 2, y: (n1.y + n2.y) / 2, z: (n1.z + n2.z) / 2 }; // average
						var p = { x: p2.x + n.x * w, y: p2.y + n.y * w }; // displace middle joint projection by weighted normal
						outlineControls.push(p.x, p.y);
					}
				}
				addSupport("Head", "Neck", "SpineShoulder", 0.5);
				addSupport("Head", "SpineShoulder", "ShoulderRight", 0.25);
				addSupport("SpineShoulder", "ShoulderRight", "ElbowRight", 0.0);
				addSupport("ShoulderRight", "ElbowRight", "WristRight", 0.0);
				addSupport("ElbowRight", "WristRight", "HandRight", 0.1);
				addSupport("WristRight", "HandRight", "HandTipRight", 0.1);
				addSupport("HandRight", "HandTipRight", "HandRight", 0.1);
				addSupport("HandTipRight", "HandRight", "ThumbRight", 0.1);
				addSupport("HandRight", "ThumbRight", "HandRight", 0.1);
				addSupport("ThumbRight", "HandRight", "WristRight", 0.1);
				addSupport("HandRight", "WristRight", "ElbowRight", 0.1);
				addSupport("WristRight", "ElbowRight", "ShoulderRight", 0.2);
				addSupport("ElbowRight", "ShoulderRight", "SpineMid", 0.33);
				addSupport("ShoulderRight", "SpineMid", "HipRight", 0.55);
				addSupport("SpineMid", "HipRight", "KneeRight", 0.2);
				addSupport("HipRight", "KneeRight", "AnkleRight", 0.1);
				addSupport("KneeRight", "AnkleRight", "FootRight", 0.2);
				addSupport("AnkleRight", "FootRight", "AnkleRight", 0.1);
				addSupport("FootRight", "AnkleRight", "KneeRight", 0.1);
				addSupport("AnkleRight", "KneeRight", "SpineBase", 0.1);
				addSupport("KneeRight", "SpineBase", "KneeLeft", 0.1);
				addSupport("SpineBase", "KneeLeft", "AnkleLeft", 0.1);
				addSupport("KneeLeft", "AnkleLeft", "FootLeft", 0.1);
				addSupport("AnkleLeft", "FootLeft", "AnkleLeft", 0.1);
				addSupport("FootLeft", "AnkleLeft", "KneeLeft", 0.2);
				addSupport("AnkleLeft", "KneeLeft", "HipLeft", 0.1);
				addSupport("KneeLeft", "HipLeft", "SpineMid", 0.25);
				addSupport("HipLeft", "SpineMid", "ShoulderLeft", 0.55);
				addSupport("SpineMid", "ShoulderLeft", "ElbowLeft", 0.33);
				addSupport("ShoulderLeft", "ElbowLeft", "WristLeft", 0.2);
				addSupport("ElbowLeft", "WristLeft", "HandLeft", 0.1);
				addSupport("WristLeft", "HandLeft", "ThumbLeft", 0.1);
				addSupport("HandLeft", "ThumbLeft", "HandLeft", 0.1);
				addSupport("ThumbLeft", "HandLeft", "HandTipLeft", 0.1);
				addSupport("HandLeft", "HandTipLeft", "HandLeft", 0.1);
				addSupport("HandTipLeft", "HandLeft", "WristLeft", 0.1);
				addSupport("HandLeft", "WristLeft", "ElbowLeft", 0.1);
				addSupport("WristLeft", "ElbowLeft", "ShoulderLeft", 0.0);
				addSupport("ElbowLeft", "ShoulderLeft", "SpineShoulder", 0.0);
				addSupport("ShoulderLeft", "SpineShoulder", "Head", 0.2);
				addSupport("SpineShoulder", "Neck", "Head", 0.5);

				context.beginPath();
				context.strokeStyle = "#FFF";
				drawSpline(context, outlineControls);
				context.stroke();

				// draw the hands

				var handLeft = {};
				var handRight = {};
				project(trackingObject.body.handLeft, handLeft);
				project(trackingObject.body.handRight, handRight);

				context.beginPath();
				context.strokeStyle = "#FFF";
				if (trackingObject.body.handLeft.grab) {
					context.strokeStyle = "#0F0";
				}
				context.rect(handLeft.x - 10, handLeft.y - 10, 20, 20);
				context.stroke();

				context.beginPath();
				context.strokeStyle = "#FFF";
				if (trackingObject.body.handRight.grab) {
					context.strokeStyle = "#0F0";
				}
				context.rect(handRight.x - 10, handRight.y - 10, 20, 20);
				context.stroke();

				/*
				joints.forEach(function (id) {
					var joint = stickman.joints[id];
				});
				*/

				// draw the face
				context.fillStyle = "#FFF";
				var face = faces[trackingObject.id];
				if (face) {
					face.points2d.forEach(function (p) {
						context.fillRect(p.x, p.y, 1.25, 1.25);
					});
				}

			});
		}

		// B-Spline rendering (#controls)

		// http://js1k.com/2015-hypetrain/details/2287
		function getDragonCurveTrack(x1, y1, x2, y2) {
			track = [x1, y1];
			layTrackRecursive(x1, y1, x2, y2, 9, 1); // #9gag: set the depth of the recursion here. be sane and keep it real and under 13
			track.push(x2, y2, x2, y2, x2, y2);
			return track;
		}

		function layTrackRecursive(x1, y1, x2, y2, n, flip) {
			var deltax = (x2 - x1) / 2.3;
			var deltay = (y2 - y1) / 2.3;

			var xm = x1 + deltax - deltay;
			var ym = y1 + deltay + deltax;

			if (n-- > 1) {
				if (flip + 1) {
					layTrackRecursive(x1, y1, xm, ym, n, flip);
					track.push(xm, ym);
					layTrackRecursive(x2, y2, xm, ym, n, -flip);
				} else {
					layTrackRecursive(x2, y2, xm, ym, n, -flip);
					track.push(xm, ym);
					layTrackRecursive(x1, y1, xm, ym, n, flip);
				}
			}
		}

		var h = 512;
		var w = 1024;

		var soup = [149, 277, 203, 293, 308, 206, 298, 206, 386, 232, 358, 301, 294, 306, 364, 304, 414, 228, 454, 203, 434, 203, 464, 215, 458, 208, 408, 257, 463, 309, 515, 254, 478, 206, 477, 213, 498, 203, 485, 201, 509, 217, 539, 220, 545, 209, 537, 220, 527, 296, 594, 297, 599, 214, 591, 218, 622, 222, 618, 218, 623, 373, 623, 228, 710, 230, 680, 287, 623, 260];
		var controls = getDragonCurveTrack(0.2 * w, 0.2 * h, 0.8 * w, 0.4 * h);
		//var controls = soup;

		if (window.location.hash.length > 10) {
			try {
				var hash = JSON.parse("[" + window.location.hash.substring(1) + "]");
				if (Array.isArray(hash) && hash.length > 3) {
					controls = hash;
				}
			} catch (e) {
				console.log(e);
			}
		}

		// lambda for iteration over the splines for a set of controls
		function forBezier(controls, i, func) {
			var currentx = controls[i * 2 + 0];
			var currenty = controls[i * 2 + 1];
			var nextx = controls[i * 2 + 2];
			var nexty = controls[i * 2 + 3];
			var helper1x = currentx;
			var helper1y = currenty;
			if (i > 0) {
				helper1x = currentx;
				var previousx = controls[i * 2 - 2];
				var previousy = controls[i * 2 - 1];
				helper1x = currentx + (nextx - previousx) * 0.25;
				helper1y = currenty + (nexty - previousy) * 0.25;
			}
			var helper2x = nextx;
			var helper2y = nexty;
			if (i < controls.length / 2 - 2) {
				var nextnextx = controls[i * 2 + 4];
				var nextnexty = controls[i * 2 + 5];
				helper2x = nextx - (nextnextx - currentx) * 0.25;
				helper2y = nexty - (nextnexty - currenty) * 0.25;
			}
			return func(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, i, controls);
		}

		function forEachBezier(controls, func) {
			if (controls.length > 1) {
				for (var i = 0; i < controls.length / 2 - 1; i++) {
					forBezier(controls, i, func);
				}
			}
		}

		// see http://stackoverflow.com/a/17096947/6036193
		function getCubic(normalizedDistance, a, b, c, d) {
			var t2 = normalizedDistance * normalizedDistance;
			var t3 = t2 * normalizedDistance;
			return a + (-a * 3 + normalizedDistance * (3 * a - a * normalizedDistance)) * normalizedDistance + (3 * b + normalizedDistance * (-6 * b + b * 3 * normalizedDistance)) * normalizedDistance + (c * 3 - c * 3 * normalizedDistance) * t2 + d * t3;
		}

		// returns the point on the spline for a normalized range value
		function getPointOnSpline(controls, index) {
			index *= controls.bezierLength;
			var start = 0;
			for (var i = 0; i < controls.bezierLengths.length; i++) {
				var l = controls.bezierLengths[i];
				if (index >= start && index <= start + l) {
					return forBezier(controls, i, function (currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty) {
						return getPointOnBezier(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, (index - start) / l)
					});
				}
				start += l;
			}
		}

		function getPointOnBezier(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, index) {
			return [getCubic(index, currentx, helper1x, helper2x, nextx), getCubic(index, currenty, helper1y, helper2y, nexty)];
		}

		function getBezierLength(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty) {
			// solve differentially with N segments
			var N = 32;
			var L = 0;
			var start = getPointOnBezier(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, 0);
			for (var i = 1; i <= N; i++) {
				var end = getPointOnBezier(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, i / N);
				L += Math.sqrt((start[0] - end[0]) * (start[0] - end[0]) + (start[1] - end[1]) * (start[1] - end[1]));
				start = end;
			}
			return L;
		}

		function attachBezierLengths(controls) {
			controls.bezierLengths = [];
			forEachBezier(controls, function (currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty, i, controls) {
				controls.bezierLengths[i] = getBezierLength(currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty);
			});
			controls.bezierLength = controls.bezierLengths.reduce(function (a, b) { return a + b }, 0);
			animationFrameCount = Math.floor(0.2 * controls.bezierLength / Math.sqrt(2)); // line drawing animation #speed
		}

		function updateUrlHash() {
			var roundedControls = controls.map(function (x) { return Math.round(x); });
			window.location.hash = JSON.stringify(roundedControls).replace("[", "").replace("]", "");
		}

		attachBezierLengths(controls);

		// if it's only to delete and add pairs of xy coordinates, why not consequently use splice? maybe change it later
		function array2LinkedList(controls) {
			var listHead = null
			if (controls.length > 1) {
				for (var i = 0; i < controls.length / 2; i++) {
					var reverseIndex = (controls.length / 2 - i - 1) * 2; // iterate through the array backwards
					listHead = { x: controls[reverseIndex], y: controls[reverseIndex + 1], next: listHead }; // append a new standard object to the head of the list
				}
			}
			return listHead;
		}

		function linkedList2Array(listElement) {
			var array = [];
			while (listElement != null) {
				array.push(listElement.x, listElement.y);
				listElement = listElement.next;
			}
			return array;
		}

		function addPointAtIndex(controls, i, x, y) {
			var listHead = array2LinkedList(controls);
			if (i == -1) {
				return { x: x, y: y, next: listHead };
			} else {
				var newIndex = 0;
				var beforeElement = listHead;
				while (newIndex < i && beforeElement.next != null) {
					beforeElement = beforeElement.next;
					newIndex++;
				}
				beforeElement.next = { x: x, y: y, next: beforeElement.next };
			}
			return listHead;
		}

		function deletePointAtIndex(controls, i) {
			return deletePointsAtIndices(controls, [i]);
		}

		function deletePointsAtIndices(controls, indices) {
			var listHead = array2LinkedList(controls);
			var length = getLength(listHead);
			sortArray(indices);
			// first remove all from the beginning
			var j = 0;
			for (; length > 2 && indices.indexOf(j) == j; j++) {
				listHead = listHead.next;
				length--;
			}
			// then remove all remaining
			var control = listHead;
			for (var i = j + 1; control != null && length > 2; i++) {
				if (indices.indexOf(i) != -1) {
					if (control.next != null) {
						control.next = control.next.next;
						length--;
					}
				} else {
					control = control.next;
				}
			}
			return listHead;
		}

		function getLength(listElem) {
			var l = (listElem == null) ? 0 : 1;
			while (listElem.next != null) {
				l++;
				listElem = listElem.next;
			}
			return l;
		}

		// todo: try typed array sort
		// stoopid default JS Array.sort() ordered the integers lexicographical.
		// stubborn as i was, i didn't change the array of selected indices to a typed array but hacked this
		// there's room for performance improvement here but then it's not really critical (yet)
		function sortArray(array) {
			for (var i = 0; i < array.length; i++) {
				var _i = array[i];
				var minRest = _i;
				var minIndex = i;
				for (var j = i; j < array.length; j++) {
					var _j = array[j];
					if (_j < minRest) {
						minRest = _j;
						minIndex = j;
					}
				}
				array[i] = minRest;
				array[minIndex] = _i;
			}
		}

		var oldPenX, oldPenY, newPenX, newPenY;
		var animationFrameCount = Math.floor(controls.bezierLength / Math.sqrt(2));
		var animationFrame = 0;
		var selectedControls = [];
		var handleSize = 3.;
		var hoveredControlIndex = -1;

		function updateSpline(pointerX, pointerY) {
			var minD = 100;
			var nearestControlIndex = hoveredControlIndex = -1;
			for (var i = 0; i < controls.length / 2; i++) {
				var x = controls[i * 2];
				var y = controls[i * 2 + 1];
				var d = Math.sqrt((pointerX - x) * (pointerX - x) + (pointerY - y) * (pointerY - y));
				if (d < minD) {
					minD = d;
					nearestControlIndex = i;
				}
			}
			if (minD < handleSize * 2) {
				if (!previousMouseDown && (selectionWidth == 0 && selectionHeight == 0)) {
					selectedControls = [nearestControlIndex];
					hoveredControlIndex = nearestControlIndex;
				}
			} else {
				hoveredControlIndex = -1;
				if (!mouseDown && (splineEditorState != MOV || (selectionWidth == 0 && selectionHeight == 0)) && (splineEditorState != DEL || (selectionWidth == 0 && selectionHeight == 0))) {
					selectedControls = [];
				}
			}
		}

		var ADD = 1;
		var MOV = 2;
		var DEL = 3;
		var splineEditorState = ADD; // initial state
		var splineEditorHUDx = 440;
		var splineEditorHUDy = 16;
		var isSplineEditorHovered = false;
		var isAddHovered = false;
		var isMovHovered = false;
		var isDelHovered = false;

		var selectionLeft = -1;
		var selectionTop = -1;
		var selectionWidth = 0;
		var selectionHeight = 0;
		var selectionResized = false;
		var previousMouseDown = false;
		var previousIndicatedControls = controls;

		function animatePointOnSpline(context) {
			if (animationFrame > animationFrameCount) {
				animationFrame = 0;
			}
			var index = animationFrame / animationFrameCount;

			var oldGlobalCompositeOperation = context.globalCompositeOperation;
			context.globalCompositeOperation = "source-over";

			context.fillStyle = "#000";
			context.fillRect(0, 0, sizeX, sizeY);

			context.strokeStyle = "#FF0";
			context.font = "35px Lucida Console";

			function isInside(x, y, left, top, width, height, callback) {
				if (width < 0) {
					left += width;
					width = -width;
				} else {
					left = left;
					width = width;
				}
				if (height < 0) {
					top += height;
					height = -height;
				} else {
					top = top;
					height = height;
				}
				var _isInside = x >= left && x <= left + width && y >= top && y <= top + height;
				if (_isInside && typeof (callback) === "function") {
					callback();
				}
				return _isInside;
			}

			function isMouseInside(left, top, width, height, callback) {
				var _mouseX = mouseX * sizeX;
				var _mouseY = (1 - mouseY) * sizeY;
				return isInside(_mouseX, _mouseY, left, top, width, height, callback);
			}

			if (mouseDown && isSplineEditorHovered) {
				splineEditorHUDx += mouseDx * sizeX / viewX;
				splineEditorHUDy -= mouseDy * sizeY / viewY;
			}

			context.strokeStyle = "#00F";
			isSplineEditorHovered = isMouseInside(splineEditorHUDx, splineEditorHUDy, 48 * 3, 48, function () {
				context.strokeStyle = "#0FF";
			});
			context.beginPath();
			context.translate(splineEditorHUDx + 0.5, splineEditorHUDy + 0.5); // yours truly, hair lines
			context.rect(0, 0, 48 * 3, 48);
			context.stroke();

			if (splineEditorState == ADD) {
				context.strokeStyle = "#FF0";
				context.fillStyle = "#0F0";
			} else {
				context.strokeStyle = "#F00";
				context.fillStyle = "#F00";
			}
			isAddHovered = isMouseInside(splineEditorHUDx + 8, splineEditorHUDy + 8, 32, 32, function () {
				context.strokeStyle = "#FFF";
				if (mouseDown && !previousMouseDown) {
					splineEditorState = ADD;
					selectionWidth = 0;
					selectionHeight = 0;
				}
			});

			context.beginPath();
			context.rect(8, 8, 32, 32);
			context.stroke();
			context.fillText("A", 14, 35);

			if (splineEditorState == MOV) {
				context.strokeStyle = "#FF0";
				context.fillStyle = "#0F0";
			} else if (splineEditorState == ADD) {
				context.strokeStyle = "#F00";
				context.fillStyle = "#F00";
			} else {
				context.strokeStyle = "#F00";
				context.fillStyle = "#F00";
			}
			isMovHovered = isMouseInside(splineEditorHUDx + 56, splineEditorHUDy + 8, 32, 32, function () {
				context.strokeStyle = "#FFF";
				if (mouseDown && !previousMouseDown) {
					splineEditorState = MOV;
					selectionResized = false;
				}
			});

			context.beginPath();
			context.rect(56, 8, 32, 32);
			//context.rect(64, 16, 16, 16);
			context.stroke();
			context.fillText("M", 62, 35);

			if (splineEditorState == DEL) {
				context.strokeStyle = "#FF0";
				context.fillStyle = "#0F0";
			} else {
				context.strokeStyle = "#F00";
				context.fillStyle = "#F00";
			}
			isDelHovered = isMouseInside(splineEditorHUDx + 104, splineEditorHUDy + 8, 32, 32, function () {
				context.strokeStyle = "#FFF";
				if (mouseDown && !previousMouseDown) {
					splineEditorState = DEL;
					selectionWidth = 0;
					selectionHeight = 0;
					selectionResized = false;
				}
			});

			context.beginPath();
			context.rect(104, 8, 32, 32);
			context.stroke();
			context.fillText("D", 110, 35);

			context.translate(-splineEditorHUDx - 0.5, -splineEditorHUDy - 0.5);

			if ((splineEditorState == MOV || splineEditorState == DEL) && !isSplineEditorHovered) {
				var _mouseX = mouseX * sizeX;
				var _mouseY = (1 - mouseY) * sizeY;

				if (mouseDown || (!mouseDown && previousMouseDown)) {
					var selectionBoxIsHovered = isMouseInside(selectionLeft, selectionTop, selectionWidth, selectionHeight);

					if (!previousMouseDown && !selectionBoxIsHovered && hoveredControlIndex == -1) {
						selectionLeft = _mouseX;
						selectionTop = _mouseY;
						selectionWidth = 0;
						selectionHeight = 0;
						selectionResized = false;
						//console.log("selection started:", selectionLeft, selectionTop);
					} else if (!selectionResized) {
						selectionWidth += mouseDx * sizeX / viewX;
						selectionHeight -= mouseDy * sizeY / viewY;
						//console.log("selection size changed");
						// collect selectedControls
						for (var i = 0; i < controls.length / 2; i++) {
							var x = controls[i * 2 + 0];
							var y = controls[i * 2 + 1];
							// split in-group
							if (isInside(x, y, selectionLeft, selectionTop, selectionWidth, selectionHeight)) {
								if (selectedControls.indexOf(i) == -1) {
									selectedControls.push(i);
								}
							} else {
								var selectionIndex = selectedControls.indexOf(i);
								if (selectionIndex != -1) {
									selectedControls.splice(selectionIndex, 1);
								}
							}
						}

					} else {
						selectionLeft += mouseDx * sizeX / viewX;
						selectionTop -= mouseDy * sizeY / viewY;
						//console.log("selection box moved");
					}
				} else {
					selectionResized = true;
				}
			}

			// draw selection box
			if (selectionWidth != 0 || selectionHeight != 0) {
				var left, top, width, height;
				if (selectionWidth < 0) {
					left = selectionLeft + selectionWidth;
					width = -selectionWidth;
				} else {
					left = selectionLeft;
					width = selectionWidth;
				}
				if (selectionHeight < 0) {
					top = selectionTop + selectionHeight;
					height = -selectionHeight;
				} else {
					top = selectionTop;
					height = selectionHeight;
				}
				if (splineEditorState == MOV) {
					context.strokeStyle = "#666";
				} else if (splineEditorState == DEL) {
					context.strokeStyle = "#088";
				}
				context.beginPath();
				context.rect(left + 0.5, top + 0.5, width, height);
				context.stroke();
			}

			context.globalCompositeOperation = "lighter";
			context.strokeStyle = "#F00";
			drawSpline(context, controls);

			var point = getPointOnSpline(controls, index);

			context.fillStyle = "#0F0";
			context.fillRect(point[0] - 1.25, point[1] - 1.25, 2.5, 2.5);

			var nearestSegmentIndex = 0;
			var nearestControlIndex = -1;
			var distanceToNearestSegment = 1024;
			var distanceToNearestControl = 1024;
			var pushToEnd = false;
			if (controls.length > 1) {
				var nextX, nextY, d1, d2, d3;
				for (var i = 0; i < controls.length / 2; i++) {
					var x = controls[i * 2];
					var y = controls[i * 2 + 1];
					d1 = Math.sqrt((mouseX * sizeX - x) * (mouseX * sizeX - x) + ((1 - mouseY) * sizeY - y) * ((1 - mouseY) * sizeY - y));
					if (d1 < distanceToNearestControl) {
						distanceToNearestControl = d1;
						nearestControlIndex = i;
					}
					if (i < controls.length / 2 - 1) {
						nextX = controls[i * 2 + 2];
						nextY = controls[i * 2 + 3];
						d2 = Math.sqrt((mouseX * sizeX - nextX) * (mouseX * sizeX - nextX) + ((1 - mouseY) * sizeY - nextY) * ((1 - mouseY) * sizeY - nextY));
						d3 = Math.sqrt((x - nextX) * (x - nextX) + (y - nextY) * (y - nextY));
						if (d1 + d2 - d3 < distanceToNearestSegment) {
							distanceToNearestSegment = d1 + d2 - d3;
							nearestSegmentIndex = i;
						}
					}
				}
				pushToEnd = d2 < distanceToNearestSegment;
				var x = controls[0];
				var y = controls[1];
				d1 = Math.sqrt((mouseX * sizeX - x) * (mouseX * sizeX - x) + ((1 - mouseY) * sizeY - y) * ((1 - mouseY) * sizeY - y));
				pushToBegin = d1 < distanceToNearestSegment;
			}
			//			context.lineWidth = 1.;
			context.strokeStyle = "#0F0";

			if (selectedControls.length == 0 && (splineEditorState == ADD || splineEditorState == MOV)) {
				var newControlIndex = pushToEnd ? controls.length / 2 : pushToBegin ? -1 : nearestSegmentIndex;
				var indicatedList;
				var indicatedControls = controls;
				if (!isSplineEditorHovered && splineEditorState == ADD) {
					var indicatedControls = previousIndicatedControls;
					if (mouseDx != 0 || mouseDy != 0) {
						indicatedList = addPointAtIndex(controls, newControlIndex, mouseX * sizeX, (1 - mouseY) * sizeY);
						indicatedControls = linkedList2Array(indicatedList);
						attachBezierLengths(indicatedControls);
					}
				} else {
					indicatedControls = controls;
				}
				drawSpline(context, indicatedControls);
				previousIndicatedControls = indicatedControls;
				if (mouseDown && selectedControls.length < 1 && !previousMouseDown) {
					selectedControls = [newControlIndex + (pushToEnd ? 0 : 1)];
					controls = indicatedControls;
					updateUrlHash();
				}
			} else if (splineEditorState == DEL || (splineEditorState == MOV && isDelHovered)) {
				var indicatedList;
				var indicatedControls = previousIndicatedControls;
				if (mouseDx != 0 || mouseDy != 0) {
					if (isDelHovered || (mouseDown && previousMouseDown && !selectionResized) || (!mouseDown && previousMouseDown)) {
						indicatedList = deletePointsAtIndices(controls, selectedControls);
						indicatedControls = linkedList2Array(indicatedList);
						attachBezierLengths(indicatedControls);
					} else if (distanceToNearestControl < handleSize * 2 && !previousMouseDown) {
						indicatedList = deletePointAtIndex(controls, nearestControlIndex);
						indicatedControls = linkedList2Array(indicatedList);
						attachBezierLengths(indicatedControls);
					} else {
						indicatedControls = controls;
					}
				}
				drawSpline(context, indicatedControls);
				previousIndicatedControls = indicatedControls;
				if (mouseDown && isDelHovered || !mouseDown && previousMouseDown && splineEditorState == DEL) {
					selectedControls = [];
					controls = indicatedControls;
					updateUrlHash();
					selectionWidth = 0;
					selectionHeight = 0;
					selectionResized = false;
				}
			} else {
				drawSpline(context, controls);
			}

			context.lineWidth = 1.;

			// move selectedControls
			if (controls.length > 1) {
				for (var i = 0; i < controls.length / 2; i++) {
					if (selectedControls.indexOf(i) == -1) {
						context.strokeStyle = "#00F";
					} else {
						if (mouseDown && !isSplineEditorHovered && (splineEditorState != MOV || selectionResized) && (splineEditorState != DEL || selectionResized)) {
							controls[i * 2] += mouseDx * sizeX / viewX;
							controls[i * 2 + 1] -= mouseDy * sizeY / viewY;
						}
						if (splineEditorState == ADD || splineEditorState == MOV) {
							context.strokeStyle = "#0FF";
						} else if (splineEditorState == DEL) {
							context.strokeStyle = "#F00";
						}
					}
					var x = controls[i * 2];
					var y = controls[i * 2 + 1];
					context.beginPath();
					context.arc(x, y, handleSize, 0, 2 * Math.PI, false);
					context.stroke();
				}
				attachBezierLengths(controls);
				if (selectedControls.length == 0 && splineEditorState == ADD) {
					context.beginPath();
					context.arc(_mouseX, _mouseY, handleSize, 0, 2 * Math.PI, false);
					context.stroke();
				}
			}
			if (selectedControls.length > 0 && !mouseDown && previousMouseDown) {
				updateUrlHash();
			}

			var point = getPointOnSpline(controls, index);
			oldPenX = newPenX;
			oldPenY = newPenY;
			newPenX = point[0] / sizeX;
			newPenY = 1. - point[1] / sizeY;

			animationFrame++;

			context.globalCompositeOperation = oldGlobalCompositeOperation;
			previousMouseDown = mouseDown;
		}

		function drawSpline(context, controls) {
			context.beginPath();
			forEachBezier(controls, function (currentx, currenty, helper1x, helper1y, helper2x, helper2y, nextx, nexty) {
				context.moveTo(currentx, currenty);
				context.bezierCurveTo(helper1x, helper1y, helper2x, helper2y, nextx, nexty);
			});
			context.stroke();
			drawSplineScale(16, 0.133, context, controls);
		}

		function drawSplineScale(d, l, context, controls) {
			var n = controls.bezierLength / d;
			context.beginPath();
			for (var i = 0; i < n; i++) {
				var s1 = i / (n + 0.5);
				var s2 = s1 + 0.001 / n;
				var p1 = getPointOnSpline(controls, s1);
				var p2 = getPointOnSpline(controls, s2);
				var dx = (p2[0] - p1[0]) * 1000 * l;
				var dy = (p2[1] - p1[1]) * 1000 * l;
				context.moveTo(p1[0] - dy, p1[1] + dx);
				context.lineTo(p1[0] + dy, p1[1] - dx);

			}
			context.stroke();
		}

		// Poi Toy
		var allPoiToys = [];

		(function advancePoiToys() {
			var before = Date.now();
			allPoiToys.forEach(function (poiToy) {
				poiToy.advance();
			});
			var dur = Date.now() - before;
			if (dur > 10) {
				console.warn('poi sim time: ' + dur);
			}
			setTimeout(advancePoiToys, 10 - dur);
		})();

		var PoiToy = function () {
			allPoiToys.push(this);
			this.pop = function () {
				delete allPoiToys[allPoiToys.indexOf(this)];
			}

			this.numLights = 80;
			this.postureIdx = 0;
			this.postureHistory = [];
			this.historyLength = 32;
			this.pushPosture = function (posture) {
				this.postureHistory = [posture].concat(this.postureHistory.slice(0, this.historyLength - 1)); // new posture goes in first, truncate history
			}

			this.force = 0.003;
			this.grav = 0.000;
			this.speedFactor = 0.66;
			this.friction = 30.; // 50
			this.x = 0.5;
			this.y = 0.2;
			this.z = 0.;
			this.points = []; // support points
			for (i = 0; i < 4; i++) {
				this.points[i] = { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0 };
			}

			this.applySpringForce = function (i1, i2) {
				fx = (this.points[i2].x - this.points[i1].x) * this.force;
				fy = (this.points[i2].y - this.points[i1].y) * this.force;
				fz = (this.points[i2].z - this.points[i1].z) * this.force;
				this.points[i1].vx += fx;
				this.points[i2].vx -= fx;
				this.points[i1].vy += fy;
				this.points[i2].vy -= fy;
				this.points[i1].vz += fz;
				this.points[i2].vz -= fz;
			};

			this.frame = 0;
			this.advance = function () {
				for (var n = 0; n < 6; n++) {

					// apply spring forces
					for (i = 1; i < 4; i++) {
						this.applySpringForce(i - 1, i);
						var vx = this.points[i].vx;
						var vy = this.points[i].vy;
						var vz = this.points[i].vz;
						var friction = Math.max(0, 1 - (vx * vx + vy * vy + vz * vz) * this.friction); // nonlinear quadratic
						this.points[i].vx *= friction;
						this.points[i].vy *= friction;
						this.points[i].vz *= friction;
						this.points[i].vy -= this.grav;
						this.points[i].x += vx * this.speedFactor; // Verlet integration
						this.points[i].y += vy * this.speedFactor;
						this.points[i].z += vz * this.speedFactor;
					}

					// pin the first point back to the control position
					this.points[0].x = this.x;
					this.points[0].y = this.y;
					this.points[0].z = this.z;

					// add a new posture to the front of the history
					var newPosture = [];
					x0 = this.points[0].x; // 4 control points
					y0 = this.points[0].y;
					z0 = this.points[0].z;
					x1 = this.points[1].x;
					y1 = this.points[1].y;
					z1 = this.points[1].z;
					x2 = this.points[2].x;
					y2 = this.points[2].y;
					z2 = this.points[2].z;
					x3 = this.points[3].x;
					y3 = this.points[3].y;
					z3 = this.points[3].z;
					for (i = 0; i < this.numLights; i++) {
						t = i / this.numLights;
						u = 1 - t;
						// 6th degree Bernstein polynomial
						var x = (P(t, 5) + 5 * P(t, 4) * u) * x0 + 10 * t * t * t * u * u * x1 + 10 * t * t * u * u * u * x2 + (5 * P(u, 4) * t + P(u, 5)) * x3;
						var y = (P(t, 5) + 5 * P(t, 4) * u) * y0 + 10 * t * t * t * u * u * y1 + 10 * t * t * u * u * u * y2 + (5 * P(u, 4) * t + P(u, 5)) * y3;
						var z = (P(t, 5) + 5 * P(t, 4) * u) * z0 + 10 * t * t * t * u * u * z1 + 10 * t * t * u * u * u * z2 + (5 * P(u, 4) * t + P(u, 5)) * z3;
						newPosture[i] = { x: x, y: y, z: z, frame: this.frame, col: { r: 1, g: 1, b: 1, a: 1 } }; // init white
					}
					this.pushPosture(newPosture);
					this.postureIdx++;

					// advance frame counter
					this.frame++;
				}
			};

			this.patterns = [];
			this.patterns["transparent"] = function (frame, pos, age, col) {
				col.r = 1;
				col.g = 1;
				col.b = 1;
				col.a = 0;
			};
			this.patterns["white"] = function (frame, pos, age, col) {
				col.r = 1;
				col.g = 1;
				col.b = 1;
				col.a = 1;
			};
			this.patterns["white fadeout"] = function (frame, pos, age, col) {
				col.r = 1;
				col.g = 1;
				col.b = 1;
				col.a = (1 - age / this.historyLength);
			};
			this.patterns["white stripes"] = function (frame, pos, age, col) {
				var pattern1 = (pos) % 4 == 0;
				var pattern2 = (pos + 1) % 4 == 0;
				var pattern = Math.max(pattern1, pattern2);
				col.r = pattern;
				col.g = pattern;
				col.b = pattern;
				col.a = (pattern - age / this.historyLength);
			};
			this.patterns["domain map"] = function (frame, pos, age, col) {
				var x = (frame % 64) / 64;
				var y = 2 * pos / this.numLights;
				col.r = x;
				col.g = y;
				col.b = 0;
				col.a = (1 - 0.5 * age / this.historyLength);
			};
			this.patterns["rgb sines"] = function (frame, pos, age, col) {
				var x = (frame % 64) / 64;
				var y = 2 * pos / this.numLights;
				var thickness = 0.05;
				var frequency = 0.25;
				var amplitude = 0.33;
				var sine1 = Math.sin(frame * frequency) * amplitude + 0.5;
				var sine1Mask = (y - sine1 - thickness < 0) * (y - sine1 + thickness > 0);
				var sine2 = Math.sin(frame * frequency + Math.PI * 2 / 3) * amplitude + 0.5;
				var sine2Mask = (y - sine2 - thickness < 0) * (y - sine2 + thickness > 0);
				var sine3 = Math.sin(frame * frequency - Math.PI * 2 / 3) * amplitude + 0.5;
				var sine3Mask = (y - sine3 - thickness < 0) * (y - sine3 + thickness > 0);
				col.r = sine1Mask;
				col.g = sine2Mask;
				col.b = sine3Mask;
				var alphaMask = Math.max(sine1Mask, Math.max(sine2Mask, sine3Mask));
				col.a = alphaMask;
			};
			this.patterns["cmy sines"] = function (frame, pos, age, col) {
				var x = (frame % 64) / 64;
				var y = 2 * pos / this.numLights;
				var thickness = 0.05;
				var frequency = 0.25;
				var amplitude = 0.33;
				var sine1 = Math.sin(frame * frequency) * amplitude + 0.5;
				var sine1Mask = (y - sine1 - thickness < 0) * (y - sine1 + thickness > 0);
				var sine2 = Math.sin(frame * frequency + Math.PI * 2 / 3) * amplitude + 0.5;
				var sine2Mask = (y - sine2 - thickness < 0) * (y - sine2 + thickness > 0);
				var sine3 = Math.sin(frame * frequency - Math.PI * 2 / 3) * amplitude + 0.5;
				var sine3Mask = (y - sine3 - thickness < 0) * (y - sine3 + thickness > 0);
				col.r = sine1Mask + sine2Mask;
				col.g = sine2Mask + sine3Mask;
				col.b = sine3Mask + sine1Mask;
				var alphaMask = Math.max(sine1Mask, Math.max(sine2Mask, sine3Mask));
				col.a = alphaMask;
			};
			this.patterns["compartments"] = function (frame, pos, age, col) {
				var y = pos / this.numLights;
				var bandThickness = 0.05;
				// baseline
				var band1Pos = 0.5;
				var thickness = 0.015;
				var band1Mask = (y - band1Pos - thickness < 0) * (y - band1Pos + thickness > 0);
				// divide
				var width = 24;
				var index = frame % width;
				var divide = (index == 0) ? 1 : 0;
				col.r = band1Mask + divide;
				col.g = band1Mask + divide;
				col.b = band1Mask + divide;
				var alphaMask = Math.max(band1Mask, Math.max(divide, 0));
				col.a = alphaMask;
			};
			this.patterns["heart"] = function (frame, pos, age, col) {
				var y = pos / this.numLights;
				var bandThickness = 0.05;
				var dotMask = (frame % 2 == 0 && pos % 2 == 0) ? 1 : 0;
				// baseline
				var band1Pos = 0.6;
				var thickness = 0.015;
				var band1Mask = (y - band1Pos - thickness < 0) * (y - band1Pos + thickness > 0);
				// divide compartments
				var num = 8;
				var width = 24;
				var index = frame % width;
				var divide = (index == 0) ? 1 : 0;
				var heartFrame = ((frame - index) / width % num == 0) ? 1 : 0;
				var cx = index / width - 0.5;
				var cy = (y - band1Pos) * 3 + Math.abs(index / width - 0.5) * 0.7;
				var d = Math.sqrt(cx * cx + cy * cy);
				var ang = Math.atan2(cy, cx);
				var heartMask = (d < 0.5) ? heartFrame : 0;
				heartFrame = heartMask;
				col.r = band1Mask + divide + heartFrame;
				col.g = band1Mask + divide + heartFrame;
				col.b = band1Mask + divide + heartFrame;
				var alphaMask = Math.max(band1Mask, Math.max(divide, heartFrame * (1 + 0 * dotMask)));
				col.a = alphaMask;
			};

			this.patterns["smiley"] = function (frame, pos, age, col) {
				var width = 16;
				var height = 16;

				var array = [
					[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
					[0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0],
					[0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0],
					[1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0],
					[1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0],
					[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
					[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
					[1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
				];

				var x = (frame % width);
				var offsety = 64;

				var y = pos - offsety;

				var mask = 0;
				if (y >= 0 && y < height) {
					mask = array[y][x];
				}

				col.r = mask;
				col.g = mask;
				col.b = mask;
				col.a = mask;
			};

			this.createTextPatternFn = function (text, bgBlackness) {
				var canvas = document.createElement("canvas");
				var ctx = canvas.getContext("2d");
				var font = "bold italic 18px arial";
				ctx.font = font;
				var l = Math.ceil(ctx.measureText(text).width);
				canvas.width = l;
				canvas.height = 16;

				ctx.fillStyle = "rgba(0,0,0," + bgBlackness + ")";
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				ctx.fillStyle = "#FFF";
				ctx.font = font;
				ctx.fillText(text, 0, 15);
				var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

				var patternFn = function (frame, pos, age, col) {
					var x = (frame % canvas.width);
					var offsety = 32;
					var y = pos - offsety;
					if (y >= 0 && y < canvas.height) {
						var i = (y * canvas.width + x) * 4;
						col.r = data[i + 0] / 256;
						col.g = data[i + 1] / 256;
						col.b = data[i + 2] / 256;
						col.a = data[i + 3] / 256;
					} else {
						col.r = 0;
						col.g = 0;
						col.b = 0;
						col.a = 0;
					}
				};

				return patternFn;
			}

			this.applyColor = this.patterns["rgb sines"]; // replace this anytime at runtime
			this.applyColor = this.createTextPatternFn("3D Web Fest 2016  ", 0.5);

			function P(m, e) {
				return Math.pow(m, e);
			}
			this.lastRenderFrame = 0;
			this.drawLightStreaks = function (context) {
				var framesSinceLastRender = this.frame - this.lastRenderFrame;
				this.lastRenderFrame = this.frame;
				var lightStreakLength = Math.min(this.postureHistory.length, framesSinceLastRender + 1);
				//lightStreakLength = this.postureHistory.length; // draw all history
				var p2d = {};
				for (lightID = 0; lightID < this.numLights; lightID++) {
					for (i = 1; i < lightStreakLength; i++) {
						var preposture = this.postureHistory[i - 1];
						var posture = this.postureHistory[i];
						if (posture[lightID] != undefined && preposture[lightID] != undefined) {
							this.applyColor(posture[lightID].frame, lightID, i, posture[lightID].col);
							var c = posture[lightID].col;
							if (c.a != 0) {
								context.beginPath();
								context.strokeStyle = "rgba(" + Math.floor(256 * c.r) + "," + Math.floor(256 * c.g) + "," + Math.floor(256 * c.b) + "," + c.a + ")";
								project(preposture[lightID], p2d);
								context.moveTo(p2d.x, p2d.y);
								project(posture[lightID], p2d);
								context.lineTo(p2d.x, p2d.y);
								context.stroke();
							}
						}
					}
				}
			}
		}

	</script>
	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aPos;
		attribute vec2 aTexCoord;
		varying   vec2 uv;
		void main(void) {
		gl_Position = vec4(aPos, 1.);
		uv = aTexCoord;
		}
	</script>
	<script id="shader-fs-inc" type="x-shader/x-fragment">
		#ifdef GL_ES
		precision mediump float;
		#endif

		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_prev_n;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_blur2;
		uniform sampler2D sampler_blur3;
		uniform sampler2D sampler_blur4;
		uniform sampler2D sampler_blur5;
		uniform sampler2D sampler_blur6;
		uniform sampler2D sampler_noise;
		uniform sampler2D sampler_noise_n;
		uniform sampler2D sampler_fluid;
		uniform sampler2D sampler_fluid_p;
		uniform sampler2D sampler_particles;
		uniform sampler2D sampler_particle_projection;
		uniform sampler2D sampler_sticky_scene;
		uniform sampler2D sampler_poitoy_scene;
		uniform sampler2D sampler_spline_scene;

		varying vec2 uv;
		uniform vec2 texSize;
		uniform vec2 pixelSize;
		uniform vec2 aspect;
		uniform vec2 scale;

		uniform vec2 mouse;
		uniform vec2 mouseV;
		uniform float mouseDown;

		uniform float fps;
		uniform float time;
		uniform float frame;

		uniform vec2 particleTexSize;
		uniform vec2 activeRange;
		uniform vec2 pen;
		uniform vec2 oldPen;

		uniform vec4 rnd;
		uniform vec4 rainbow;

		uniform vec4 mover0;
		uniform int moverState0;
		uniform vec4 mover1;
		uniform int moverState1;
		uniform vec4 mover2;
		uniform int moverState2;
		uniform vec4 mover3;
		uniform int moverState3;
		uniform vec4 mover4;
		uniform int moverState4;
		uniform vec4 mover5;
		uniform int moverState5;
		uniform vec4 mover6;
		uniform int moverState6;
		uniform vec4 mover7;
		uniform int moverState7;
		uniform vec4 mover8;
		uniform int moverState8;
		uniform vec4 mover9;
		uniform int moverState9;
		uniform vec2 head0;
		uniform vec4 col0;
		uniform vec2 head1;
		uniform vec4 col1;
		uniform vec2 head2;
		uniform vec4 col2;
		uniform vec2 head3;
		uniform vec4 col3;
		uniform vec2 head4;
		uniform vec4 col4;
		uniform vec2 head5;
		uniform vec4 col5;
		uniform vec2 head6;
		uniform vec4 col6;
		uniform vec2 head7;
		uniform vec4 col7;
		uniform vec2 head8;
		uniform vec4 col8;
		uniform vec2 head9;
		uniform vec4 col9;

		uniform vec4 midifader1;
		uniform vec4 midifader2;
		uniform vec4 midiknob1;
		uniform vec4 midiknob2;

		vec4 BlurA(vec2 uv, int level)
		{
		if(level == 0)
		{
		return texture2D(sampler_prev, fract(uv));
		}
		if(level == 1)
		{
		return texture2D(sampler_blur, fract(uv));
		}
		if(level == 2)
		{
		return texture2D(sampler_blur2, fract(uv));
		}
		if(level == 3)
		{
		return texture2D(sampler_blur3, fract(uv));
		}
		if(level == 4)
		{
		return texture2D(sampler_blur4, fract(uv));
		}
		if(level == 5)
		{
		return texture2D(sampler_blur5, fract(uv));
		}
		return texture2D(sampler_blur6, uv);
		}

		vec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){
		vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);
		vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);
		return vec2( dot(dX, selector), dot(dY, selector) );
		}

		vec2 uv_zoom_exp(vec2 uv, vec2 center, vec2 aspect, float zoom, float zoom_exp, float zoom_factor){
		vec2 uv_correct = 0.5 + (uv -0.5)* aspect;
		vec2 center_correct = 0.5 + ( center - 0.5) * aspect;
		vec2 zoom_distorted = center_correct + (uv_correct - center_correct)*(1. - zoom * pow(zoom_exp, zoom_factor*length(uv_correct-center_correct)));
		return 0.5 + (zoom_distorted - 0.5) / aspect;
		}

		bool is_onscreen(vec2 uv){
		return (uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.);
		}

		float filter(vec2 uv, vec2 pos){
		return clamp( 1.-length((uv-pos)*texSize)/2., 0. , 1.);
		}

		float border(vec2 uv, float border, vec2 texSize){
		uv*=texSize;
		return (uv.x
		<border || uv.x>
			texSize.x-border || uv.y<border || uv.y>
				texSize.y-border) ? 1.:.0;
				}

				#define pi 3.141592653589793238462643383279
				#define pi_inv 0.318309886183790671537767526745
				#define pi2_inv 0.159154943091895335768883763372

				float border(vec2 domain, float thickness){
				vec2 uv = fract(domain-vec2(0.5));
				uv = min(uv,1.-uv)*2.;
				return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);
				}

				float square_mask(vec2 domain){
				return (domain.x <= 1. && domain.x >= 0. && domain.y <= 1. && domain.y >= 0.) ? 1. : 0.;
				}

				vec2 complex_mul(vec2 factorA, vec2 factorB){
				return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);
				}

				vec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){
				vec2 uv = domain - center;
				float d = length(uv);
				return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;
				}

				vec2 complex_div(vec2 numerator, vec2 denominator){
				return vec2( numerator.x*denominator.x + numerator.y*denominator.y,
				numerator.y*denominator.x - numerator.x*denominator.y)/
				vec2(denominator.x*denominator.x + denominator.y*denominator.y);
				}

				// HSL to RGB converter code from http://www.gamedev.net/topic/465948-hsl-shader-glsl-code/
				float Hue_2_RGB(float v1, float v2, float vH )
				{
				float ret;
				if ( vH < 0.0 )
				vH += 1.0;
				if ( vH > 1.0 )
				vH -= 1.0;
				if ( ( 6.0 * vH ) < 1.0 )
				ret = ( v1 + ( v2 - v1 ) * 6.0 * vH );
				else if ( ( 2.0 * vH ) < 1.0 )
				ret = ( v2 );
				else if ( ( 3.0 * vH ) < 2.0 )
				ret = ( v1 + ( v2 - v1 ) * ( ( 2.0 / 3.0 ) - vH ) * 6.0 );
				else
				ret = v1;
				return ret;
				}

				vec3 hsl2rgb(float H, float S, float L){
				float var_2, var_1, R, G, B;
				if (S == 0.0)
				{
				R = L;
				G = L;
				B = L;
				}
				else
				{
				if ( L < 0.5 )
				{
				var_2 = L * ( 1.0 + S );
				}
				else
				{
				var_2 = ( L + S ) - ( S * L );
				}

				var_1 = 2.0 * L - var_2;

				R = Hue_2_RGB( var_1, var_2, H + ( 1.0 / 3.0 ) );
				G = Hue_2_RGB( var_1, var_2, H );
				B = Hue_2_RGB( var_1, var_2, H - ( 1.0 / 3.0 ) );
				}
				return vec3(R,G,B);
				}

				float lum(vec4 col){
				return dot(col, vec4(0.3, 0.59, 0.11, 0.));
				}

				vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
				vec4 dX = texture2D(sampler, uv + vec2(1.,0.)*d) - texture2D(sampler, uv - vec2(1.,0.)*d);
				vec4 dY = texture2D(sampler, uv + vec2(0.,1.)*d) - texture2D(sampler, uv - vec2(0.,1.)*d);
				return -vec2( dot(dX, selector), dot(dY, selector) );
				}

				vec2 rot90(vec2 vector){
				return vector.yx*vec2(1,-1);
				}

				float circle(vec2 uv, vec2 aspect, float scale){
				return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);
				}

				float sigmoid(float x) {
				return 2./(1. + exp2(-x)) - 1.;
				}

				float smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){
				return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;
				}

				float tip(vec2 uv, vec2 pos, float size, float min)
				{
				return max( min, 1. - length((uv - pos) * aspect / size) );
				}

				float warpFilter(vec2 uv, vec2 pos, float size, float ramp)
				{
				return 0.5 + sigmoid( tip(uv, pos, size, -16.) * ramp) * 0.5;
				}

				vec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)
				{
				vec2 pos_correct = 0.5 + (pos - 0.5);
				vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;
				float filter = warpFilter(uv, pos_correct, size, ramp);
				return mix(uv, rot_uv, filter);
				}

				vec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)
				{
				float ramp = 4.;

				float d = 0.138 / 1024. / pixelSize.y;

				float l = length(vel);
				vec2 p1 = pos;
				vec2 p2 = pos;

				if(l > 0.){
				vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;
				p1 = pos - normal * d / 2.;
				p2 = pos + normal * d / 2.;
				}

				float w = l / d * 2.;

				// two overlapping rotations that would annihilate when they were not displaced.
				vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));
				vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));
				return (circle1 + circle2) / 2.;
				}


	</script>
	<script id="shader-fs-copy" type="x-shader/x-fragment">
		uniform sampler2D source;
		void main(void) {
		gl_FragColor = texture2D(source, uv);
		}
	</script>
	<script id="shader-fs-init" type="x-shader/x-fragment">
		void main(void){
		gl_FragColor = vec4(0.);
		}
	</script>
	<script id="shader-fs-move-particles" type="x-shader/x-fragment">
		vec4 applyMoverForce(vec4 p, vec2 f00, int moverState, vec4 mover, float active){
		if(active == 1. && (moverState == 4 || moverState == 3)){
		vec2 pos = (p.xy - mover.xy);
		float d = length(pos*aspect);

		float area = smoothcircle(p.xy-mover.xy+0.5, aspect, 0.05, 12.);
		float dir = 0.002;
		if( moverState == 3){
		dir = -1./6.*d;
		}
		p.zw += pos * area * dir;

		//p.xy += mover.zw * float(d < 0.04); // simple window cleaner
		}
		return p;
		}

		vec4 applyMoverForces(vec4 p, vec2 foo){
		p = applyMoverForce(p, foo, moverState0, mover0, col0.a); // first person, left hand
		p = applyMoverForce(p, foo, moverState1, mover1, col0.a); // right hand
		p = applyMoverForce(p, foo, moverState2, mover2, col1.a); // second person
		p = applyMoverForce(p, foo, moverState3, mover3, col1.a);
		p = applyMoverForce(p, foo, moverState4, mover4, col2.a); // third
		p = applyMoverForce(p, foo, moverState5, mover5, col2.a);
		p = applyMoverForce(p, foo, moverState6, mover6, col3.a);
		p = applyMoverForce(p, foo, moverState7, mover7, col3.a);
		p = applyMoverForce(p, foo, moverState8, mover8, col4.a);
		p = applyMoverForce(p, foo, moverState9, mover9, col4.a);

		p = applyMoverForce(p, foo, 3, vec4(mouse, mouseV), mouseDown);

		p.xy += foo;
		return p;
		}

		void main(){ //#particles
		vec4 p = texture2D(sampler_particles, uv); // residual location and velocity of the particle in the previous frame
		vec2 v = texture2D(sampler_fluid, p.xy).xz; // motion vector for the actual location from the advection field texture
		vec4 noise = texture2D(sampler_noise, uv + rnd.xy);
		p.xy += v*scale;
		p.xy += noise.xy*pixelSize/32.;
		p.xy += gradient(sampler_blur3, p.xy, pixelSize*16., vec4(1.,2,-1.,0.))*pixelSize;
		p.xy += gradient(sampler_blur2, p.xy, pixelSize*8., vec4(-2,2,1.,0.))*pixelSize;
		p.xy += gradient(sampler_blur, p.xy, pixelSize*4., vec4(-4, 2,4.,0.))*pixelSize;

		vec2 domain = uv;
		float index = ((domain.y-0.5/particleTexSize.y) + (domain.x-0.5/particleTexSize.x) * particleTexSize.y) * particleTexSize.x;
		float particleCount = particleTexSize.x * particleTexSize.y;
		index /= particleCount;
		//if(activeRange.x < index && index < activeRange.y && noise.x - noise.y < 0.618){
		//	p.xy = mix(oldPen, pen, (index - activeRange.x)/(activeRange.y - activeRange.x));
		if(length(noise-0.5) < 0.05){
		p.xy = pen;
		p.zw = (noise.zw-0.5)*2048.;
		}else{
		//p.xy += noise.zw*pixelSize.xy/2.;
		}

		// reset position when off canvas
		gl_FragColor = mix( p, vec4(fract(p.xyz), 1.) , vec4((p.x < 0. || p.x > 1.)||(p.y < 0. || p.y > 1.)||(p.z < 0. || p.z > 1.)||(p.w < 0. || p.w > 1.)));

		gl_FragColor.zw = p.zw;
		}
	</script>
	<script id="shader-fs-advance" type="x-shader/x-fragment">
		void main() { // #warp and #react. the results of this program will be diffused
		vec2 uv_orig = uv;
		vec2 motion = texture2D(sampler_fluid, uv).xz*pixelSize;//*0.;
		vec4 noise = texture2D(sampler_noise, uv_orig + rnd.xy)-0.5;

		float penTip = smoothcircle(uv + 0.5 - pen, aspect, 1./256., 1024.);

		vec4 rawSpline = texture2D(sampler_spline_scene, uv);
		vec4 rawPoiToyScene = texture2D(sampler_poitoy_scene, uv_orig);

		vec2 uv =  uv_orig - motion + gradient(sampler_blur, uv, pixelSize*4., vec4(0.5,0.5,-4.,0))*pixelSize;

		gl_FragColor.x = texture2D(sampler_prev, uv).x + texture2D(sampler_blur4, uv).y*4./256.;
		gl_FragColor.x += (texture2D(sampler_blur, uv).x-texture2D(sampler_blur6, uv).x)*8./256. + 0./256. + noise.x*7./256.;

		uv = uv_orig - motion + gradient(sampler_blur, uv_orig, pixelSize*4., vec4(-0.5,-0.25,-2.,0))*pixelSize;

		gl_FragColor.z = texture2D(sampler_prev, uv_orig - (motion + (uv_orig - 0.5)*0.01)*max(0.,1.-texture2D(sampler_prev, uv_orig).z*2.5)).z;
		gl_FragColor.z = max(gl_FragColor.z - 1./512., max(penTip,rawPoiToyScene.x));

		uv = uv_orig + noise.zx*pixelSize*1.;
		gl_FragColor.y = texture2D(sampler_prev, uv).y;
		//  	gl_FragColor.y += texture2D(sampler_particle_projection, uv_orig).y*128./256. - 2.;//196./256.;
		gl_FragColor.y = texture2D(sampler_particle_projection, uv_orig).y;

		//	 	gl_FragColor.y = mix(texture2D(sampler_particle_projection, uv).y, texture2D(sampler_particle_projection, uv).y,0.5);


		uv =  uv_orig - motion + gradient(sampler_blur, uv, pixelSize*4., vec4(0.,0.5,-4.,0))*pixelSize;

		uv = vortex_pair_warp(uv_orig, mouse, mouseV*aspect*1.5/texSize);
		uv = vortex_pair_warp(uv, pen, -(oldPen - pen)*aspect*2.25);

		vec2 d = pixelSize*5.;
		vec2 ga;
		ga.x = texture2D(sampler_blur3, uv-vec2(1.,0.)*d).a - texture2D(sampler_blur3, uv+vec2(1.,0.)*d).a;
		ga.y = texture2D(sampler_blur3, uv-vec2(0.,1.)*d).a - texture2D(sampler_blur3, uv+vec2(0.,1.)*d).a;

		vec2 uva = uv + ga*6.*pixelSize; // makes a plane deformation vector to gradually shrink the red color patches at its borders

		float a = texture2D(sampler_prev, uva).a;
		a += (texture2D(sampler_blur2, uva).a - texture2D(sampler_blur4, uv).a)*24./256.; // "reaction-diffusion"
		a += 1.75/256.;

		//gl_FragColor.a = a;

		vec4 prev = texture2D(sampler_prev, uv_orig);

		gl_FragColor.a = a;

		gl_FragColor = clamp(gl_FragColor, 0. , 1.);

		}
	</script>
	<script id="shader-fs-composite" type="x-shader/x-fragment">
		vec4 moverCol(int moverState){
		vec4 red = vec4(1,0,0,0);
		vec4 green = vec4(0,1,0,0);
		vec4 blue = vec4(0,0,1,0);

		vec4 cyan = vec4(0,1,1,0);
		vec4 yellow = vec4(1,1,0,0);

		vec4 purple = vec4(0.5,0,.50,0);

		vec4 col = purple; // unknown

		if(moverState == 1){ // lasso
		col = cyan;
		}
		if(moverState == 2){ // open
		col = red;
		}
		if(moverState == 3){ // closed
		col = green;
		}
		if(moverState == 4){ // pointy
		col = yellow;
		}
		return col;
		}

		void mixInMover(int moverState, vec4 mover, vec4 col){
		if(col.a == 1.){
		gl_FragColor = mix(gl_FragColor, moverCol(moverState), smoothcircle(uv-mover.xy+0.5, aspect, 0.025, 96.));
		}
		}

		void mixInMovers(){
		mixInMover(moverState0, mover0, col0); // first person, left hand
		mixInMover(moverState1, mover1, col0); // right hand

		mixInMover(moverState2, mover2, col1); // second person
		mixInMover(moverState3, mover3, col1);

		mixInMover(moverState4, mover4, col2); // third
		mixInMover(moverState5, mover5, col2);
		mixInMover(moverState6, mover6, col3);
		mixInMover(moverState7, mover7, col3);
		mixInMover(moverState8, mover8, col4);
		mixInMover(moverState9, mover9, col4);
		}

		float mouseFilter(vec2 uv){
		return clamp( 1.-length((uv-mouse)*texSize)/16., 0. , 1.);
		}

		void main(void) { // #composite
		vec2 motion = texture2D(sampler_fluid, uv).xz*pixelSize*2.;

		vec4 rawStickyScene = texture2D(sampler_sticky_scene, uv);
		vec2 uv = uv - motion;
		vec4 prev = texture2D(sampler_prev, uv);
		vec4 rawSpline = texture2D(sampler_spline_scene, uv);
		vec4 rawPoiToyScene = texture2D(sampler_poitoy_scene, uv);
		vec4 rawParticles = texture2D(sampler_particle_projection, uv);

		float penTip = smoothcircle(uv + 0.5 - pen, aspect, 1./256., 1024.);

		gl_FragColor = vec4(prev.a);
		gl_FragColor = mix(gl_FragColor, vec4(1), prev);
		gl_FragColor = mix(gl_FragColor, vec4(1), rawSpline);
		gl_FragColor = mix(gl_FragColor, vec4(1), rawPoiToyScene);
		gl_FragColor = mix(gl_FragColor, vec4(1), rawStickyScene);
		gl_FragColor = mix(gl_FragColor, vec4(1), penTip);
		//gl_FragColor.yxzw = 1.- gl_FragColor;
		//mixInMovers();
		gl_FragColor.a = 1.;
		}
	</script>
	<script id="shader-fs-blur-horizontal" type="x-shader/x-fragment">
		// Gaussian factors from https://github.com/mattdesl/lwjgl-basics/wiki/ShaderLesson5
		// horizontal blur fragment shader
		uniform sampler2D src_tex;

		void main(void) // fragment
		{
		float h = pixelSize.x;
		vec4 sum = vec4(0.0);
		sum += texture2D(src_tex, vec2(-4,0) * pixelSize + uv ) * 0.0162162162;
		sum += texture2D(src_tex, vec2(-3,0) * pixelSize + uv ) * 0.0540540541;
		sum += texture2D(src_tex, vec2(-2,0) * pixelSize + uv ) * 0.1216216216;
		sum += texture2D(src_tex, vec2(-1,0) * pixelSize + uv ) * 0.1945945946;
		sum += texture2D(src_tex, vec2( 0,0) * pixelSize + uv ) * 0.2270270270;
		sum += texture2D(src_tex, vec2( 1,0) * pixelSize + uv ) * 0.1945945946;
		sum += texture2D(src_tex, vec2( 2,0) * pixelSize + uv ) * 0.1216216216;
		sum += texture2D(src_tex, vec2( 3,0) * pixelSize + uv ) * 0.0540540541;
		sum += texture2D(src_tex, vec2( 4,0) * pixelSize + uv ) * 0.0162162162;
		gl_FragColor = sum;
		}
	</script>
	<script id="shader-fs-blur-vertical" type="x-shader/x-fragment">
		uniform sampler2D src_tex;

		void main(void) // fragment
		{
		float v = pixelSize.y;
		vec4 sum = vec4(0.0);
		sum += texture2D(src_tex, vec2(0,-4) * pixelSize + uv ) * 0.0162162162;
		sum += texture2D(src_tex, vec2(0,-3) * pixelSize + uv ) * 0.0540540541;
		sum += texture2D(src_tex, vec2(0,-2) * pixelSize + uv ) * 0.1216216216;
		sum += texture2D(src_tex, vec2(0,-1) * pixelSize + uv ) * 0.1945945946;
		sum += texture2D(src_tex, vec2(0, 0) * pixelSize + uv ) * 0.2270270270;
		sum += texture2D(src_tex, vec2(0, 1) * pixelSize + uv ) * 0.1945945946;
		sum += texture2D(src_tex, vec2(0, 2) * pixelSize + uv ) * 0.1216216216;
		sum += texture2D(src_tex, vec2(0, 3) * pixelSize + uv ) * 0.0540540541;
		sum += texture2D(src_tex, vec2(0, 4) * pixelSize + uv ) * 0.0162162162;
		gl_FragColor = sum;
		}
	</script>
	<script id="shader-fs-add-mouse-motion" type="x-shader/x-fragment">
		void main(void){
		vec2 v = texture2D(sampler_fluid, uv).xz;
		if(length(mouseV) > 0.){
		v = mix(v, mouseV, filter(uv, mouse)*0.85);
		}
		float scale = 8.;
		// first person left hand
		if(length(mover0.zw) > 0.){
		v = mix(v, mover0.zw*scale*texSize, filter(uv, mover0.xy)*0.85);
		}
		// first person right hand
		if(length(mover1.zw) > 0.){
		v = mix(v, mover1.zw*scale*texSize, filter(uv, mover1.xy)*0.85);
		}

		// second person left hand
		if(length(mover2.zw) > 0.){
		v = mix(v, mover2.zw*scale*texSize, filter(uv, mover2.xy)*0.85);
		}
		// second person right hand
		if(length(mover3.zw) > 0.){
		v = mix(v, mover3.zw*scale*texSize, filter(uv, mover3.xy)*0.85);
		}
		// third person left hand
		if(length(mover4.zw) > 0.){
		v = mix(v, mover4.zw*scale*texSize, filter(uv, mover4.xy)*0.85);
		}
		// third person right hand
		if(length(mover5.zw) > 0.){
		v = mix(v, mover5.zw*scale*texSize, filter(uv, mover5.xy)*0.85);
		}
		// 4th person left hand
		if(length(mover6.zw) > 0.){
		v = mix(v, mover6.zw*scale*texSize, filter(uv, mover6.xy)*0.85);
		}
		// 4th person right hand
		if(length(mover7.zw) > 0.){
		v = mix(v, mover7.zw*scale*texSize, filter(uv, mover7.xy)*0.85);
		}

		gl_FragColor.xz = v*0.999;
		}
	</script>
	<script id="shader-fs-advect" type="x-shader/x-fragment">
		const float dt = .0005;

		void main(void){
		vec2 v = texture2D(sampler_fluid, uv).xz;

		vec2 D = -texSize*vec2(v.x, v.y)*dt;

		vec2 Df = floor(D),   Dd = D - Df;
		vec2 uv = uv + Df*pixelSize;

		vec2 uv0, uv1, uv2, uv3;

		uv0 = uv + pixelSize*vec2(0.,0.);
		uv1 = uv + pixelSize*vec2(1.,0.);
		uv2 = uv + pixelSize*vec2(0.,1.);
		uv3 = uv + pixelSize*vec2(1.,1.);

		vec2 v0 = texture2D(sampler_fluid, uv0).xz;
		vec2 v1 = texture2D(sampler_fluid, uv1).xz;
		vec2 v2 = texture2D(sampler_fluid, uv2).xz;
		vec2 v3 = texture2D(sampler_fluid, uv3).xz;

		v = mix( mix( v0, v1, Dd.x), mix( v2, v3, Dd.x), Dd.y);

		gl_FragColor.xz = v*(1.-border(uv, 1., texSize))*0.99975;
		}
	</script>
	<script id="shader-fs-p" type="x-shader/x-fragment">
		uniform sampler2D sampler_v;
		uniform sampler2D sampler_p;
		const float h = 1./1024.;

		void main(void){

		vec2 v = texture2D(sampler_v, uv).xz;
		float v_x = texture2D(sampler_v, uv - vec2(1.,0.)*pixelSize).r;
		float v_y = texture2D(sampler_v, uv - vec2(0.,1.)*pixelSize).b;

		float n = texture2D(sampler_p, uv- pixelSize*vec2(0.,1.)).r;
		float w = texture2D(sampler_p, uv + pixelSize*vec2(1.,0.)).r;
		float s = texture2D(sampler_p, uv + pixelSize*vec2(0.,1.)).r;
		float e = texture2D(sampler_p, uv - pixelSize*vec2(1.,0.)).r;

		float p = ( n + w + s + e - (v.x - v_x + v.y - v_y)*h ) * .25;

		gl_FragColor.r = p;
		gl_FragColor.ba = vec2(0.); // unused
		}
	</script>
	<script id="shader-fs-div" type="x-shader/x-fragment">
		uniform sampler2D sampler_v;
		uniform sampler2D sampler_p;

		void main(void){
		float p = texture2D(sampler_p, uv).r;
		vec2 v = texture2D(sampler_v, uv).xz;
		float p_x = texture2D(sampler_p, uv + vec2(1.,0.)*pixelSize).r;
		float p_y = texture2D(sampler_p, uv + vec2(0.,1.)*pixelSize).r;

		v -= (vec2(p_x, p_y)-p)*512.;

		gl_FragColor.xz = v;
		}
	</script>
	<script type="x-shader/x-vertex" id="shader-particle-renderer-vs">
		#ifdef GL_ES
		precision mediump float;
		#endif

		attribute vec2 uv; // particle position lookup vector
		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_particles; // particle positions in a float texture
		uniform vec2 mouse;
		uniform vec2 pixelSize;
		varying vec2 domain;

		//varying float vertexID;

		vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
		vec4 dX = texture2D(sampler, uv + vec2(1.,0.)*d) - texture2D(sampler, uv - vec2(1.,0.)*d);
		vec4 dY = texture2D(sampler, uv + vec2(0.,1.)*d) - texture2D(sampler, uv - vec2(0.,1.)*d);
		return vec2( dot(dX, selector), dot(dY, selector) );
		}

		void main() {
		domain = uv;
		gl_Position = (texture2D(sampler_particles, uv) - 0.5)*2.; // pass em flat
		//gl_Position.xy += gradient(sampler_blur, gl_Position.xy*0.5+0.5, pixelSize*3., vec4(0,0.,1,0))*pixelSize*32.;

		gl_Position.zw = vec2(0,1);
		gl_PointSize = 1.;
		}
	</script>
	<script type="x-shader/x-fragment" id="shader-particle-renderer-fs">
		void main() {
		gl_FragColor = vec4(1.0, 0.5, 0.166, 0.33);
		}
	</script>
	<script type="text/javascript">
		function getShader(gl, id, addInc) {
			if (addInc == undefined) {
				addInc = true;
			}

			var shaderScript = document.getElementById(id);
			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					str += k.textContent;
				k = k.nextSibling;
			}

			var fsIncScript = document.getElementById("shader-fs-inc");
			var incStr = "";
			k = fsIncScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					incStr += k.textContent;
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				if (addInc) {
					str = incStr + str;
				}
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex")
				shader = gl.createShader(gl.VERTEX_SHADER);
			else
				return null;
			gl.shaderSource(shader, str);
			gl.compileShader(shader);
			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
				alert("error compiling shader '" + id + "'\n\n" + gl.getShaderInfoLog(shader));
			return shader;
		}

		window.requestAnimFrame = (function () {
			return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame
				|| window.msRequestAnimationFrame || function (callback) {
					window.setTimeout(callback, 1000 / desiredFramerate);
				};
		})();

		var gl;
		var ext;

		var prog_copy;
		var prog_advance;
		var prog_composite;
		var prog_blur_horizontal;
		var prog_blur_vertical;
		var prog_fluid_init;
		var prog_fluid_add_mouse_motion;
		var prog_fluid_advect;
		var prog_fluid_p;
		var prog_fluid_div;
		var prog_move_particles;
		var prog_render_particles;

		var FBO_main;
		var FBO_main2;
		var FBO_noise;
		var FBO_blur;
		var FBO_blur2;
		var FBO_blur3;
		var FBO_blur4;
		var FBO_blur5;
		var FBO_blur6;
		var FBO_helper;
		var FBO_helper2;
		var FBO_helper3;
		var FBO_helper4;
		var FBO_helper5;
		var FBO_helper6;
		var FBO_fluid_v;
		var FBO_fluid_p;
		var FBO_fluid_store;
		var FBO_fluid_backbuffer;
		var FBO_particles; // particle positions in a texture
		var FBO_particles2; // double buffer
		var FBO_particle_projection; // particle render target for projection feedback effects
		var FBO_sticky_scene; // we will copy a 2d drawn scene to a webgl texture using this
		var FBO_poitoy_scene; // 2d drawn scene to webgl texture too
		var FBO_spline_scene; // hooray for the canvas 2d spline editor in WebGL

		var texture_main_n; // main, nearest pixel
		var texture_main_l; // main, linear interpolated access on the same buffer
		var texture_main2_n; // main double buffer, nearest
		var texture_main2_l; // main double buffer, linear
		var texture_blur; // full resolution blur result
		var texture_blur2; // double blur
		var texture_blur3; // quad blur
		var texture_blur4; // use low resolutions wisely ;)
		var texture_blur5;
		var texture_blur6;
		var texture_helper; // needed for multi-pass shader programs (2-pass Gaussian blur)
		var texture_helper2; // (1/4 resolution )
		var texture_helper3; // (1/16 resolution )
		var texture_helper4; // (1/256 resolution )
		var texture_helper5;
		var texture_helper6;
		var texture_noise_n; // nearest pixel access
		var texture_noise_l; // linear interpolated
		var texture_fluid_v; // velocities
		var texture_fluid_p; // pressure
		var texture_fluid_store;
		var texture_fluid_backbuffer;
		var texture_particles;
		var texture_particles2;
		var texture_particle_projection;
		var texture_sticky_scene;
		var texture_poitoy_scene;
		var texture_spline_scene;

		// main texture loop dimensions
		var sizeX = 1024; // must be powers of 2
		var sizeY = 512;
		var viewX = sizeX; // viewport size (ideally exactly the texture size)
		var viewY = sizeY;

		// particle positions will be stored in a texture of that size
		var particlesWidth = 1024;
		var particlesHeight = 512;
		var particleCount = particlesWidth * particlesHeight; // can also be set to lower than particlesWidth * particlesHeight

		var useParticles = true;
		var useProjectionFeedback = true; // rendering half a million points can slow things down significantly, don't render to texture if not needed
		var useFluidSimulation = true; // the textures will be initialized anyway
		var simScale = 8; // for better performance, the fluid simulation will be calculated for cells this times bigger than the main texture's pixels (powers of 2)

		var desiredFramerate = 100; // more like a limit
		var startFullpage = true;
		var renderParticlesOnly = false;

		// don't change vars below
		var canvas2d;
		var canvas2dContext;

		var frame = 0; // frame counter to be resetted every 1000ms
		var framecount = 0; // not resetted
		var mainBufferToggle = 1;
		var halted = false;
		var fps, fpsDisplayUpdateTimer;
		var time, starttime = new Date().getTime();

		var mouseX = 0.5;
		var mouseY = 0.5;
		var mouseDown = false;
		var oldMouseX = 0;
		var oldMouseY = 0;
		var mouseDx = 0;
		var mouseDy = 0;

		var aspectx = 2;
		var aspecty = 1;

		// geometry
		var particleBuffer, squareBuffer, hLineBuffer, vLineBuffer;

		function updateAspectRatio() {
			aspectx = Math.max(1, viewX / viewY);
			aspecty = Math.max(1, viewY / viewX);
		}

		var poiToy = new PoiToy();
		poiToy.z = 0.5;
		poiToy.applyColor = poiToy.createTextPatternFn("Debugviewart  #  ", 0.5);

		function load() {
			hide(); // unhide with doubleclick
			clearInterval(fpsDisplayUpdateTimer);
			canvas2d = document.createElement("canvas");
			canvas2d.width = sizeX;
			canvas2d.height = sizeY;
			canvas2dContext = canvas2d.getContext("2d");
			var c = document.getElementById("c");
			try {
				gl = c.getContext("webgl", {
					depth: false
				});
			} catch (e) {
			}
			if (!gl) {
				alert("Meh! Y u no support WebGL !?!");
				return;
			}

			["OES_texture_float", "OES_standard_derivatives", "OES_texture_float_linear"].forEach(function (name) {
				console.log("get extension " + name);
				try {
					ext = gl.getExtension(name);
				} catch (e) {
					alert(e);
				}
				if (!ext) {
					alert("Meh! Y u no support " + name + " !?!)");
					return;
				}
				ext = false;
			});

			var vertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);

			if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0) {
				alert("Meh! Y u no support vertex shader textures !?!");
				return;
			} else {
				console.log("MAX_VERTEX_TEXTURE_IMAGE_UNITS = " + vertexTextures);
			}

			document.onmousemove = function (evt) {
				mouseX = evt.pageX / viewX;
				mouseY = 1 - evt.pageY / viewY;

				poiToy.x = (mouseX - 0.5) * aspectx;
				poiToy.y = (mouseY - 0.5) * aspecty;

				updateSpline(mouseX * sizeX, (1 - mouseY) * sizeY);
			};

			document.onmousedown = function (evt) {
				mouseDown = true;
			}

			document.onmouseup =
				document.onmouseout = function (evt) {
					mouseDown = false;
				}

			document.addEventListener("orientationchange", window.onresize = function () {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
				c.width = viewX;
				c.height = viewY;
				updateAspectRatio();
			});


			if (startFullpage) {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
			}

			c.width = viewX;
			c.height = viewY;
			updateAspectRatio();

			prog_copy = createAndLinkProgram("shader-fs-copy");
			prog_advance = createAndLinkProgram("shader-fs-advance");
			prog_composite = createAndLinkProgram("shader-fs-composite");
			prog_blur_horizontal = createAndLinkProgram("shader-fs-blur-horizontal");
			prog_blur_vertical = createAndLinkProgram("shader-fs-blur-vertical");
			prog_fluid_init = createAndLinkProgram("shader-fs-init");
			prog_fluid_add_mouse_motion = createAndLinkProgram("shader-fs-add-mouse-motion");
			prog_fluid_advect = createAndLinkProgram("shader-fs-advect");
			prog_fluid_p = createAndLinkProgram("shader-fs-p");
			prog_fluid_div = createAndLinkProgram("shader-fs-div");
			prog_move_particles = createAndLinkProgram("shader-fs-move-particles");

			triangleStripGeometry = {
				vertices: new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]),
				texCoords: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
				vertexSize: 3,
				vertexCount: 4,
				type: gl.TRIANGLE_STRIP
			};

			createTexturedGeometryBuffer(triangleStripGeometry);

			hLineVertices = [];
			hLineTexCoords = [];
			for (var y = 0; y < sizeY; y++) {
				hLineVertices.push(-1, -1 + 2 * y / sizeY, 0, 1, -1 + 2 * y / sizeY, 0);
				hLineTexCoords.push(0. / sizeX, (y - 0.5) / sizeY, (sizeX + 0.) / sizeX, (y - 0.5) / sizeY);
			}
			hLineGeometry = {
				vertices: new Float32Array(hLineVertices),
				texCoords: new Float32Array(hLineTexCoords),
				vertexSize: 3,
				vertexCount: sizeY * 2,
				type: gl.LINES
			};

			vLineVertices = [];
			vLineTexCoords = [];
			for (var x = 0; x < sizeX; x++) {
				vLineVertices.push(-1 + 2 * x / sizeX, -1, 0, -1 + 2 * x / sizeX, 1, 0);
				vLineTexCoords.push((x - 0.5) / sizeX, 0. / sizeY, (x - 0.5) / sizeX, (sizeY + 0.) / sizeY);
			}
			vLineGeometry = {
				vertices: new Float32Array(vLineVertices),
				texCoords: new Float32Array(vLineTexCoords),
				vertexSize: 3,
				vertexCount: sizeX * 2,
				type: gl.LINES
			};

			createTexturedGeometryBuffer(hLineGeometry);
			createTexturedGeometryBuffer(vLineGeometry);

			squareBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer);

			var aPosLoc = gl.getAttribLocation(prog_advance, "aPos");
			var aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");

			gl.enableVertexAttribArray(aPosLoc);
			gl.enableVertexAttribArray(aTexLoc);

			var verticesAndTexCoords = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1, // one square of a quad!
				0, 0, 1, 0, 0, 1, 1, 1] // hello texture, you be full
			);

			gl.bufferData(gl.ARRAY_BUFFER, verticesAndTexCoords, gl.STATIC_DRAW);
			gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 8, 0);
			gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 8, 32);

			var noisePixels = [], pixels = [], simpixels = [], pixels2 = [], pixels3 = [], pixels4 = [], pixels5 = [], pixels6 = [], particles = [], particlesIdx = [];
			var dX = 1 / particlesWidth;
			var dY = 1 / particlesHeight;
			for (var j = 0; j < sizeY; j++) {
				for (var i = 0; i < sizeX; i++) {
					noisePixels.push(Math.random(), Math.random(), Math.random(), Math.random());
					pixels.push(0, 0, 0, 1);
					if (i < sizeX / simScale && j < sizeY / simScale)
						simpixels.push(0, 0, 0, 1);
					if (i < sizeX / 2 && j < sizeY / 2)
						pixels2.push(0, 0, 0, 1);
					if (i < sizeX / 4 && j < sizeY / 4)
						pixels3.push(0, 0, 0, 1);
					if (i < sizeX / 8 && j < sizeY / 8)
						pixels4.push(0, 0, 0, 1);
					if (i < sizeX / 16 && j < sizeY / 16)
						pixels5.push(0, 0, 0, 1);
					if (i < sizeX / 32 && j < sizeY / 32)
						pixels6.push(0, 0, 0, 1);
					if (i < particlesWidth && j < particlesHeight) {
						particles.push(dX / 2 + i * dX, dY / 2 + j * dY, 0, 0); // initial particle positions, here: uniform distribution
					}
				}
			}

			for (var i = 0; i < particlesHeight; i++) {
				for (var j = 0; j < particlesWidth; j++) {
					particlesIdx.push(dX / 2 + j * dX, dY / 2 + i * dY); // coordinate lookup vectors (center of pixels)
				}
			}

			FBO_main = gl.createFramebuffer();
			FBO_main2 = gl.createFramebuffer();
			var glPixels;
			glPixels = new Float32Array(noisePixels);
			texture_main_n = createAndBindTexture(glPixels, 1, FBO_main, gl.NEAREST);
			texture_main2_n = createAndBindTexture(glPixels, 1, FBO_main2, gl.NEAREST);
			glPixels = new Float32Array(noisePixels);
			texture_main_l = createAndBindTexture(glPixels, 1, FBO_main, gl.LINEAR);
			texture_main2_l = createAndBindTexture(glPixels, 1, FBO_main2, gl.LINEAR);

			FBO_fluid_p = gl.createFramebuffer();
			FBO_fluid_v = gl.createFramebuffer();
			FBO_fluid_store = gl.createFramebuffer();
			FBO_fluid_backbuffer = gl.createFramebuffer();
			texture_fluid_v = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_v);
			texture_fluid_p = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_p);
			texture_fluid_store = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_store);
			texture_fluid_backbuffer = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_backbuffer);

			FBO_particle_projection = gl.createFramebuffer();
			texture_particle_projection = createAndBindTexture(new Float32Array(pixels), 1, FBO_particle_projection, gl.LINEAR);

			FBO_helper = gl.createFramebuffer();
			FBO_helper2 = gl.createFramebuffer();
			FBO_helper3 = gl.createFramebuffer();
			FBO_helper4 = gl.createFramebuffer();
			FBO_helper5 = gl.createFramebuffer();
			FBO_helper6 = gl.createFramebuffer();
			texture_helper = createAndBindTexture(new Float32Array(pixels), 1, FBO_helper, gl.NEAREST); // helper buffers for the two-pass Gaussian blur calculation basically
			texture_helper2 = createAndBindTexture(new Float32Array(pixels2), 2, FBO_helper2, gl.NEAREST);
			texture_helper3 = createAndBindTexture(new Float32Array(pixels3), 4, FBO_helper3, gl.NEAREST);
			texture_helper4 = createAndBindTexture(new Float32Array(pixels4), 8, FBO_helper4, gl.NEAREST);
			texture_helper5 = createAndBindTexture(new Float32Array(pixels5), 16, FBO_helper5, gl.NEAREST);
			texture_helper6 = createAndBindTexture(new Float32Array(pixels6), 32, FBO_helper6, gl.NEAREST);

			FBO_blur = gl.createFramebuffer();
			FBO_blur2 = gl.createFramebuffer();
			FBO_blur3 = gl.createFramebuffer();
			FBO_blur4 = gl.createFramebuffer();
			FBO_blur5 = gl.createFramebuffer();
			FBO_blur6 = gl.createFramebuffer();
			texture_blur = createAndBindTexture(new Float32Array(pixels), 1, FBO_blur, gl.LINEAR);
			texture_blur2 = createAndBindTexture(new Float32Array(pixels2), 2, FBO_blur2, gl.LINEAR);
			texture_blur3 = createAndBindTexture(new Float32Array(pixels3), 4, FBO_blur3, gl.LINEAR);
			texture_blur4 = createAndBindTexture(new Float32Array(pixels4), 8, FBO_blur4, gl.LINEAR);
			texture_blur5 = createAndBindTexture(new Float32Array(pixels5), 16, FBO_blur5, gl.LINEAR);
			texture_blur6 = createAndBindTexture(new Float32Array(pixels6), 32, FBO_blur6, gl.LINEAR);

			FBO_sticky_scene = gl.createFramebuffer();
			texture_sticky_scene = createAndBindTexture(new Uint8Array(pixels), 1, FBO_sticky_scene, gl.LINEAR, gl.UNSIGNED_BYTE);

			FBO_poitoy_scene = gl.createFramebuffer();
			texture_poitoy_scene = createAndBindTexture(new Uint8Array(pixels), 1, FBO_poitoy_scene, gl.LINEAR, gl.UNSIGNED_BYTE);

			FBO_spline_scene = gl.createFramebuffer();
			texture_spline_scene = createAndBindTexture(new Uint8Array(pixels), 1, FBO_spline_scene, gl.LINEAR, gl.UNSIGNED_BYTE);

			FBO_noise = gl.createFramebuffer();
			glPixels = new Float32Array(noisePixels);
			texture_noise_n = createAndBindTexture(glPixels, 1, FBO_noise, gl.NEAREST);
			texture_noise_l = createAndBindTexture(glPixels, 1, FBO_noise, gl.LINEAR);

			FBO_particles = gl.createFramebuffer();
			texture_particles = createAndBindParticleTexture(new Float32Array(particles), FBO_particles);

			FBO_particles2 = gl.createFramebuffer();
			texture_particles2 = createAndBindParticleTexture(new Float32Array(particles), FBO_particles2);

			// lesson learned: the (frame) buffer location that we pass to the vertex shader has to be bound to the program before linking!

			var aParticleLoc = 2; // no getAttributeLoc
			prog_render_particles = createAndLinkParticleRenderer(aParticleLoc);

			gl.useProgram(prog_render_particles);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 0);
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "particleTexSize"), particlesWidth, particlesHeight);

			gl.enableVertexAttribArray(aParticleLoc);
			particleBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particlesIdx), gl.STATIC_DRAW);
			gl.vertexAttribPointer(aParticleLoc, 2, gl.FLOAT, false, 0, 0);

			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur);
			gl.activeTexture(gl.TEXTURE3);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur2);
			gl.activeTexture(gl.TEXTURE4);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur3);
			gl.activeTexture(gl.TEXTURE5);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur4);
			gl.activeTexture(gl.TEXTURE6);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur5);
			gl.activeTexture(gl.TEXTURE7);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur6);
			gl.activeTexture(gl.TEXTURE8);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_l);
			gl.activeTexture(gl.TEXTURE9);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_n);
			gl.activeTexture(gl.TEXTURE10);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE11);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.activeTexture(gl.TEXTURE12);
			gl.bindTexture(gl.TEXTURE_2D, texture_particles); // to be swapped anyways
			gl.activeTexture(gl.TEXTURE13);
			gl.bindTexture(gl.TEXTURE_2D, texture_particle_projection);
			gl.activeTexture(gl.TEXTURE14);
			gl.bindTexture(gl.TEXTURE_2D, texture_sticky_scene);
			gl.activeTexture(gl.TEXTURE15);
			gl.bindTexture(gl.TEXTURE_2D, texture_poitoy_scene);
			gl.activeTexture(gl.TEXTURE16);
			gl.bindTexture(gl.TEXTURE_2D, texture_spline_scene);

			fluidInit(FBO_fluid_v);
			fluidInit(FBO_fluid_p);
			fluidInit(FBO_fluid_store);
			fluidInit(FBO_fluid_backbuffer);

			fpsDisplayUpdateTimer = setInterval(fr, 1000);
			time = new Date().getTime() - starttime;

			gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			gl.clearColor(0, 0, 0, 1);

			anim();
		}

		function createTexturedGeometryBuffer(geometry) {
			geometry.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			geometry.aPosLoc = gl.getAttribLocation(prog_advance, "aPos"); // we could take any program here, they all use the same vertex shader
			gl.enableVertexAttribArray(geometry.aPosLoc);
			geometry.aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");
			gl.enableVertexAttribArray(geometry.aTexLoc);
			geometry.texCoordOffset = geometry.vertices.byteLength;
			gl.bufferData(gl.ARRAY_BUFFER, geometry.texCoordOffset + geometry.texCoords.byteLength, gl.STATIC_DRAW);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, geometry.vertices);
			gl.bufferSubData(gl.ARRAY_BUFFER, geometry.texCoordOffset, geometry.texCoords);
			setGeometryVertexAttribPointers(geometry);
		}

		function setGeometryVertexAttribPointers(geometry) {
			gl.vertexAttribPointer(geometry.aPosLoc, geometry.vertexSize, gl.FLOAT, gl.FALSE, 0, 0);
			gl.vertexAttribPointer(geometry.aTexLoc, 2, gl.FLOAT, gl.FALSE, 0, geometry.texCoordOffset);
		}

		function createAndLinkProgram(fsId) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-vs"));
			gl.attachShader(program, getShader(gl, fsId));
			gl.linkProgram(program);
			return program;
		}

		function createAndLinkParticleRenderer(aParticleLoc) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-vs"));
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-fs", false));
			gl.bindAttribLocation(program, aParticleLoc, "uv"); // can't use getAttribLocation later so we must bind before linking
			gl.linkProgram(program);
			return program;
		}

		function createAndBindTexture(glPixels, scale, fbo, filter, type) {
			if (type == undefined) {
				type = gl.FLOAT;
			}
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / scale, sizeY / scale, 0, gl.RGBA, type, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindParticleTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, particlesWidth, particlesHeight, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindSimulationTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / simScale, sizeY / simScale, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function fluidInit(fbo) {
			gl.viewport(0, 0, sizeX / simScale, sizeY / simScale);
			gl.useProgram(prog_fluid_init);
			renderAsTriangleStrip(fbo);
		}

		function setUniforms(program) {
			gl.uniform4f(gl.getUniformLocation(program, "rnd"), Math.random(), Math.random(), Math.random(), Math.random());
			gl.uniform4f(gl.getUniformLocation(program, "rainbow"), rainbowR, rainbowG, rainbowB, 1);
			gl.uniform2f(gl.getUniformLocation(program, "texSize"), sizeX, sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(program, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(program, "mouseV"), mouseDx, mouseDy);
			gl.uniform1f(gl.getUniformLocation(program, "mouseDown"), mouseDown);
			gl.uniform1f(gl.getUniformLocation(program, "fps"), fps);
			gl.uniform1f(gl.getUniformLocation(program, "time"), time);
			gl.uniform1f(gl.getUniformLocation(program, "frame"), framecount);

			gl.uniform2f(gl.getUniformLocation(program, "particleTexSize"), particlesWidth, particlesHeight);
			var index = animationFrame / (animationFrameCount + 1);
			var range = 1. / (animationFrameCount + 1);
			gl.uniform2f(gl.getUniformLocation(program, "activeRange"), index, index + range);

			gl.uniform2f(gl.getUniformLocation(program, "pen"), newPenX, newPenY);
			gl.uniform2f(gl.getUniformLocation(program, "oldPen"), oldPenX || newPenX, oldPenY || newPenY);

			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur"), 2);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur2"), 3);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur3"), 4);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur4"), 5);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur5"), 6);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur6"), 7);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise"), 8);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise_n"), 9);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid"), 10);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid_p"), 11);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particles"), 12);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particle_projection"), 13);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_sticky_scene"), 14);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_poitoy_scene"), 15);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_spline_scene"), 16);

			gl.uniform4f(gl.getUniformLocation(program, "midifader1"), getMidi(0), getMidi(1), getMidi(2), getMidi(3));
			gl.uniform4f(gl.getUniformLocation(program, "midifader2"), getMidi(4), getMidi(5), getMidi(6), getMidi(7));
			gl.uniform4f(gl.getUniformLocation(program, "midiknob1"), getMidi(16), getMidi(17), getMidi(18), getMidi(19));
			gl.uniform4f(gl.getUniformLocation(program, "midiknob2"), getMidi(20), getMidi(21), getMidi(22), getMidi(23));

			setMoverUniforms(program);
		}

		var colors = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1], [0, 1, 1]]; // red green blue yellow magenta cyan

		function setMoverUniforms(program) {
			// push it
			var moverIndex = 0;
			var bodyIndex = 0;
			// project it
			var p3d = {};
			var p2d = {};
			activeTrackingObjects.forEach(function (trackingObject) {
				var stickman = trackingObject.stickman;
				var body = trackingObject.body;
				project(body.head, p2d); // current projection
				var x = p2d.x / sizeX;
				var y = 1 - p2d.y / sizeY;
				gl.uniform2f(gl.getUniformLocation(program, "head" + bodyIndex), x, y);
				var col = colors[bodyIndex];
				gl.uniform4f(gl.getUniformLocation(program, "col" + bodyIndex), col[0], col[1], col[2], 1);
				bodyIndex++;
				// left hand
				project(body.handLeft, p2d); // current projection
				var x = p2d.x / sizeX;
				var y = 1 - p2d.y / sizeY;
				project(body.handLeft.old, p2d); // previous projection
				var old = {};
				old.x = p2d.x / sizeX;
				old.y = 1 - p2d.y / sizeY;
				var dx = (x - old.x); // difference = velocity
				var dy = (y - old.y);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				var state = body.handLeft.state;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), x, y, dx, dy);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), state);
				moverIndex++;
				// right hand
				project(body.handRight, p2d);
				x = p2d.x / sizeX;
				y = 1 - p2d.y / sizeY;
				project(body.handRight.old, p2d);
				old.x = p2d.x / sizeX;
				old.y = 1 - p2d.y / sizeY;
				dx = (x - old.x);
				dy = (y - old.y);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				state = body.handRight.state;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), x, y, dx, dy);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), state);
				moverIndex++;
			});
			// init untracked players
			for (var index = moverIndex; index < 12; index++) {
				gl.uniform4f(gl.getUniformLocation(program, "col" + bodyIndex), 0, 0, 0, 0);
				bodyIndex++;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), 0);
				moverIndex++;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), 0);
				moverIndex++
			}
		}

		function useGeometry(geometry) {
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			setGeometryVertexAttribPointers(geometry);
		}

		function renderGeometry(geometry, targetFBO) {
			useGeometry(geometry);
			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.drawArrays(geometry.type, 0, geometry.vertexCount);
			gl.flush();
		}

		function renderAsTriangleStrip(targetFBO) {
			renderGeometry(triangleStripGeometry, targetFBO);
		}

		function renderParticles(targetFBO, clear) {
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);

			if (targetFBO == null)
				gl.viewport(0, 0, viewX, viewY);
			else
				gl.viewport(0, 0, sizeX, sizeY);

			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.useProgram(prog_render_particles);

			gl.activeTexture(gl.TEXTURE12);
			if (mainBufferToggle < 0) {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
			} else {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
			}

			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 12); // input for the vertex shader
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "particleTexSize"), particlesWidth, particlesHeight);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_blur"), 2);

			var index = animationFrame / (animationFrameCount + 1);
			var range = 1. / (animationFrameCount + 1);
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "activeRange"), index, index + range);

			if (clear == undefined || clear) {
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			}

			gl.enable(gl.BLEND);
			gl.drawArrays(gl.POINTS, 0, particleCount);
			gl.disable(gl.BLEND);

			gl.flush();
		}

		function updateSplineSceneTexture() {
			gl.activeTexture(gl.TEXTURE16);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2d);
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_spline_scene);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_spline_scene, 0);
		}

		function updateStickySceneTexture() {
			gl.activeTexture(gl.TEXTURE14);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2d);
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_sticky_scene);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_sticky_scene, 0);
		}

		function updatePoiToySceneTexture() {
			gl.activeTexture(gl.TEXTURE15);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2d);
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_poitoy_scene);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_poitoy_scene, 0);
		}

		function calculateBlurTextures(texture_source) {
			calculateBlurTexture(texture_source, texture_blur, FBO_blur, texture_helper, FBO_helper, 1);
			calculateBlurTexture(texture_blur, texture_blur2, FBO_blur2, texture_helper2, FBO_helper2, 2);
			calculateBlurTexture(texture_blur2, texture_blur3, FBO_blur3, texture_helper3, FBO_helper3, 4);
			calculateBlurTexture(texture_blur3, texture_blur4, FBO_blur4, texture_helper4, FBO_helper4, 8);
			calculateBlurTexture(texture_blur4, texture_blur5, FBO_blur5, texture_helper5, FBO_helper5, 16);
			calculateBlurTexture(texture_blur5, texture_blur6, FBO_blur6, texture_helper6, FBO_helper6, 32);
		}

		function calculateBlurTexture(sourceTex, targetTex, targetFBO, helperTex, helperFBO, scale) {
			// copy source
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, sourceTex);
			renderAsTriangleStrip(targetFBO);

			// blur vertically
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_vertical);
			gl.uniform2f(gl.getUniformLocation(prog_blur_vertical, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, targetTex);
			renderAsTriangleStrip(helperFBO);

			// blur horizontally
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_horizontal);
			gl.uniform2f(gl.getUniformLocation(prog_blur_horizontal, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, helperTex);
			renderAsTriangleStrip(targetFBO);

		}

		function stepParticles() {
			gl.viewport(0, 0, particlesWidth, particlesHeight);
			gl.useProgram(prog_move_particles);
			setUniforms(prog_move_particles);

			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				renderAsTriangleStrip(FBO_particles2)
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				renderAsTriangleStrip(FBO_particles);
			}
		}

		function fluidSimulationStep() {
			addMouseMotion();
			advect();
			diffuse();
		}

		function addMouseMotion() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_add_mouse_motion);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			setUniforms(prog_fluid_add_mouse_motion);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "texSize"), (sizeX / simScale), (sizeY / simScale));
			renderAsTriangleStrip(FBO_fluid_backbuffer);
		}

		function advect() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_advect);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "texSize"), (sizeX / simScale), (sizeY / simScale));
			renderAsTriangleStrip(FBO_fluid_v);
		}

		function diffuse() {
			for (var i = 0; i < 8; i++) {
				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_backbuffer);

				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_p);
			}


			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_div);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "texSize"), (sizeX / simScale), (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_v"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_p"), 1);
			renderAsTriangleStrip(FBO_fluid_backbuffer);

			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			renderAsTriangleStrip(FBO_fluid_v);
		}

		// main texture feedback warp
		function advance() {
			gl.viewport(0, 0, sizeX, sizeY);
			gl.useProgram(prog_advance);
			setUniforms(prog_advance);
			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l); // interpolated input
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n); // "nearest" input
				renderAsTriangleStrip(FBO_main2);
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l); // interpolated
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n); // "nearest"
				renderAsTriangleStrip(FBO_main);
			}
			mainBufferToggle = -mainBufferToggle;
		}

		function composite() {
			gl.viewport(0, 0, viewX, viewY);
			gl.useProgram(prog_composite);
			setUniforms(prog_composite);
			if (mainBufferToggle < 0) {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n);
			} else {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n);
			}
			renderAsTriangleStrip(null);
		}

		var rainbowR, rainbowG, rainbowB, w = Math.PI * 2 / 3;

		function anim() {
			requestAnimationFrame(anim);

			updateStickMen();

			canvas2dContext.fillStyle = "#000";

			canvas2dContext.fillRect(0, 0, sizeX, sizeY);
			canvas2dContext.strokeStyle = "#FFF";
			//drawSpline(canvas2dContext, controls);
			drawStickMen(canvas2dContext);
			updateStickySceneTexture();

			canvas2dContext.fillStyle = "#000";
			canvas2dContext.fillRect(0, 0, sizeX, sizeY);

			canvas2dContext.lineWidth = 1.5;
			drawPoiToys(canvas2dContext);
			updatePoiToySceneTexture();

			canvas2dContext.fillStyle = "#F00";
			canvas2dContext.fillRect(0, 0, sizeX, sizeY);
			animatePointOnSpline(canvas2dContext);
			updateSplineSceneTexture();

			time = new Date().getTime() - starttime;

			var t = time / 150;

			rainbowR = 0.5 + 0.5 * Math.sin(t);
			rainbowG = 0.5 + 0.5 * Math.sin(t + w);
			rainbowB = 0.5 + 0.5 * Math.sin(t - w);

			if (oldMouseX != 0 && oldMouseY != 0) {
				mouseDx = (mouseX - oldMouseX) * viewX;
				mouseDy = (mouseY - oldMouseY) * viewY;
			}

			if (!halted) {

				if (useProjectionFeedback)
					renderParticles(FBO_particle_projection);

				if (useFluidSimulation)
					fluidSimulationStep();

				if (useParticles)
					stepParticles();

				advance();

				var srcTex = (mainBufferToggle < 0) ? texture_main2_l : texture_main_l;

				calculateBlurTextures(srcTex);

				frame++;
				framecount++;
			}

			if (renderParticlesOnly) {
				gl.viewport(0, 0, viewX, viewY);
				gl.useProgram(prog_copy);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_sticky_scene);
				renderAsTriangleStrip(null);
				renderParticles(null, false);
			}
			else {
				composite();
			}
			frames++;

			oldMouseX = mouseX;
			oldMouseY = mouseY;

		}

		function fr() { // updates every second
			document.getElementById("fps").textContent = frame;
			frame = 0; // reset the frame counter
		}

		var hidden = false;
		function hide() {
			hidden = !hidden;
			document.getElementById("desc").style.setProperty('visibility', hidden ? 'hidden' : 'visible');
		}

		function goFull(cb) {
			if (cb.checked) {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
			} else {
				viewX = sizeX;
				viewY = sizeY;
			}
			c.width = viewX;
			c.height = viewY;
			updateAspectRatio();
		}

		function switchRenderer(particlesOnly) {
			renderParticlesOnly = particlesOnly;
		}
	</script>
	<style type="text/css">
		body {
			background-color: #000000;
			color: #FFFFFF;
		}

		#c {
			position: absolute;
			top: 0;
			left: 0;
			z-index: -1;
		}

		a {
			color: #FFFFFF;
			font-weight: bold;
		}

		#desc {
			background-color: rgba(0, 0, 0, 0.2);
			width: 1024px;
		}
	</style>
</head>
<body onload="load()" ondblclick="hide()">
	<div id="desc">
		fps: <span id="fps"></span>
		<!--
				<form>
					<input type="radio" name="render"
						onclick="switchRenderer(false)" checked="checked">blur
					gradient composite</input>
					<br>
					<input type="radio" name="render"
						onclick="switchRenderer(true)">only particles</input>
					<br>

					<input
						type="checkbox" onclick="goFull(this)" checked="checked">doubleclick anywhere to hide this box. Press F11 for fullscreen.
						-->
		</form>
	</div>
	<canvas id="c"></canvas>
</body>
</html>