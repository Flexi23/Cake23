<html>
<head>
	<title>Turing pattern + particle projection feedback + blur gradient composite | WebGL GPGPU</title>
	<script src="@(Model.Host.URL)/Scripts/jquery-1.6.4.min.js"></script>
	<script src="@(Model.Host.URL)/Scripts/jquery.signalR-2.2.0.min.js"></script>
	<script src="@(Model.Host.URL)/signalr/hubs"></script>
	<script type="text/javascript">
		$(function () {
			$.connection.hub.url = "@(Model.Host.URL)/signalr"; var kinect = $.connection.kinect2Hub;

			kinect.client.onBody = function (bodyJson, projectionMappedPointsJson) {
				body = JSON.parse(bodyJson);
				// bodysampler = JSON.parse(projectionMappedPointsJson); // this would be the inbuilt mapping of the 3d coordinates to the 1080p video camera
				body.head = {
					x: (body.Joints["Head"].Position.X + body.Joints["Neck"].Position.X * 2) / 3,
					y: (body.Joints["Head"].Position.Y + body.Joints["Neck"].Position.Y * 2) / 3,
					z: (body.Joints["Head"].Position.Z + body.Joints["Neck"].Position.Z * 2) / 3
				};
				body.handRight = { "prevX": -1, "prevY": -1, "prevZ": -1, "grab": false, "point": false, "object": null };
				switch (body.handRight.state = body.HandRightState) {
					case 3:
						body.handRight.grab = true;
						break;
					case 4:
						body.handRight.point = true;
						break;
				}
				body.handRight.id = "hr" + body.TrackingId;
				//if (body.handRight.grab) {
				body.handRight.x = (body.Joints["HandTipRight"].Position.X * 2 + body.Joints["HandRight"].Position.X + body.Joints["ThumbRight"].Position.X * 2) / 5;
				body.handRight.y = (body.Joints["HandTipRight"].Position.Y * 2 + body.Joints["HandRight"].Position.Y + body.Joints["ThumbRight"].Position.Y * 2) / 5;
				body.handRight.z = (body.Joints["HandTipRight"].Position.Z * 2 + body.Joints["HandRight"].Position.Z + body.Joints["ThumbRight"].Position.Z * 2) / 5;
				//} else
				if (body.handRight.point) {
					body.handRight.x = body.Joints["HandTipRight"].Position.X;
					body.handRight.y = body.Joints["HandTipRight"].Position.Y;
					body.handRight.z = body.Joints["HandTipRight"].Position.Z;
				}
				body.handLeft = { "prevX": -1, "prevY": -1, "prevZ": -1, "grab": false, "point": false, "object": null };
				switch (body.handLeft.state = body.HandLeftState) {
					case 3:
						body.handLeft.grab = true;
						break;
					case 4:
						body.handLeft.point = true;
						break;
				}
				body.handLeft.id = "hl" + body.TrackingId;
				//if (body.handLeft.grab) {
				body.handLeft.x = (body.Joints["HandTipLeft"].Position.X * 2 + body.Joints["HandLeft"].Position.X + body.Joints["ThumbLeft"].Position.X * 2) / 5;
				body.handLeft.y = (body.Joints["HandTipLeft"].Position.Y * 2 + body.Joints["HandLeft"].Position.Y + body.Joints["ThumbLeft"].Position.Y * 2) / 5;
				body.handLeft.z = (body.Joints["HandTipLeft"].Position.Z * 2 + body.Joints["HandLeft"].Position.Z + body.Joints["ThumbLeft"].Position.Z * 2) / 5;
				//} else
				if (body.handLeft.point) {
					body.handLeft.x = body.Joints["HandTipLeft"].Position.X;
					body.handLeft.y = body.Joints["HandTipLeft"].Position.Y;
					body.handLeft.z = body.Joints["HandTipLeft"].Position.Z;
				}
				var trackingObject = getTrackingObject(body.TrackingId);
				if (trackingObject.body == null) {
					trackingObject.body = body;
				} else {
					var oldBody = trackingObject.body;
					body.handRight.prevX = oldBody.handRight.x;
					body.handRight.prevY = oldBody.handRight.y;
					body.handRight.prevZ = oldBody.handRight.z;
					body.handLeft.prevX = oldBody.handLeft.x;
					body.handLeft.prevY = oldBody.handLeft.y;
					body.handLeft.prevZ = oldBody.handLeft.z;
					if (oldBody.handRight.grab) {
						body.handRight.object = oldBody.handRight.object;
					}
					if (oldBody.handLeft.grab) {
						body.handLeft.object = oldBody.handLeft.object;
					}
				}
				trackingObject.body = body; // update
			};
			kinect.client.onBodies = function (trackingIdsJson, frame) {
				var trackingIds = null;
				if (trackingIdsJson != null) {
					trackingIds = JSON.parse(trackingIdsJson);
				}
				onBodies(trackingObjects, trackingIds, frame);
			};
			kinect.client.onFace = onFace;

			var midi = $.connection.midiHub;
			midi.client.onMidi = onMidi;

			$.connection.hub.start().done(function () {
			});

		});

		var trackingObjects = [], bodyFrameIndex;
		function getTrackingObject(id) {
			var hit = null;
			trackingObjects.forEach(function (trackingObject) { // perhaps not the most efficient way, but don't expect too many tracked bodies anyway
				if (trackingObject.id == id) {
					hit = trackingObject;
				}
			});
			if (hit) {
				return hit;
			}
			// create new trackingObject
			console.log("create tracking object " + id);
			var trackingObject = { id: id, body: null }; // init as object that can be easily extended with additional properties
			trackingObjects.push(trackingObject);
			return trackingObject;
		}

		// Kinect body frame arrived
		var activeTrackingObjects = [];
		function onBodies(trackingObjects, trackedBodyIds, frame) {
			bodyFrameIndex = frame;
			activeTrackingObjects = [];
			trackedBodyIds.forEach(function (id) {
				var trackingObject = getTrackingObject(id);
				activeTrackingObjects.push(trackingObject);
			});
		}

		var midi = [];
		function onMidi(channel, data1, data2) {
			//for now, just ignore the channel information
			midi[data1] = data2 / 127.;
			console.log("midi msg: channel " + channel + " , data: " + data1 + " => " + data2);
		}

		var faces = [];

		function onFace(verticesJSON, status, TrackingId) {
			var trackingObject = getTrackingObject(TrackingId);
			var before = Date.now();
			var vertices = JSON.parse(verticesJSON);
			var dur = Date.now() - before;
			var face = faces[TrackingId];
			if (face == undefined) {
				face = {
					points2d: []
				};
				for (var i = 0; i < 1347; i++) {
					face.points2d[i] = {};
				}
				faces[TrackingId] = face;
			}

			if (trackingObject.body) {
				var head = trackingObject.body.head;
				if (head) {
					var p2d = {};
					var p3d = {};
					var scale = 1.3;
					for (var i = 0; i < 1347; i++) {

						p3d.x = head.x + (vertices[i * 3 + 0] - head.x) * scale;
						p3d.y = head.y + (vertices[i * 3 + 1] - head.y) * scale;
						p3d.z = head.z + (vertices[i * 3 + 2] - head.z) * scale;

						project(p3d, p2d);

						var shape = face.points2d[i];

						shape.x = p2d.x;
						shape.y = p2d.y;

						if (shape.update) {
							shape.update();
						}
					}
				}
			}
			//console.log("face mesh deserialize and update time: " + dur);
		}

		function getMidi(id) {

			if (midi[id] == undefined)
				midi[id] = 0;

			return midi[id];
		}

		var joints = ["SpineBase", "SpineMid", "Neck", "Head", "ShoulderLeft",
			"ElbowLeft", "WristLeft", "HandLeft", "ShoulderRight", "ElbowRight",
			"WristRight", "HandRight", "HipLeft", "KneeLeft", "AnkleLeft",
			"FootLeft", "HipRight", "KneeRight", "AnkleRight", "FootRight",
			"SpineShoulder", "HandTipLeft", "ThumbLeft", "HandTipRight", "ThumbRight"];

		var members = [
//		["SpineBase", "SpineMid"],
//		["SpineMid", "SpineShoulder"],
			["SpineShoulder", "Neck"],
			["Neck", "Head"],
			["SpineShoulder", "ShoulderLeft"],
			["ShoulderLeft", "ElbowLeft"],
			["ElbowLeft", "WristLeft"],
			["WristLeft", "HandLeft"],
			["HandLeft", "HandTipLeft"],
			["HandLeft", "ThumbLeft"],
//		["SpineBase", "HipLeft"],
			["SpineBase", "KneeLeft"],
			["SpineBase", "KneeRight"],
//		["HipLeft", "ShoulderLeft"],
			["HipLeft", "KneeLeft"],
			["KneeLeft", "AnkleLeft"],
			["AnkleLeft", "FootLeft"],
			["SpineShoulder", "ShoulderRight"],
			["ShoulderRight", "ElbowRight"],
			["ElbowRight", "WristRight"],
			["WristRight", "HandRight"],
			["HandRight", "HandTipRight"],
			["HandRight", "ThumbRight"],
//		["SpineBase", "HipRight"],
//		["HipRight", "ShoulderRight"],
			["HipRight", "KneeRight"],
			["KneeRight", "AnkleRight"],
			["AnkleRight", "FootRight"],
			["SpineMid", "ShoulderRight"],
			["SpineMid", "ShoulderLeft"],
			["SpineMid", "HipRight"],
			["SpineMid", "HipLeft"]
		];

		// perspective projection (virtual camera 
		function project(p3d, p2d) {
			p2d.x = p3d.x;
			p2d.y = p3d.y;
			var w = Math.atan2(-p3d.x, -p3d.y);
			var l = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y);
			var d = 3.;
			var zoom = 3;
			var p = Math.tan(Math.PI / 2 + Math.atan2(d + p3d.z, l));
			d = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y + (p3d.z + d) * (p3d.z + d));
			p2d.x = zoom * Math.sin(w) * p / aspectx + 0.5;
			p2d.y = zoom * Math.cos(w) * p / aspecty + 0.5;
			p2d.y = 1 - p2d.y;
			p2d.x *= sizeX;
			p2d.y *= sizeY;
		}

		var Joint = function () {
			this.x = 0.5;
			this.y = 0.5;
			this.z = 1;
			this.state = 0;
			this.old = {};
			this.old.x = 0.5;
			this.old.y = 0.5;
			this.old.z = 1;
			this.old.state = 0;
			this.update = function (pos) {
				this.old.x = this.x;
				this.old.y = this.y;
				this.old.z = this.z;
				this.old.state = this.state;
				this.x = pos.x;
				this.y = pos.y;
				this.z = pos.z;
				this.state = pos.state;
			};
		};

		var Bone = function (joint1, joint2) {
			this.joint1 = joint1;
			this.joint2 = joint2;
		}

		var StickMan = function () {
			this.joints = [];
			this.bones = [];
			var self = this;
			joints.forEach(function (name) {
				self.joints[name] = new Joint();
			});
			members.forEach(function (member) {
				self.bones[member] = new Bone(self.joints[member[0]], self.joints[member[1]]);
			});
		};

		function updateStickMen() {
			activeTrackingObjects.forEach(function (trackingObject) {

				var stickMan = trackingObject.stickMan;
				if (stickMan == null) {
					stickMan = new StickMan();
					trackingObject.stickMan = stickMan;
				}

				joints.forEach(function (id) {
					stickMan.joints[id].update({
						x: trackingObject.body.Joints[id].Position.X,
						y: trackingObject.body.Joints[id].Position.Y,
						z: trackingObject.body.Joints[id].Position.Z,
						state: body.Joints[id].TrackingState
					});
				});
			});
		}

		function drawStickMen(context) {
			activeTrackingObjects.forEach(function (trackingObject) {

				var stickMan = trackingObject.stickMan;
				if (stickMan == null) {
					stickMan = new StickMan();
					trackingObject.stickMan = stickMan;
				}

				// draw the bones
				context.strokeStyle = "#FFF";
				context.beginPath();

				members.forEach(function (member) {
					var joint1 = stickMan.joints[member[0]];
					var joint2 = stickMan.joints[member[1]];
					if (joint1.state == 2 && joint2.state == 2) {
						var p1 = {};
						var p2 = {};
						project(joint1, p1);
						project(joint2, p2);
						context.moveTo(p1.x, p1.y);
						context.lineTo(p2.x, p2.y);
					}
				});

				context.stroke();

				// draw the hands

				var handLeft = {};
				var handRight = {};
				project(trackingObject.body.handLeft, handLeft);
				project(trackingObject.body.handRight, handRight);

				context.beginPath();
				context.strokeStyle = "#FFF";
				if (trackingObject.body.handLeft.grab) {
					context.strokeStyle = "#0F0";
				}
				context.rect(handLeft.x - 25, handLeft.y - 25, 50, 50);
				context.stroke();

				context.beginPath();
				context.strokeStyle = "#FFF";
				if (trackingObject.body.handRight.grab) {
					context.strokeStyle = "#0F0";
				}
				context.rect(handRight.x - 25, handRight.y - 25, 50, 50);
				context.stroke();

				/*
				joints.forEach(function (id) {
					var joint = stickMan.joints[id];
				});
				*/

				// draw the face
				context.fillStyle = "#FFF";
				var face = faces[trackingObject.id];
				if (face) {
					face.points2d.forEach(function (p) {
						context.fillRect(p.x, p.y, 1, 1);
					});
				}
			});
		}
	</script>
	<script id="shader-vs" type="x-shader/x-vertex"> 
	attribute vec3 aPos;
	attribute vec2 aTexCoord;
	varying   vec2 uv;
	varying vec2 uv_orig;
	void main(void) {
		 gl_Position = vec4(aPos, 1.);
		 uv = aTexCoord;
		 uv_orig = uv;
	}
	</script>

	<script id="shader-fs-inc" type="x-shader/x-fragment">
	#ifdef GL_ES
	precision mediump float;
	#endif

	varying vec2 uv;
	varying vec2 uv_orig;
		
	bool is_onscreen(vec2 uv){
		return (uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.);
	}

	float border(vec2 uv, float border, vec2 texSize){
		uv*=texSize;
		return (uv.x<border || uv.x>texSize.x-border || uv.y<border || uv.y >texSize.y-border) ? 1.:.0;
	}

	#define pi 3.141592653589793238462643383279
	#define pi_inv 0.318309886183790671537767526745
	#define pi2_inv 0.159154943091895335768883763372

	float border(vec2 domain, float thickness){
		 vec2 uv = fract(domain-vec2(0.5));
		 uv = min(uv,1.-uv)*2.;
		 return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);
	}

	float square_mask(vec2 domain){
		return (domain.x <= 1. && domain.x >= 0. && domain.y <= 1. && domain.y >= 0.) ? 1. : 0.; 
	}

	vec2 complex_mul(vec2 factorA, vec2 factorB){
		 return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);
	}

	vec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){
		vec2 uv = domain - center;
		float d = length(uv);
		return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;
	}

	vec2 complex_div(vec2 numerator, vec2 denominator){
		 return vec2( numerator.x*denominator.x + numerator.y*denominator.y,
									numerator.y*denominator.x - numerator.x*denominator.y)/
						vec2(denominator.x*denominator.x + denominator.y*denominator.y);
	}

	// HSL to RGB converter code from http://www.gamedev.net/topic/465948-hsl-shader-glsl-code/
	float Hue_2_RGB(float v1, float v2, float vH )
	{
		float ret;
		 if ( vH < 0.0 )
			 vH += 1.0;
		 if ( vH > 1.0 )
			 vH -= 1.0;
		 if ( ( 6.0 * vH ) < 1.0 )
			 ret = ( v1 + ( v2 - v1 ) * 6.0 * vH );
		 else if ( ( 2.0 * vH ) < 1.0 )
			 ret = ( v2 );
		 else if ( ( 3.0 * vH ) < 2.0 )
			 ret = ( v1 + ( v2 - v1 ) * ( ( 2.0 / 3.0 ) - vH ) * 6.0 );
		 else
			 ret = v1;
		 return ret;
	}

	vec3 hsl2rgb(float H, float S, float L){
		float var_2, var_1, R, G, B;	
		if (S == 0.0)
		{
			 R = L;
			 G = L;
			 B = L;
		}
		else
		{
			 if ( L < 0.5 )
			 {
				 var_2 = L * ( 1.0 + S );
			 }
			 else
			 {
				 var_2 = ( L + S ) - ( S * L );
			 }

			 var_1 = 2.0 * L - var_2;

			 R = Hue_2_RGB( var_1, var_2, H + ( 1.0 / 3.0 ) );
			 G = Hue_2_RGB( var_1, var_2, H );
			 B = Hue_2_RGB( var_1, var_2, H - ( 1.0 / 3.0 ) );
		}
		return vec3(R,G,B);
	}

	vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
		vec4 dX = 0.5*texture2D(sampler, uv + vec2(1.,0.)*d) - 0.5*texture2D(sampler, uv - vec2(1.,0.)*d);
		vec4 dY = 0.5*texture2D(sampler, uv + vec2(0.,1.)*d) - 0.5*texture2D(sampler, uv - vec2(0.,1.)*d);
		return vec2( dot(dX, selector), dot(dY, selector) );
	}

	vec2 rot90(vec2 vector){
		return vector.yx*vec2(1,-1);
	}

	float circle(vec2 uv, vec2 aspect, float scale){
		return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);
	}

	float sigmoid(float x) {
		return 2./(1. + exp2(-x)) - 1.;
	}

	float smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){
		return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;
	}

	</script>

	<script id="shader-fs-copy" type="x-shader/x-fragment"> 
	uniform sampler2D source;
	void main(void) {
		gl_FragColor = texture2D(source, uv);
	}
	</script>

	<script id="shader-fs-init" type="x-shader/x-fragment"> 
	void main(void){
		gl_FragColor = vec4(0.);
	}
	</script>

	<script id="shader-fs-move-particles" type="x-shader/x-fragment"> 
	uniform sampler2D sampler_prev;
	uniform sampler2D sampler_prev_n;
	uniform sampler2D sampler_blur;
	uniform sampler2D sampler_blur2;
	uniform sampler2D sampler_blur3;
	uniform sampler2D sampler_blur4;
	uniform sampler2D sampler_blur5;
	uniform sampler2D sampler_blur6;
	uniform sampler2D sampler_noise;
	uniform sampler2D sampler_noise_n;
	uniform sampler2D sampler_fluid;
	uniform sampler2D sampler_particles;

	uniform vec2 texSize;
	uniform vec2 pixelSize;
	uniform vec2 scale;
	uniform vec4 rnd;
	uniform float frame;
	uniform vec2 mouse;
	uniform vec2 mouseV;

	void main(void){
		vec4 p = texture2D(sampler_particles, uv); // residual location and velocity of the particle in the previous frame
		vec2 f = texture2D(sampler_fluid, p.xy).xz*pixelSize; // fluid simulation flow vector
		vec4 noise = texture2D(sampler_noise, p.xy)*2. - vec4(1.);

		// apply forces
		p.zw += gradient(sampler_blur6, p.xy, pixelSize*64., vec4(-1.,1.75,0.,0.))*pixelSize; // gradients from red and green
		p.zw = p.zw * max(0., 1.- (p.z*p.z + p.w*p.w)*32.); // (non-linear) friction

		p.xy += p.zw; // verlet integration

		vec2 oo = vec2(0);
		oo += gradient(sampler_prev, p.xy, pixelSize*1., vec4(-32.,0,0.,0.))*pixelSize; // move away from red, accurate
		oo += gradient(sampler_blur, p.xy, pixelSize*4., vec4(4.,0,0.,0.))*pixelSize; // move toward red, smooth
		oo += rot90(gradient(sampler_blur2, p.xy, pixelSize*8., vec4(-8.,0,0.,0.)))*pixelSize; // move orthogonal to the gradient

		p.xy += f+oo; // fluid + other offset

		/*
		float bounce = 0.999;

		if(p.x < 0.){
			p.x = 0.;
			p.z = abs(p.z)*bounce;
		}else if(p.x > 1.){
			p.x = 1.;
			p.z = -abs(p.z)*bounce;
		}

		if(p.y < 0.){
			p.y = 0.;
			p.w = abs(p.w)*bounce;
		}else if(p.y > 1.){
			p.y = 1.;
			p.w = -abs(p.w)*bounce;
		}

		gl_FragColor = p; // write back
	*/
		gl_FragColor.xy = fract(p.xy); // wrap

		gl_FragColor.zw = p.zw; 
	}
	</script>

	<script id="shader-fs-composite" type="x-shader/x-fragment"> 
	uniform sampler2D sampler_prev;
	uniform sampler2D sampler_prev_n;
	uniform sampler2D sampler_blur;
	uniform sampler2D sampler_blur2;
	uniform sampler2D sampler_blur3;
	uniform sampler2D sampler_blur4;
	uniform sampler2D sampler_blur5;
	uniform sampler2D sampler_blur6;
	uniform sampler2D sampler_noise;
	uniform sampler2D sampler_noise_n;
	uniform sampler2D sampler_fluid;
	uniform sampler2D sampler_fluid_p;
	uniform sampler2D sampler_particles;
	uniform sampler2D sampler_particle_projection;
	uniform sampler2D sampler_canvas2d;

	uniform vec4 rnd;
	uniform vec4 rainbow;
	uniform vec2 texSize;
	uniform vec2 pixelSize;
	uniform vec2 aspect;
	uniform vec2 mouse;
	uniform vec2 mouseV;
	uniform float fps;
	uniform float time;
	uniform float frame;

	float mouseFilter(vec2 uv){
		return clamp( 1.-length((uv-mouse)*texSize)/16., 0. , 1.);
	}
	void main(void) {
		vec2 uv_bg = uv	+(gradient(sampler_prev, uv, pixelSize*1.5, vec4(1,0,0,0))
						+ gradient(sampler_blur, uv, pixelSize*3., vec4(-2,0,0,0)))*pixelSize*512.;

		gl_FragColor = mix(vec4(0), vec4(0.8,0.7,1,0), texture2D(sampler_blur, uv_bg).g);

		vec2 uv_turing = uv + gradient(sampler_prev, uv, pixelSize*1., vec4(0.7,-1,0,0))*pixelSize*16.;
		gl_FragColor = mix(gl_FragColor, vec4(7./256.), pow(texture2D(sampler_prev, uv_turing).r,0.5));

		vec2 uv_particles = uv + gradient(sampler_blur, uv, pixelSize*2., vec4(1,-1,0,0))*pixelSize*4.*0.;
		uv_particles += gradient(sampler_blur2, uv, pixelSize*4., vec4(0,-1,0,0))*pixelSize*128.;

		gl_FragColor = mix(gl_FragColor, vec4(7./8.), texture2D(sampler_particle_projection, uv_particles)*0.25);

	//	gl_FragColor = texture2D(sampler_prev, uv); // bypass
	
		gl_FragColor = mix(gl_FragColor, vec4(1), texture2D(sampler_canvas2d, uv));

		gl_FragColor.a = 1.;
	}
	</script>
	<script id="shader-fs-advance" type="x-shader/x-fragment"> 
	uniform sampler2D sampler_prev;
	uniform sampler2D sampler_prev_n;
	uniform sampler2D sampler_blur;
	uniform sampler2D sampler_blur2;
	uniform sampler2D sampler_blur3;
	uniform sampler2D sampler_blur4;
	uniform sampler2D sampler_blur5;
	uniform sampler2D sampler_blur6;
	uniform sampler2D sampler_noise;
	uniform sampler2D sampler_noise_n;
	uniform sampler2D sampler_fluid;
	uniform sampler2D sampler_particles;
	uniform sampler2D sampler_particle_projection;

	uniform vec4 rnd;
	uniform vec4 rainbow;
	uniform vec2 pixelSize;
	uniform vec2 aspect;
	uniform vec2 mouse;
	uniform vec2 mouseV;
	uniform float fps;
	uniform float time;
	uniform float frame;

	void main(void) {
		float noise = texture2D(sampler_noise, uv + rnd.zw).x*0.5-0.25;
		vec2 f = texture2D(sampler_fluid, uv).xz*pixelSize;

		gl_FragColor = vec4(0.);

		//starting from a simple Turing pattern in red

		float centerFilter = smoothcircle(uv, aspect, 0.25, 128.);
		float zoom = 1.;// 0.999;
		float w = 0.;
		vec2 w2 = vec2(cos(w),sin(w));
		vec2 c = vec2(0.5);
		vec2 uvr = c + complex_mul((uv - c)*zoom, w2) + noise*pixelSize*0. - f;
		uvr +=  gradient(sampler_blur5, uv, pixelSize*64., vec4(0.,6.2,0.,0.))*pixelSize;
	//	uvr +=  rot90(gradient(sampler_blur5, uv, pixelSize*32., vec4(0.,4.,0.,0.)))*pixelSize;
		uvr +=  gradient(sampler_blur2, uv, pixelSize*4., vec4(-2.,0.,0.,0.))*pixelSize;
	//	uvr +=  rot90(gradient(sampler_blur, uv, pixelSize*4., vec4(1.,0.,0.,0.)))*pixelSize;
		gl_FragColor.r = texture2D(sampler_prev, uvr).r;
		gl_FragColor.r += (texture2D(sampler_blur2, uv).r - texture2D(sampler_blur4, uvr).r)*20./256. + 1./256. + noise*0./256.;

		// then there's the particle projection that's added to the green

		gl_FragColor.g = texture2D(sampler_blur2, uv).g *240./256.;
		gl_FragColor.g = mix(gl_FragColor.g, texture2D(sampler_particle_projection, uv).g, 16./256.);


		gl_FragColor = clamp(gl_FragColor, 0., 1.);
		gl_FragColor.a = 1.;
	}
	</script>

	<script id="shader-fs-blur-horizontal" type="x-shader/x-fragment">
	// original shader from http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
	// horizontal blur fragment shader
	uniform sampler2D src_tex;
	uniform vec2 pixelSize;

	void main(void) // fragment
	{
		float h = pixelSize.x;
		vec4 sum = vec4(0.0);
		sum += texture2D(src_tex, vec2(uv.x - 4.0*h, uv.y) ) * 0.05;
		sum += texture2D(src_tex, vec2(uv.x - 3.0*h, uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x - 2.0*h, uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x - 1.0*h, uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x + 0.0*h, uv.y) ) * 0.16;
		sum += texture2D(src_tex, vec2(uv.x + 1.0*h, uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x + 2.0*h, uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x + 3.0*h, uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x + 4.0*h, uv.y) ) * 0.05;
		gl_FragColor.xyz = sum.xyz/0.98; // normalize
		gl_FragColor.a = 1.;
	} 
	</script>

	<script id="shader-fs-blur-vertical" type="x-shader/x-fragment">
	uniform sampler2D src_tex;
	uniform vec2 pixelSize;

	void main(void) // fragment
	{
		float v = pixelSize.y;
		vec4 sum = vec4(0.0);
		sum += texture2D(src_tex, vec2(uv.x, - 4.0*v + uv.y) ) * 0.05;
		sum += texture2D(src_tex, vec2(uv.x, - 3.0*v + uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x, - 2.0*v + uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x, - 1.0*v + uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x, + 0.0*v + uv.y) ) * 0.16;
		sum += texture2D(src_tex, vec2(uv.x, + 1.0*v + uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x, + 2.0*v + uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x, + 3.0*v + uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x, + 4.0*v + uv.y) ) * 0.05;
			gl_FragColor.xyz = sum.xyz/0.98;
		gl_FragColor.a = 1.;
	}
	</script>

	<script id="shader-fs-add-mouse-motion" type="x-shader/x-fragment"> 
	uniform sampler2D sampler_fluid;

	uniform vec2 aspect;
	uniform vec2 mouse; // mouse coordinate
	uniform vec2 mouseV; // mouse velocity
	uniform vec2 pixelSize;
	uniform vec2 texSize;

	float mouseFilter(vec2 uv){
		return clamp( 1.-length((uv-mouse)*texSize)/2., 0. , 1.);
	}

	void main(void){
		vec2 v = texture2D(sampler_fluid, uv).xz;

		if(length(mouseV) > 0.)
			v = mix(v, mouseV*2., mouseFilter(uv)*0.85);

		gl_FragColor.xz = v;
	}
	</script>

	<script id="shader-fs-advect" type="x-shader/x-fragment"> 
	uniform vec2 texSize;
	uniform vec2 pixelSize;

	uniform sampler2D sampler_fluid;

	const float dt = .0005;

	void main(void){
		vec2 v = texture2D(sampler_fluid, uv).xz;

		vec2 D = -texSize*vec2(v.x, v.y)*dt;

		 vec2 Df = floor(D),   Dd = D - Df;
		 vec2 uv = uv + Df*pixelSize;

		vec2 uv0, uv1, uv2, uv3;

		uv0 = uv + pixelSize*vec2(0.,0.);
		uv1 = uv + pixelSize*vec2(1.,0.);
		uv2 = uv + pixelSize*vec2(0.,1.);
		uv3 = uv + pixelSize*vec2(1.,1.);

		vec2 v0 = texture2D(sampler_fluid, uv0).xz;
		vec2 v1 = texture2D(sampler_fluid, uv1).xz;
		vec2 v2 = texture2D(sampler_fluid, uv2).xz;
		vec2 v3 = texture2D(sampler_fluid, uv3).xz;

		v = mix( mix( v0, v1, Dd.x), mix( v2, v3, Dd.x), Dd.y);

		gl_FragColor.xz = v*(1.-border(uv, 1., texSize));
	}

	</script>

	<script id="shader-fs-p" type="x-shader/x-fragment"> 
	uniform vec2 pixelSize;
	uniform vec2 texSize;
	uniform sampler2D sampler_v;
	uniform sampler2D sampler_p;
	const float h = 1./1024.;

	void main(void){

		vec2 v = texture2D(sampler_v, uv).xz;
		float v_x = texture2D(sampler_v, uv - vec2(1.,0.)*pixelSize).r;
		float v_y = texture2D(sampler_v, uv - vec2(0.,1.)*pixelSize).b;

		float n = texture2D(sampler_p, uv- pixelSize*vec2(0.,1.)).r;
		float w = texture2D(sampler_p, uv + pixelSize*vec2(1.,0.)).r;
		float s = texture2D(sampler_p, uv + pixelSize*vec2(0.,1.)).r;
		float e = texture2D(sampler_p, uv - pixelSize*vec2(1.,0.)).r;

		float p = ( n + w + s + e - (v.x - v_x + v.y - v_y)*h ) * .25;

		gl_FragColor.r = p;
		gl_FragColor.ba = vec2(0.); // unused
	}
	</script>

	<script id="shader-fs-div" type="x-shader/x-fragment"> 
	uniform vec2 texSize;
	uniform vec2 pixelSize;
	uniform sampler2D sampler_v;
	uniform sampler2D sampler_p;

	void main(void){
		float p = texture2D(sampler_p, uv).r;
		vec2 v = texture2D(sampler_v, uv).xz;
		float p_x = texture2D(sampler_p, uv + vec2(1.,0.)*pixelSize).r;
		float p_y = texture2D(sampler_p, uv + vec2(0.,1.)*pixelSize).r;

		v -= (vec2(p_x, p_y)-p)*512.;

		gl_FragColor.xz = v;
	}
	</script>

	<script type="x-shader/x-vertex" id="shader-particle-renderer-vs"> 
	attribute vec2 uv; // particle position lookup vector
	uniform sampler2D sampler_prev;
	uniform sampler2D sampler_blur;
	uniform sampler2D sampler_particles; // particle positions in a float texture
	uniform vec2 mouse;
	uniform vec2 pixelSize;
			
	vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
		vec4 dX = 0.5*texture2D(sampler, uv + vec2(1.,0.)*d) - 0.5*texture2D(sampler, uv - vec2(1.,0.)*d);
		vec4 dY = 0.5*texture2D(sampler, uv + vec2(0.,1.)*d) - 0.5*texture2D(sampler, uv - vec2(0.,1.)*d);
		return vec2( dot(dX, selector), dot(dY, selector) );
	}

	void main() {
		gl_Position = (texture2D(sampler_particles, uv) - 0.5)*2.; // pass em flat
		gl_Position.xy += gradient(sampler_blur, gl_Position.xy*0.5+0.5, pixelSize*3., vec4(1,-0.,0,0))*pixelSize*32.;

		gl_Position.zw = vec2(0,1);
		gl_PointSize = 1.;	
	}
	</script>
	<script type="x-shader/x-fragment" id="shader-particle-renderer-fs"> 
	void main() {
		gl_FragColor = vec4(1.0, 0.5, 0.166, 0.33);
	}
	</script>

	<script type="text/javascript">
		function getShader(gl, id) {
			var shaderScript = document.getElementById(id);
			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					str += k.textContent;
				k = k.nextSibling;
			}

			var fsIncScript = document.getElementById("shader-fs-inc");
			var incStr = "";
			k = fsIncScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					incStr += k.textContent;
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				str = incStr + str;
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex")
				shader = gl.createShader(gl.VERTEX_SHADER);
			else
				return null;
			gl.shaderSource(shader, str);
			gl.compileShader(shader);
			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
				alert("error compiling shader '" + id + "'\n\n" + gl.getShaderInfoLog(shader));
			return shader;
		}

		window.requestAnimFrame = (function () {
			return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame
					|| window.msRequestAnimationFrame || function (callback) {
						window.setTimeout(callback, 1000 / desiredFramerate);
					};
		})();

		var gl;
		var ext;

		var prog_copy;
		var prog_advance;
		var prog_composite;
		var prog_blur_horizontal;
		var prog_blur_vertical;
		var prog_fluid_init;
		var prog_fluid_add_mouse_motion;
		var prog_fluid_advect;
		var prog_fluid_p;
		var prog_fluid_div;
		var prog_move_particles;
		var prog_render_particles;
		
		var FBO_main;
		var FBO_main2;
		var FBO_noise;
		var FBO_blur;
		var FBO_blur2;
		var FBO_blur3;
		var FBO_blur4;
		var FBO_blur5;
		var FBO_blur6;
		var FBO_helper;
		var FBO_helper2;
		var FBO_helper3;
		var FBO_helper4;
		var FBO_helper5;
		var FBO_helper6;
		var FBO_fluid_v;
		var FBO_fluid_p;
		var FBO_fluid_store;
		var FBO_fluid_backbuffer;
		var FBO_particles; // particle positions in a texture
		var FBO_particles2; // double buffer
		var FBO_particle_projection; // particle render target for projection feedback effects
		var FBO_canvas2d; // we will copy a 2d drawn scene to a webgl texture using this, or not

		var texture_main_n; // main, nearest pixel
		var texture_main_l; // main, linear interpolated access on the same buffer
		var texture_main2_n; // main double buffer, nearest
		var texture_main2_l; // main double buffer, linear
		var texture_blur; // full resolution blur result
		var texture_blur2; // double blur
		var texture_blur3; // quad blur
		var texture_blur4; // use low resolutions wisely ;)
		var texture_blur5;
		var texture_blur6;
		var texture_helper; // needed for multi-pass shader programs (2-pass Gaussian blur)
		var texture_helper2; // (1/4 resolution )
		var texture_helper3; // (1/16 resolution )
		var texture_helper4; // (1/256 resolution )
		var texture_helper5;
		var texture_helper6;
		var texture_noise_n; // nearest pixel access
		var texture_noise_l; // linear interpolated
		var texture_fluid_v; // velocities
		var texture_fluid_p; // pressure
		var texture_fluid_store;
		var texture_fluid_backbuffer;
		var texture_particles;
		var texture_particles2;
		var texture_particle_projection;
		var texture_canvas2d;

		// main texture loop dimensions
		var sizeX = 1024; // must be powers of 2
		var sizeY = 512;
		var viewX = sizeX; // viewport size (ideally exactly the texture size)
		var viewY = sizeY;

		// particle positions will be stored in a texture of that size
		var particlesWidth = 1024;
		var particlesHeight = 512;
		var particleCount = particlesWidth * particlesHeight; // can also be set to lower than particlesWidth * particlesHeight

		var useParticles = true;
		var useProjectionFeedback = true; // rendering half a million points can slow things down significantly, don't render to texture if not needed
		var useFluidSimulation = true; // the textures will be initialized anyway
		var simScale = 8; // for better performance, the fluid simulation will be calculated for cells this times bigger than the main texture's pixels (powers of 2)

		var desiredFramerate = 100; // more like a limit
		var startFullpage = true;
		var renderParticlesOnly = false;

		// don't change vars below
		var canvas2d;
		var canvas2dContext;

		var frame = 0; // frame counter to be resetted every 1000ms
		var framecount = 0; // not resetted
		var mainBufferToggle = 1;
		var halted = false;
		var fps, fpsDisplayUpdateTimer;
		var time, starttime = new Date().getTime();

		var mouseX = 0.5;
		var mouseY = 0.5;
		var oldMouseX = 0;
		var oldMouseY = 0;
		var mouseDx = 0;
		var mouseDy = 0;

		var aspectx = 2;
		var aspecty = 1;

		// geometry
		var particleBuffer, squareBuffer, hLineBuffer, vLineBuffer;

		function load() {
			clearInterval(fpsDisplayUpdateTimer);
			canvas2d = document.createElement("canvas");
			canvas2d.width = sizeX;
			canvas2d.height = sizeY;
			canvas2dContext = canvas2d.getContext("2d");
			var c = document.getElementById("c");
			try {
				gl = c.getContext("experimental-webgl", {
					depth: false
				});
			} catch (e) {
			}
			if (!gl) {
				alert("Meh! Y u no support experimental WebGL !?!");
				return;
			}

			["OES_texture_float", "OES_standard_derivatives", "OES_texture_float_linear"].forEach(function (name) {
				console.log("check " + name);
				try {
					ext = gl.getExtension(name);
				} catch (e) {
					alert(e);
				}
				if (!ext) {
					alert("Meh! Y u no support " + name + " !?!\n(Chrome 29 or Firefox 24 will do fine)");
					return;
				}
				ext = false;
			});

			if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0) {
				alert("Meh! Y u no support vertex shader textures !?!");
				return;
			}

			document.onmousemove = function (evt) {
				mouseX = evt.pageX / viewX;
				mouseY = 1 - evt.pageY / viewY;
			};

			if (startFullpage) {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
			}

			c.width = viewX;
			c.height = viewY;

			prog_copy = createAndLinkProgram("shader-fs-copy");
			prog_advance = createAndLinkProgram("shader-fs-advance");
			prog_composite = createAndLinkProgram("shader-fs-composite");
			prog_blur_horizontal = createAndLinkProgram("shader-fs-blur-horizontal");
			prog_blur_vertical = createAndLinkProgram("shader-fs-blur-vertical");
			prog_fluid_init = createAndLinkProgram("shader-fs-init");
			prog_fluid_add_mouse_motion = createAndLinkProgram("shader-fs-add-mouse-motion");
			prog_fluid_advect = createAndLinkProgram("shader-fs-advect");
			prog_fluid_p = createAndLinkProgram("shader-fs-p");
			prog_fluid_div = createAndLinkProgram("shader-fs-div");
			prog_move_particles = createAndLinkProgram("shader-fs-move-particles");

			triangleStripGeometry = {
				vertices: new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]),
				texCoords: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
				vertexSize: 3,
				vertexCount: 4,
				type: gl.TRIANGLE_STRIP
			};

			createTexturedGeometryBuffer(triangleStripGeometry);

			hLineVertices = [];
			hLineTexCoords = [];
			for (var y = 0; y < sizeY; y++) {
				hLineVertices.push(-1, -1 + 2 * y / sizeY, 0, 1, -1 + 2 * y / sizeY, 0);
				hLineTexCoords.push(0. / sizeX, (y - 0.5) / sizeY, (sizeX + 0.) / sizeX, (y - 0.5) / sizeY);
			}
			hLineGeometry = {
				vertices: new Float32Array(hLineVertices),
				texCoords: new Float32Array(hLineTexCoords),
				vertexSize: 3,
				vertexCount: sizeY * 2,
				type: gl.LINES
			};

			vLineVertices = [];
			vLineTexCoords = [];
			for (var x = 0; x < sizeX; x++) {
				vLineVertices.push(-1 + 2 * x / sizeX, -1, 0, -1 + 2 * x / sizeX, 1, 0);
				vLineTexCoords.push((x - 0.5) / sizeX, 0. / sizeY, (x - 0.5) / sizeX, (sizeY + 0.) / sizeY);
			}
			vLineGeometry = {
				vertices: new Float32Array(vLineVertices),
				texCoords: new Float32Array(vLineTexCoords),
				vertexSize: 3,
				vertexCount: sizeX * 2,
				type: gl.LINES
			};

			createTexturedGeometryBuffer(hLineGeometry);
			createTexturedGeometryBuffer(vLineGeometry);

			squareBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer);

			var aPosLoc = gl.getAttribLocation(prog_advance, "aPos");
			var aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");

			gl.enableVertexAttribArray(aPosLoc);
			gl.enableVertexAttribArray(aTexLoc);

			var verticesAndTexCoords = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1, // one square of a quad!
			0, 0, 1, 0, 0, 1, 1, 1] // hello texture, you be full
			);

			gl.bufferData(gl.ARRAY_BUFFER, verticesAndTexCoords, gl.STATIC_DRAW);
			gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 8, 0);
			gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 8, 32);

			var noisePixels = [], pixels = [], simpixels = [], pixels2 = [], pixels3 = [], pixels4 = [], pixels5 = [], pixels6 = [], particles = [], particlesIdx = [];
			var dX = 1 / particlesWidth;
			var dY = 1 / particlesHeight;
			for (var j = 0; j < sizeY; j++) {
				for (var i = 0; i < sizeX; i++) {
					noisePixels.push(Math.random(), Math.random(), Math.random(), 1);
					pixels.push(0, 0, 0, 1);
					if (i < sizeX / simScale && j < sizeY / simScale)
						simpixels.push(0, 0, 0, 1);
					if (i < sizeX / 2 && j < sizeY / 2)
						pixels2.push(0, 0, 0, 1);
					if (i < sizeX / 4 && j < sizeY / 4)
						pixels3.push(0, 0, 0, 1);
					if (i < sizeX / 8 && j < sizeY / 8)
						pixels4.push(0, 0, 0, 1);
					if (i < sizeX / 16 && j < sizeY / 16)
						pixels5.push(0, 0, 0, 1);
					if (i < sizeX / 32 && j < sizeY / 32)
						pixels6.push(0, 0, 0, 1);
					if (i < particlesWidth && j < particlesHeight) {
						particles.push(dX / 2 + i * dX, dY / 2 + j * dY, 0, 0); // initial particle positions, here: uniform distribution
					}
				}
			}

			for (var i = 0; i < particlesHeight; i++) {
				for (var j = 0; j < particlesWidth; j++) {
					particlesIdx.push(dX / 2 + j * dX, dY / 2 + i * dY); // coordinate lookup vectors (center of pixels)
				}
			}

			FBO_main = gl.createFramebuffer();
			FBO_main2 = gl.createFramebuffer();
			var glPixels;
			glPixels = new Float32Array(noisePixels);
			texture_main_n = createAndBindTexture(glPixels, 1, FBO_main, gl.NEAREST);
			texture_main2_n = createAndBindTexture(glPixels, 1, FBO_main2, gl.NEAREST);
			glPixels = new Float32Array(noisePixels);
			texture_main_l = createAndBindTexture(glPixels, 1, FBO_main, gl.LINEAR);
			texture_main2_l = createAndBindTexture(glPixels, 1, FBO_main2, gl.LINEAR);

			FBO_fluid_p = gl.createFramebuffer();
			FBO_fluid_v = gl.createFramebuffer();
			FBO_fluid_store = gl.createFramebuffer();
			FBO_fluid_backbuffer = gl.createFramebuffer();
			texture_fluid_v = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_v);
			texture_fluid_p = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_p);
			texture_fluid_store = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_store);
			texture_fluid_backbuffer = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_backbuffer);

			FBO_particle_projection = gl.createFramebuffer();
			texture_particle_projection = createAndBindTexture(new Float32Array(pixels), 1, FBO_particle_projection, gl.LINEAR);

			FBO_helper = gl.createFramebuffer();
			FBO_helper2 = gl.createFramebuffer();
			FBO_helper3 = gl.createFramebuffer();
			FBO_helper4 = gl.createFramebuffer();
			FBO_helper5 = gl.createFramebuffer();
			FBO_helper6 = gl.createFramebuffer();
			texture_helper = createAndBindTexture(new Float32Array(pixels), 1, FBO_helper, gl.NEAREST); // helper buffers for the two-pass Gaussian blur calculation basically
			texture_helper2 = createAndBindTexture(new Float32Array(pixels2), 2, FBO_helper2, gl.NEAREST);
			texture_helper3 = createAndBindTexture(new Float32Array(pixels3), 4, FBO_helper3, gl.NEAREST);
			texture_helper4 = createAndBindTexture(new Float32Array(pixels4), 8, FBO_helper4, gl.NEAREST);
			texture_helper5 = createAndBindTexture(new Float32Array(pixels5), 16, FBO_helper5, gl.NEAREST);
			texture_helper6 = createAndBindTexture(new Float32Array(pixels6), 32, FBO_helper6, gl.NEAREST);

			FBO_blur = gl.createFramebuffer();
			FBO_blur2 = gl.createFramebuffer();
			FBO_blur3 = gl.createFramebuffer();
			FBO_blur4 = gl.createFramebuffer();
			FBO_blur5 = gl.createFramebuffer();
			FBO_blur6 = gl.createFramebuffer();
			texture_blur = createAndBindTexture(new Float32Array(pixels), 1, FBO_blur, gl.LINEAR);
			texture_blur2 = createAndBindTexture(new Float32Array(pixels2), 2, FBO_blur2, gl.LINEAR);
			texture_blur3 = createAndBindTexture(new Float32Array(pixels3), 4, FBO_blur3, gl.LINEAR);
			texture_blur4 = createAndBindTexture(new Float32Array(pixels4), 8, FBO_blur4, gl.LINEAR);
			texture_blur5 = createAndBindTexture(new Float32Array(pixels5), 16, FBO_blur5, gl.LINEAR);
			texture_blur6 = createAndBindTexture(new Float32Array(pixels6), 32, FBO_blur6, gl.LINEAR);

			FBO_canvas2d = gl.createFramebuffer();
			texture_canvas2d = createAndBindTexture(new Float32Array(pixels), 1, FBO_canvas2d, gl.NEAREST);

			FBO_noise = gl.createFramebuffer();
			glPixels = new Float32Array(noisePixels);
			texture_noise_n = createAndBindTexture(glPixels, 1, FBO_noise, gl.NEAREST);
			texture_noise_l = createAndBindTexture(glPixels, 1, FBO_noise, gl.LINEAR);

			FBO_particles = gl.createFramebuffer();
			texture_particles = createAndBindParticleTexture(new Float32Array(particles), FBO_particles);

			FBO_particles2 = gl.createFramebuffer();
			texture_particles2 = createAndBindParticleTexture(new Float32Array(particles), FBO_particles2);

			// lesson learned: the (frame) buffer location that we pass to the vertex shader has to be bound to the program before linking!

			var aParticleLoc = 2; // no getAttributeLoc
			prog_render_particles = createAndLinkParticleRenderer(aParticleLoc);

			gl.useProgram(prog_render_particles);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 0);

			gl.enableVertexAttribArray(aParticleLoc);
			particleBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particlesIdx), gl.STATIC_DRAW);
			gl.vertexAttribPointer(aParticleLoc, 2, gl.FLOAT, false, 0, 0);

			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur);
			gl.activeTexture(gl.TEXTURE3);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur2);
			gl.activeTexture(gl.TEXTURE4);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur3);
			gl.activeTexture(gl.TEXTURE5);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur4);
			gl.activeTexture(gl.TEXTURE6);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur5);
			gl.activeTexture(gl.TEXTURE7);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur6);
			gl.activeTexture(gl.TEXTURE8);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_l);
			gl.activeTexture(gl.TEXTURE9);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_n);
			gl.activeTexture(gl.TEXTURE10);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE11);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.activeTexture(gl.TEXTURE12);
			gl.bindTexture(gl.TEXTURE_2D, texture_particles); // to be swapped anyways
			gl.activeTexture(gl.TEXTURE13);
			gl.bindTexture(gl.TEXTURE_2D, texture_particle_projection);
			gl.activeTexture(gl.TEXTURE14);
			gl.bindTexture(gl.TEXTURE_2D, texture_canvas2d);

			calculateBlurTexture();

			fluidInit(FBO_fluid_v);
			fluidInit(FBO_fluid_p);
			fluidInit(FBO_fluid_store);
			fluidInit(FBO_fluid_backbuffer);

			fpsDisplayUpdateTimer = setInterval(fr, 1000);
			time = new Date().getTime() - starttime;

			gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			gl.clearColor(0, 0, 0, 1);

			anim();
		}

		function createTexturedGeometryBuffer(geometry) {
			geometry.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			geometry.aPosLoc = gl.getAttribLocation(prog_advance, "aPos"); // we could take any program here, they all use the same vertex shader
			gl.enableVertexAttribArray(geometry.aPosLoc);
			geometry.aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");
			gl.enableVertexAttribArray(geometry.aTexLoc);
			geometry.texCoordOffset = geometry.vertices.byteLength;
			gl.bufferData(gl.ARRAY_BUFFER, geometry.texCoordOffset + geometry.texCoords.byteLength, gl.STATIC_DRAW);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, geometry.vertices);
			gl.bufferSubData(gl.ARRAY_BUFFER, geometry.texCoordOffset, geometry.texCoords);
			setGeometryVertexAttribPointers(geometry);
		}

		function setGeometryVertexAttribPointers(geometry) {
			gl.vertexAttribPointer(geometry.aPosLoc, geometry.vertexSize, gl.FLOAT, gl.FALSE, 0, 0);
			gl.vertexAttribPointer(geometry.aTexLoc, 2, gl.FLOAT, gl.FALSE, 0, geometry.texCoordOffset);
		}

		function createAndLinkProgram(fsId) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-vs"));
			gl.attachShader(program, getShader(gl, fsId));
			gl.linkProgram(program);
			return program;
		}

		function createAndLinkParticleRenderer(aParticleLoc) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-vs"));
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-fs"));
			gl.bindAttribLocation(program, aParticleLoc, "uv"); // can't use getAttribLocation later so we must bind before linking
			gl.linkProgram(program);
			return program;
		}

		function createAndBindTexture(glPixels, scale, fbo, filter) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / scale, sizeY / scale, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindParticleTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, particlesWidth, particlesHeight, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindSimulationTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / simScale, sizeY / simScale, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function fluidInit(fbo) {
			gl.viewport(0, 0, sizeX / simScale, sizeY / simScale);
			gl.useProgram(prog_fluid_init);
			renderAsTriangleStrip(fbo);
		}

		function setUniforms(program) {
			gl.uniform4f(gl.getUniformLocation(program, "rnd"), Math.random(), Math.random(), Math.random(), Math.random());
			gl.uniform4f(gl.getUniformLocation(program, "rainbow"), rainbowR, rainbowG, rainbowB, 1);
			gl.uniform2f(gl.getUniformLocation(program, "texSize"), sizeX, sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(program, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(program, "mouseV"), mouseDx, mouseDy);
			gl.uniform1f(gl.getUniformLocation(program, "fps"), fps);
			gl.uniform1f(gl.getUniformLocation(program, "time"), time);
			gl.uniform1f(gl.getUniformLocation(program, "frame"), framecount);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur"), 2);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur2"), 3);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur3"), 4);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur4"), 5);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur5"), 6);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur6"), 7);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise"), 8);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise_n"), 9);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid"), 10);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid_p"), 11);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particles"), 12);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particle_projection"), 13);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_canvas2d"), 14);
		}

		function useGeometry(geometry) {
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			setGeometryVertexAttribPointers(geometry);
		}

		function renderGeometry(geometry, targetFBO) {
			useGeometry(geometry);
			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.drawArrays(geometry.type, 0, geometry.vertexCount);
			gl.flush();
		}

		function renderAsTriangleStrip(targetFBO) {
			renderGeometry(triangleStripGeometry, targetFBO);
		}

		function renderParticles(targetFBO) {
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);

			if (targetFBO == null)
				gl.viewport(0, 0, viewX, viewY);
			else
				gl.viewport(0, 0, sizeX, sizeY);

			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.useProgram(prog_render_particles);

			gl.activeTexture(gl.TEXTURE12);
			if (mainBufferToggle < 0) {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
			} else {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
			}

			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 12); // input for the vertex shader
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_blur"), 2);

			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			gl.enable(gl.BLEND);
			gl.drawArrays(gl.POINTS, 0, particleCount);
			gl.disable(gl.BLEND);

			gl.flush();
		}

		function updateCanvas2dTexture() {
			gl.activeTexture(gl.TEXTURE14);
			gl.bindTexture(gl.TEXTURE_2D, texture_canvas2d);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2d);
			gl.bindTexture(gl.TEXTURE_2D, texture_canvas2d);
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_canvas2d);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_canvas2d, 0);
		}

		function calculateBlurTextures(texture_source) {
			calculateBlurTexture(texture_source, texture_blur, FBO_blur, texture_helper, FBO_helper, 1);
			calculateBlurTexture(texture_blur, texture_blur2, FBO_blur2, texture_helper2, FBO_helper2, 2);
			calculateBlurTexture(texture_blur2, texture_blur3, FBO_blur3, texture_helper3, FBO_helper3, 4);
			calculateBlurTexture(texture_blur3, texture_blur4, FBO_blur4, texture_helper4, FBO_helper4, 8);
			calculateBlurTexture(texture_blur4, texture_blur5, FBO_blur5, texture_helper5, FBO_helper5, 16);
			calculateBlurTexture(texture_blur5, texture_blur6, FBO_blur6, texture_helper6, FBO_helper6, 32);
		}

		function calculateBlurTexture(sourceTex, targetTex, targetFBO, helperTex, helperFBO, scale) {
			// copy source
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, sourceTex);
			renderAsTriangleStrip(targetFBO);

			// blur vertically
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_vertical);
			gl.uniform2f(gl.getUniformLocation(prog_blur_vertical, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, targetTex);
			renderAsTriangleStrip(helperFBO);

			// blur horizontally
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_horizontal);
			gl.uniform2f(gl.getUniformLocation(prog_blur_horizontal, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, helperTex);
			renderAsTriangleStrip(targetFBO);

		}

		function stepParticles() {
			gl.viewport(0, 0, particlesWidth, particlesHeight);
			gl.useProgram(prog_move_particles);
			gl.uniform4f(gl.getUniformLocation(prog_move_particles, "rnd"), Math.random(), Math.random(), Math.random(), Math.random());
			gl.uniform1f(gl.getUniformLocation(prog_move_particles, "frame"), framecount);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "texSize"), sizeX, sizeY);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "mouseV"), mouseDx, mouseDy);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "scale"), 2. / simScale / particlesWidth, 2. / simScale / particlesHeight);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur"), 2);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur2"), 3);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur3"), 4);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur4"), 5);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur5"), 6);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur6"), 7);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_noise"), 8);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_noise_n"), 9);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_fluid"), 10);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_fluid_p"), 11);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_particles"), 12);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_particle_projection"), 13);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_canvas2d"), 14);
			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				renderAsTriangleStrip(FBO_particles2)
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				renderAsTriangleStrip(FBO_particles);
			}
		}

		function fluidSimulationStep() {
			addMouseMotion();
			advect();
			diffuse();
		}

		function addMouseMotion() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_add_mouse_motion);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mouseV"), mouseDx, mouseDy);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "texSize"), (sizeX / simScale), (sizeY / simScale));
			renderAsTriangleStrip(FBO_fluid_backbuffer);
		}

		function advect() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_advect);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "texSize"), (sizeX / simScale), (sizeY / simScale));
			renderAsTriangleStrip(FBO_fluid_v);
		}

		function diffuse() {
			for (var i = 0; i < 8; i++) {
				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_backbuffer);

				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_p);
			}


			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_div);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "texSize"), (sizeX / simScale), (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_v"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_p"), 1);
			renderAsTriangleStrip(FBO_fluid_backbuffer);

			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			renderAsTriangleStrip(FBO_fluid_v);
		}

		// main texture feedback warp
		function advance() {
			gl.viewport(0, 0, sizeX, sizeY);
			gl.useProgram(prog_advance);
			setUniforms(prog_advance);
			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l); // interpolated input
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n); // "nearest" input
				renderAsTriangleStrip(FBO_main2);
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l); // interpolated
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n); // "nearest"
				renderAsTriangleStrip(FBO_main);
			}
			mainBufferToggle = -mainBufferToggle;
		}

		function composite() {
			gl.viewport(0, 0, viewX, viewY);
			gl.useProgram(prog_composite);
			setUniforms(prog_composite);
			if (mainBufferToggle < 0) {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n);
			} else {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n);
			}
			renderAsTriangleStrip(null);
		}

		var rainbowR, rainbowG, rainbowB, w = Math.PI * 2 / 3;

		function anim() {
			setTimeout("requestAnimationFrame(anim)", 1000 / desiredFramerate);

			updateStickMen();

			canvas2dContext.clearRect(0, 0, sizeX, sizeY);

			drawStickMen(canvas2dContext);

			updateCanvas2dTexture();

			time = new Date().getTime() - starttime;

			var t = time / 150;

			rainbowR = 0.5 + 0.5 * Math.sin(t);
			rainbowG = 0.5 + 0.5 * Math.sin(t + w);
			rainbowB = 0.5 + 0.5 * Math.sin(t - w);

			x1 = 0.5;
			thickness = (2 - mouseY * 1.) / 0.025;
			y1 = 0.035;

			x2 = 0.5 + (mouseX - 0.5) * 0.25;
			y2 = 0.07 + mouseY * 0.14;
			w1 = (0.5 - mouseX) * 0.15;

			if (oldMouseX != 0 && oldMouseY != 0) {
				mouseDx = (mouseX - oldMouseX) * viewX;
				mouseDy = (mouseY - oldMouseY) * viewY;
			}

			if (!halted) {

				if (useProjectionFeedback)
					renderParticles(FBO_particle_projection);

				if (useFluidSimulation)
					fluidSimulationStep();

				if (useParticles)
					stepParticles();

				advance();

				var srcTex = (mainBufferToggle < 0) ? texture_main2_l : texture_main_l;

				calculateBlurTextures(srcTex);

				frame++;
				framecount++;
			}

			if (renderParticlesOnly)
				renderParticles(null);
			else
				composite();

			frames++;

			oldMouseX = mouseX;
			oldMouseY = mouseY;

		}

		function fr() { // updates every second
			document.getElementById("fps").textContent = frame;
			frame = 0; // reset the frame counter
		}

		var hidden = false;
		function hide() {
			hidden = !hidden;
			document.getElementById("desc").style.setProperty('visibility', hidden ? 'hidden' : 'visible');
		}

		function goFull(cb) {
			if (cb.checked) {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
			} else {
				viewX = sizeX;
				viewY = sizeY;
			}
			c.width = viewX;
			c.height = viewY;
		}

		function setDesiredFps(tb) {
			desiredFramerate = tb.value;
			if (desiredFramerate < 1)
				desiredFPS = 1;
		}

		function switchRenderer(particlesOnly) {
			renderParticlesOnly = particlesOnly;
		}
	</script>
	<style type="text/css">
		body {
			background-color: #000000;
			color: #FFFFFF;
		}

		#c {
			position: absolute;
			top: 0;
			left: 0;
			z-index: -1;
		}

		a {
			color: #FFFFFF;
			font-weight: bold;
		}

		#desc {
			background-color: rgba(0, 0, 0, 0.2);
			width: 1024;
		}
	</style>
</head>
<body onload="load()" ondblclick="hide()">
	<div id="desc">
		Post-processing variant forked from <a href="turing-fluid-particle-projection-feedback.html">turing-fluid-particle-projection-feedback.html</a>
		fps: <span id="fps"></span>
		<form>
			<!-- 
			limit fps <input type="text" name="desiredFPS" size="3" value="50"
				onKeyUp="setDesiredFps(this)"></input> 
		 -->
			<br>
			<input type="radio" name="render"
				onclick="switchRenderer(false)" checked="checked">blur
			gradient composite</input>
			<br>
			<input type="radio" name="render"
				onclick="switchRenderer(true)">only particles</input>
			<br>
			<input
				type="checkbox" onclick="goFull(this)" checked="checked">full
			</input>
		</form>
	</div>
	<canvas id="c"></canvas>
</body>
</html>
