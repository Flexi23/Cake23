
<html>
<head>
	<title>Reaction-Diffusion Aquarium | WebGL GPGPU</title>
	<script src="../Scripts/jquery-1.6.4.min.js"></script>
	<script src="../Scripts/jquery.signalR-2.2.0.min.js"></script>
	<script src="@(Model.Host.URL)/signalr/hubs"></script>
	<script type="text/javascript">
		$(function () {
			$.connection.hub.url = "@(Model.Host.URL)/signalr";
			var kinect = $.connection.kinect2Hub;

			kinect.client.onBody = function (bodyJson, projectionMappedPointsJson) {
				body = JSON.parse(bodyJson);
				//body.points2D = JSON.parse(projectionMappedPointsJson);
				body.head = {
					x: (body.Joints["Head"].Position.X + body.Joints["Neck"].Position.X * 2) / 3,
					y: (body.Joints["Head"].Position.Y + body.Joints["Neck"].Position.Y * 2) / 3,
					z: (body.Joints["Head"].Position.Z + body.Joints["Neck"].Position.Z * 2) / 3
				};
				body.handRight = { "prevX": -1, "prevY": -1, "prevZ": -1, "grab": false, "point": false, "object": null };
				switch (body.handRight.state = body.HandRightState) {
					case 3:
						body.handRight.grab = true;
						break;
					case 4:
						body.handRight.point = true;
						break;
				}
				body.handRight.id = "hr" + body.TrackingId;
				//if (body.handRight.grab) {
				body.handRight.x = (body.Joints["HandTipRight"].Position.X * 2 + body.Joints["HandRight"].Position.X + body.Joints["ThumbRight"].Position.X * 2) / 5;
				body.handRight.y = -(body.Joints["HandTipRight"].Position.Y * 2 + body.Joints["HandRight"].Position.Y + body.Joints["ThumbRight"].Position.Y * 2) / 5;
				body.handRight.z = (body.Joints["HandTipRight"].Position.Z * 2 + body.Joints["HandRight"].Position.Z + body.Joints["ThumbRight"].Position.Z * 2) / 5;
				//} else
				if (body.handRight.point) {
					body.handRight.x = body.Joints["HandTipRight"].Position.X;
					body.handRight.y = -body.Joints["HandTipRight"].Position.Y;
					body.handRight.z = body.Joints["HandTipRight"].Position.Z;
				}
				body.handLeft = { "prevX": -1, "prevY": -1, "prevZ": -1, "grab": false, "point": false, "object": null };
				switch (body.handLeft.state = body.HandLeftState) {
					case 3:
						body.handLeft.grab = true;
						break;
					case 4:
						body.handLeft.point = true;
						break;
				}
				body.handLeft.id = "hl" + body.TrackingId;
				//if (body.handLeft.grab) {
				body.handLeft.x = (body.Joints["HandTipLeft"].Position.X * 2 + body.Joints["HandLeft"].Position.X + body.Joints["ThumbLeft"].Position.X * 2) / 5;
				body.handLeft.y = -(body.Joints["HandTipLeft"].Position.Y * 2 + body.Joints["HandLeft"].Position.Y + body.Joints["ThumbLeft"].Position.Y * 2) / 5;
				body.handLeft.z = (body.Joints["HandTipLeft"].Position.Z * 2 + body.Joints["HandLeft"].Position.Z + body.Joints["ThumbLeft"].Position.Z * 2) / 5;
				//} else
				if (body.handLeft.point) {
					body.handLeft.x = body.Joints["HandTipLeft"].Position.X;
					body.handLeft.y = -body.Joints["HandTipLeft"].Position.Y;
					body.handLeft.z = body.Joints["HandTipLeft"].Position.Z;
				}
				var trackingObject = getTrackingObject(body.TrackingId);
				if (trackingObject.body == null) {
					trackingObject.body = body;
				} else {
					var oldBody = trackingObject.body;
					body.handRight.prevX = oldBody.handRight.x;
					body.handRight.prevY = oldBody.handRight.y;
					body.handRight.prevZ = oldBody.handRight.z;
					body.handLeft.prevX = oldBody.handLeft.x;
					body.handLeft.prevY = oldBody.handLeft.y;
					body.handLeft.prevZ = oldBody.handLeft.z;
					if (oldBody.handRight.grab) {
						body.handRight.object = oldBody.handRight.object;
					}
					if (oldBody.handLeft.grab) {
						body.handLeft.object = oldBody.handLeft.object;
					}
				}
				trackingObject.body = body; // update
			};
			kinect.client.onBodies = function (trackingIdsJson, frame) {
				var trackingIds = null;
				if (trackingIdsJson != null) {
					trackingIds = JSON.parse(trackingIdsJson);
				}
				onBodies(trackingObjects, trackingIds, frame);
			};
			kinect.client.onFace = onFace;

			var midi = $.connection.midiHub;
			midi.client.onMidi = onMidi;

			$.connection.hub.start().done(function () {
			});

		});

		var trackingObjects = [], bodyFrameIndex;
		function getTrackingObject(id) {
			var hit = null;
			trackingObjects.forEach(function (trackingObject) { // perhaps not the most efficient way, but don't expect too many tracked bodies anyway
				if (trackingObject.id == id) {
					hit = trackingObject;
				}
			});
			if (hit) {
				return hit;
			}
			// create new trackingObject
			console.log("create tracking object " + id);
			var trackingObject = { id: id, body: null }; // init as object that can be easily extended with additional properties
			trackingObjects.push(trackingObject);
			return trackingObject;
		}

		// Kinect body frame arrived
		var activeTrackingObjects = [];
		function onBodies(trackingObjects, trackedBodyIds, frame) {
			bodyFrameIndex = frame;
			activeTrackingObjects = [];
			trackedBodyIds.forEach(function (id) {
				var trackingObject = getTrackingObject(id);
				trackingObject.lastActivationFrame = framecount
				activeTrackingObjects.push(trackingObject);
			});
		}
		var osc = [];
		var oscNames = []
		function onOSC(name, data) {
			osc[name] = data;
		}

		var midi = [];
		function onMidi(channel, data1, data2) {
			//for now, just ignore the channel information
			midi[data1] = data2 / 127.;
			console.log("midi msg: channel " + channel + " , data: " + data1 + " => " + data2);
		}

		var faces = [];

		function onFace(verticesJSON, status, TrackingId) {
			var trackingObject = getTrackingObject(TrackingId);
			var before = Date.now();
			var vertices = JSON.parse(verticesJSON);
			//var vertices = eval(verticesJSON);
			var dur = Date.now() - before;
			var face = faces[TrackingId];
			if (face == undefined) {
				face = {
					shapes: []
				};
				for (var i = 0; i < 1347; i++) {
					var shape = face.shapes[i] = new RegularShape();
					shape.numSides = 4;
					shape.additive = true;
					shape.size = 0.006;
					shape.innerColor = {
						r: 1.,
						g: 1.,
						b: 1.,
						a: 0.5
					};
					shape.outerColor = {
						r: 0.,
						g: 0.,
						b: 0.,
						a: 0
					};
				}
				faces[TrackingId] = face;
			}
			var head = trackingObject.body.head;

			var p2d = {};
			var p3d = {};
			var scale = 1.3;
			for (var i = 0; i < 1347; i++) {

				p3d.x = head.x + (vertices[i * 3 + 0] - head.x) * scale;
				p3d.y = head.y + (vertices[i * 3 + 1] - head.y) * scale;
				p3d.z = head.z + (vertices[i * 3 + 2] - head.z) * scale;

				project(p3d, p2d);

				var shape = face.shapes[i];

				shape.cx = p2d.x;
				shape.cy = p2d.y;

				shape.update();
			}
			//console.log("face mesh deserialize and update time: " + dur);
		}

		function getMidi(id) {

			if (midi[id] == undefined)
				midi[id] = 0;

			return midi[id];
		}

		// drawing skeletons and drag and drop controls
		var joints = ["SpineBase", "SpineMid", "Neck", "Head", "ShoulderLeft",
			"ElbowLeft", "WristLeft", "HandLeft", "ShoulderRight", "ElbowRight",
			"WristRight", "HandRight", "HipLeft", "KneeLeft", "AnkleLeft",
			"FootLeft", "HipRight", "KneeRight", "AnkleRight", "FootRight",
			"SpineShoulder", "HandTipLeft", "ThumbLeft", "HandTipRight", "ThumbRight"];
		var members = [
			//	["SpineBase", "SpineMid"],
			//	["SpineMid", "SpineShoulder"],
			["SpineShoulder", "Neck"],
			["Neck", "Head"],
			["SpineShoulder", "ShoulderLeft"],
			["ShoulderLeft", "ElbowLeft"],
			["ElbowLeft", "WristLeft"],
			["WristLeft", "HandLeft"],
			["HandLeft", "HandTipLeft"],
			["HandLeft", "ThumbLeft"],
	//			["SpineBase", "HipLeft"],
			["SpineBase", "KneeLeft"],
			["SpineBase", "KneeRight"],
			//	["HipLeft", "ShoulderLeft"],
			["HipLeft", "KneeLeft"],
			["KneeLeft", "AnkleLeft"],
			["AnkleLeft", "FootLeft"],
			["SpineShoulder", "ShoulderRight"],
			["ShoulderRight", "ElbowRight"],
			["ElbowRight", "WristRight"],
			["WristRight", "HandRight"],
			["HandRight", "HandTipRight"],
			["HandRight", "ThumbRight"],
	//			["SpineBase", "HipRight"],
			//	["HipRight", "ShoulderRight"],
			["HipRight", "KneeRight"],
			["KneeRight", "AnkleRight"],
			["AnkleRight", "FootRight"],
			["SpineMid", "ShoulderRight"],
			["SpineMid", "ShoulderLeft"],
			["SpineMid", "HipRight"],
			["SpineMid", "HipLeft"]
		];
		// perspective correction
		function project(p3d, p2d) {
			p2d.x = p3d.x;
			p2d.y = p3d.y;
			var w = Math.atan2(-p3d.x, -p3d.y);
			var l = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y);
			var d = 3.;
			var zoom = 5.;
			var p = Math.tan(Math.PI / 2 + Math.atan2(d + p3d.z, l));
			d = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y + (p3d.z + d) * (p3d.z + d));
			p2d.x = zoom * Math.sin(w) * p / aspectx + 0.5;
			p2d.y = zoom * Math.cos(w) * p / aspecty + 0.5;
		}
	</script>


	<!-- some bone material for the skeleton display-->

	<script id="shader-vs-shape" type="x-shader/x-vertex">
		attribute vec3 aPos;
		attribute float aInside;
		varying float inside;
		void main(void) {
		gl_Position = vec4(aPos, 1.);
		inside = aInside;
		}
	</script>

	<script id="shader-fs-shape" type="x-shader/x-fragment">
		uniform vec4 innerColor;
		uniform vec4 outerColor;
		varying float inside;
		void main(void) {
		gl_FragColor = mix(outerColor, innerColor, vec4(inside));
		}
	</script>

	<!-- WebGL supported skeletal model-->

	<script>
		var LineShape = function () {
			this.enabled = true;
			this.x1 = 0.1;
			this.y1 = 0.2;
			this.x2 = 0.5;
			this.y2 = 0.5;
			this.thickness = 0.01;
			this.innerColor = {
				r: 1,
				g: 1,
				b: 1,
				a: 1
			};
			this.outerColor = {
				r: 0,
				g: 0,
				b: 0,
				a: 0.
			};
			this.additive = true;
			this.render = function (targetFBO) {
				if (this.enabled && !(this.x1 == this.x2 && this.y1 == this.y2)) {
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					gl.useProgram(prog_shape);
					gl.uniform4f(gl.getUniformLocation(prog_shape, "innerColor"), this.innerColor.r, this.innerColor.g, this.innerColor.b,
							this.innerColor.a);
					gl.uniform4f(gl.getUniformLocation(prog_shape, "outerColor"), this.outerColor.r, this.outerColor.g, this.outerColor.b,
							this.outerColor.a);
					// stride = 12, for 3 float values, first 2 geometry, last one "inside" value
					gl.vertexAttribPointer(this.aPosLoc, 2, gl.FLOAT, gl.FALSE, 12, 0);
					gl.vertexAttribPointer(this.aInsideLoc, 1, gl.FLOAT, gl.FALSE, 12, 8);
					gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
					gl.enable(gl.BLEND);
					var blendMode = this.additive ? gl.ONE : gl.ONE_MINUS_SRC_ALPHA;
					gl.blendFunc(gl.SRC_ALPHA, blendMode);
					if (targetFBO == null) {
						gl.viewport(0, 0, viewX, viewY);
					} else {
						gl.viewport(0, 0, sizeX, sizeY);
					}
					gl.drawArrays(gl.TRIANGLES, 0, this.trianglesIndices.length);
					gl.disable(gl.BLEND);
				}
			};
			this.update = function () {
				this.points[1].x = (this.x1 - 0.5);
				this.points[1].y = (this.y1 - 0.5);
				this.points[3].x = (this.x2 - 0.5);
				this.points[3].y = (this.y2 - 0.5);
				var l = Math.sqrt((this.points[3].x - this.points[1].x) * (this.points[3].x - this.points[1].x) * viewY / viewX
						+ (this.points[3].y - this.points[1].y) * (this.points[3].y - this.points[1].y));
				var dx = (this.points[3].x - this.points[1].x) * this.thickness / l;
				var dy = (this.points[3].y - this.points[1].y) * this.thickness / l;
				this.points[0].x = this.points[1].x - dx - dy;
				this.points[0].y = this.points[1].y - dy + dx;
				this.points[4].x = this.points[3].x + dx - dy;
				this.points[4].y = this.points[3].y + dy + dx;
				this.points[2].x = (this.points[0].x + this.points[4].x) / 2;
				this.points[2].y = (this.points[0].y + this.points[4].y) / 2;
				this.points[8].x = this.points[1].x - dx + dy;
				this.points[8].y = this.points[1].y - dy - dx;
				this.points[5].x = this.points[3].x + dx + dy;
				this.points[5].y = this.points[3].y + dy - dx;
				this.points[7].x = (this.points[8].x + this.points[5].x) / 2;
				this.points[7].y = (this.points[8].y + this.points[5].y) / 2;
				for (var i = 0; i < this.trianglesIndices.length; i++) {
					this.data[i * 3 + 0] = this.points[this.trianglesIndices[i]].x;
					this.data[i * 3 + 1] = this.points[this.trianglesIndices[i]].y;
					this.data[i * 3 + 2] = this.points[this.trianglesIndices[i]].inside;
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);
			};
			// create initial vertex data
			this.points = [];
			for (var i = 0; i < 9; i++) {
				this.points.push({
					x: 0,
					y: 0,
					inside: 0
				});
			}
			this.points[1].inside = 1;
			this.points[3].inside = 1;
			this.trianglesIndices = [0, 1, 2, 2, 1, 3, 2, 3, 4, 3, 5, 4, 3, 7, 5, 3, 1, 7, 1, 8, 7, 0, 8, 1];
			var rawData = [];
			for (var i = 0; i < this.trianglesIndices.length; i++) {
				rawData.push(0, 0, 0);
			}
			this.data = new Float32Array(rawData);
			this.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
			gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);
			this.aPosLoc = gl.getAttribLocation(prog_shape, "aPos");
			this.aInsideLoc = gl.getAttribLocation(prog_shape, "aInside");
			this.update();
		};
		var RegularShape = function () {
			this.enabled = true;
			this.numSides = 3;
			this.cx = 0.;
			this.cy = 0.;
			this.size = 0.1;
			this.angle = 0;
			this.innerColor = {
				r: 0,
				g: 0,
				b: 1,
				a: 1
			};
			this.outerColor = {
				r: 0,
				g: 0,
				b: 0,
				a: 0.
			};
			this.additive = true;
			this.render = function (targetFBO) {
				if (this.enabled) {
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					gl.useProgram(prog_shape);
					gl.uniform4f(gl.getUniformLocation(prog_shape, "innerColor"), this.innerColor.r, this.innerColor.g, this.innerColor.b,
							this.innerColor.a);
					gl.uniform4f(gl.getUniformLocation(prog_shape, "outerColor"), this.outerColor.r, this.outerColor.g, this.outerColor.b,
							this.outerColor.a);
					// stride = 12, for 3 float values, first 2 geometry, last one "inside" value
					gl.vertexAttribPointer(this.aPosLoc, 2, gl.FLOAT, gl.FALSE, 12, 0);
					gl.vertexAttribPointer(this.aInsideLoc, 1, gl.FLOAT, gl.FALSE, 12, 8);
					gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
					if (targetFBO == null) {
						gl.viewport(0, 0, viewX, viewY);
					} else {
						gl.viewport(0, 0, sizeX, sizeY);
					}
					gl.enable(gl.BLEND);
					var blendMode = this.additive ? gl.ONE : gl.ONE_MINUS_SRC_ALPHA;
					gl.blendFunc(gl.SRC_ALPHA, blendMode);
					gl.drawArrays(gl.TRIANGLE_FAN, 0, this.numSides + 2);
					gl.disable(gl.BLEND);
				}
			};
			this.update = function () {
				this.data[0] = (this.cx - 0.5);
				this.data[1] = (this.cy - 0.5);
				for (var i = 0; i < this.numSides + 1; i++) {
					var x = (this.cx - 0.5) + Math.cos(this.angle + Math.PI * 2 * i / this.numSides) * this.size * viewY / viewX;
					var y = (this.cy - 0.5) + Math.sin(this.angle + Math.PI * 2 * i / this.numSides) * this.size;
					this.data[3 + i * 3] = x;
					this.data[3 + i * 3 + 1] = y;
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);
			};
			// create initial vertex data
			var maxNumSides = 256;
			var rawData = [0, 0, 1];
			for (var i = 0; i < maxNumSides + 1; i++) {
				rawData.push(0, 0, 0);
			}
			this.data = new Float32Array(rawData);
			this.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
			gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);
			this.aPosLoc = gl.getAttribLocation(prog_shape, "aPos");
			this.aInsideLoc = gl.getAttribLocation(prog_shape, "aInside");
			this.update();
		};
		var Joint = function () {
			this.x = 0.5;
			this.y = 0.5;
			this.z = 1;
			this.old = {};
			this.old.x = 0.5;
			this.old.y = 0.5;
			this.old.z = 1;
			this.updatePos = function (pos) {
				this.old.x = this.x;
				this.old.y = this.y;
				this.old.z = this.z;
				this.x = pos.x;
				this.y = pos.y;
				this.z = pos.z;
			};
			this.initShape = function () {
				this.shape = new RegularShape();
				this.shape.additive = false;
				this.shape.size = 0.02;
				this.shape.numSides = 8;
				this.shape.innerColor = {
					r: 1.,
					g: 1.,
					b: 1.,
					a: 1
				};
				this.shape.outerColor = {
					r: 0.,
					g: 0.,
					b: 0.,
					a: 0
				};
				this.updateShape();
			};
			this.updateShape = function () {
				this.shape.cx = this.x;
				this.shape.cy = this.y;
				this.shape.update();
			};
		};
		var Bone = function (joint1, joint2) {
			this.joint1 = joint1;
			this.joint2 = joint2;
			this.updateShape = function () {
				this.shape.x1 = this.joint1.x;
				this.shape.y1 = this.joint1.y;
				this.shape.x2 = this.joint2.x;
				this.shape.y2 = this.joint2.y;
				this.shape.update();
			};
			this.initShape = function () {
				this.shape = new LineShape();
			};
		}
		var KinectWebGLSkeletalModel = function ($) {
			var self = this;
			self.$ = $;
			this.joints = []; // for WebGL, we use an extended joint model with some vertex data attached
			joints.forEach(function (name) { // we just init the skeleton's joints with the same indices so that they can be iterated through in the same way, sorry if the global joints variable and the class member variable are confusing.
				self.joints[name] = new Joint();
			});
			this.bones = []; // what were once members in the raw data model are now bones with a rectangle vertex amendment
			members.forEach(function (member) {
				self.bones[member] = new Bone(self.joints[member[0]], self.joints[member[1]]);
			});
			this.head = new Joint();
			this.handLeft = new Joint();
			this.handRight = new Joint();
			// remember always iterate over the global name arrays and use explicite keys - somehow forEach won't work directly
			this.shuffle = function () {
				joints.forEach(function (id) {
					joint = self.joints[id];
					joint.x = Math.random() * 0.3 * viewY / viewX + 0.5;
					joint.y = Math.random() * 0.3 + 0.5;
					joint.updateShape();
				});
				members.forEach(function (id) {
					self.bones[id].updateShape();
				});
			};
			this.init = function () {
				joints.forEach(function (id) {
					joint = self.joints[id];
					joint.initShape();
				});
				self.head.initShape();
				self.head.shape.numSides = 16;
				self.head.shape.innerColor = { r: 0, g: 0, b: 1., a: 1 };
				self.handLeft.initShape();
				self.handLeft.shape.size = 0.12;
				self.handLeft.shape.numSides = 16;
				self.handLeft.shape.innerColor = { r: 0, g: 0, b: 0, a: 0 };
				self.handRight.initShape();
				self.handRight.shape.size = 0.12;
				self.handRight.shape.numSides = 16;
				self.handRight.shape.innerColor = { r: 0, g: 0, b: 0, a: 0 };
				self.handLeft.pendulum = new Pendulum();
				self.handRight.pendulum = new Pendulum();
				streakLength = 80; // number of LEDs
				historyLength = 16; // number of memorized frames
				self.handLeft.pendulum.initStreaks(streakLength, historyLength);
				self.handRight.pendulum.initStreaks(streakLength, historyLength);
				self.handLeft.pendulum.applyColor = self.handLeft.pendulum.patterns["white stripes"];
				self.handRight.pendulum.applyColor = self.handLeft.pendulum.patterns["white stripes"];
				self.handLeft.pendulum.applyColor = self.handLeft.pendulum.patterns["smiley"];
				self.handRight.pendulum.applyColor = self.handLeft.pendulum.patterns["smiley"];
				self.handLeft.pendulum.applyColor = self.handLeft.pendulum.patterns["rgb sines"];
				self.handRight.pendulum.applyColor = self.handLeft.pendulum.patterns["cmy sines"];
				//self.handLeft.pendulum.applyColor = self.handLeft.pendulum.createTextPatternFn("CAKE23    POI TOY    ", 0.04);
				//self.handRight.pendulum.applyColor = self.handLeft.pendulum.createTextPatternFn("KINECT     WEBGL     ", 0.04);
				//self.handLeft.pendulum.applyColor = self.handLeft.pendulum.createTextPatternFn("WARNOW   VALLEY    ", 0.033);
				//self.handRight.pendulum.applyColor = self.handLeft.pendulum.createTextPatternFn("HACKSPACE   HRO  ", 0.033);
				//self.handLeft.pendulum.applyColor = self.handLeft.pendulum.patterns["transparent"];
				//self.handRight.pendulum.applyColor = self.handLeft.pendulum.patterns["transparent"];
				//self.handLeft.pendulum.applyColor = self.handLeft.pendulum.createTextPatternFn("TRICK OR TREAT? ", 0.04);
				//self.handRight.pendulum.applyColor = self.handLeft.pendulum.createTextPatternFn("SAMHAIN  2015    ", 0.04);
				self.handLeft.pendulum.applyColor = self.handLeft.pendulum.patterns["transparent"];
				self.handRight.pendulum.applyColor = self.handLeft.pendulum.patterns["transparent"];
				members.forEach(function (id) {
					bone = self.bones[id];
					bone.initShape();
				});
				self.shuffle();
			};
			self.init();
			this.updateShapes = function () {
				joints.forEach(function (id) {
					joint = self.joints[id];
					joint.updateShape();
				});
				//self.head.updateShape();
				self.handLeft.updateShape();
				self.handRight.updateShape();
				self.handLeft.pendulum.x = self.$.body.handLeft.x;
				self.handLeft.pendulum.y = self.$.body.handLeft.y;
				self.handLeft.pendulum.z = self.$.body.handLeft.z;
				self.handRight.pendulum.x = self.$.body.handRight.x;
				self.handRight.pendulum.y = self.$.body.handRight.y;
				self.handRight.pendulum.z = self.$.body.handRight.z;
				members.forEach(function (id) {
					bone = self.bones[id];
					bone.updateShape();
				});
			};
			this.renderJoints = function (fbo) {
				joints.forEach(function (id) {
					joint = self.joints[id];
					joint.shape.render(fbo);
				});
				self.head.shape.render(fbo);
				self.handLeft.shape.render(fbo);
				self.handRight.shape.render(fbo);
			}
			this.renderBones = function (fbo) {
				members.forEach(function (id) {
					bone = self.bones[id];
					bone.shape.render(fbo);
				});
			};
			this.renderPendulums = function (fbo) {
				self.handLeft.pendulum.renderStrips(fbo);
				self.handRight.pendulum.renderStrips(fbo);
				/*
				 self.handLeft.pendulum.renderSupportPoints(fbo);
				 self.handRight.pendulum.renderSupportPoints(fbo);
				 */
			}
		};
		function updateKinectSkeletons() {
			activeTrackingObjects.forEach(function (trackingObject) {
				if (!gl) {
					return; // the used shapes need gl to init their vertex data
				}
				var body = trackingObject.body;

				var skeleton = trackingObject.skeleton;
				if (skeleton == null) {
					skeleton = new KinectWebGLSkeletalModel(trackingObject);
					trackingObject.skeleton = skeleton;
				}
				skeleton.lastActivationFrame = framecount;
				var p2d = {};
				var p3d = {};
				joints.forEach(function (id) {
					var joint = skeleton.joints[id];
					p3d.x = body.Joints[id].Position.X; // sry 2 lazy 2 refactor to upper case
					p3d.y = body.Joints[id].Position.Y;
					p3d.z = body.Joints[id].Position.Z;
					project(p3d, p2d);
					joint.updatePos({ x: p2d.x, y: p2d.y, z: p3d.z }); // z for what it's worth
					var col = { r: 0, g: 0, b: 0, a: 0 };
					switch (body.Joints[id].TrackingState) {
						case 0:
						case 1:
							col = { r: 1, g: 0, b: 0, a: 1 };
							break;
						case 2:
							col = { r: 0, g: 1, b: 0, a: 1 };
							break;
					}
					joint.shape.innerColor = col;
				});
				var neckx = skeleton.joints.Neck.x;
				var necky = skeleton.joints.Neck.y;
				var headx = skeleton.joints.Head.x;
				var heady = skeleton.joints.Head.y;
				skeleton.head.shape.size = 3 * Math.sqrt((headx - neckx) * (headx - neckx) + (heady - necky) * (heady - necky));
				skeleton.head.shape.cx = headx;
				skeleton.head.shape.cy = heady;
				skeleton.head.shape.update();
				skeleton.handLeft.shape.innerColor = { r: 0, g: 0, b: 0, a: 0 }; // hand default: see through
				if (body.handLeft.grab || body.handLeft.point) {
					skeleton.handLeft.shape.innerColor = { r: 0, g: 0, b: 1, a: 1 }; // grab: blue
					if (body.handLeft.point) {
						skeleton.handLeft.shape.innerColor = { r: 0, g: 0, b: 1, a: 1 }; // point: blue
					}
				}
				var x = body.handLeft.x;
				var y = body.handLeft.y;
				var z = body.handLeft.z;
				skeleton.handLeft.updatePos({ x: x, y: y, z: z });
				skeleton.handRight.shape.innerColor = { r: 0, g: 0, b: 0, a: 0 };
				if (body.handRight.grab || body.handRight.point) {
					skeleton.handRight.shape.innerColor = { r: 0, g: 0, b: 1, a: 1 };
					if (body.handRight.point) {
						skeleton.handRight.shape.innerColor = { r: 0, g: 0, b: 1, a: 1 };
					}
				}
				x = body.handRight.x;
				y = body.handRight.y;
				z = body.handRight.z;
				skeleton.handRight.updatePos({ x: x, y: y, z: z });
				members.forEach(function (id) {
					var bone = skeleton.bones[id];
					var ts1 = body.Joints[id[0]].TrackingState;
					var ts2 = body.Joints[id[1]].TrackingState;
					var col = { r: 0, g: 0, b: 0, a: 0 };
					if (ts1 == 2 && ts2 == 2) {
						col = { r: 0, g: 1, b: 0, a: 1 };
					}
					bone.shape.innerColor = col;
				});
				skeleton.updateShapes();
			});
		}

		function drawKinectSkeletonPendulums(fbo) {
			activeTrackingObjects.forEach(function (trackingObject) {
				var skeleton = trackingObject.skeleton;
				skeleton.renderPendulums(fbo);
			});
		}

		function drawKinectSkeletons(fbo) {
			activeTrackingObjects.forEach(function (trackingObject) {
				var skeleton = trackingObject.skeleton;
				skeleton.renderJoints(fbo);
				skeleton.renderBones(fbo);
			});
		}

		function drawKinectFaces(fbo) {
			activeTrackingObjects.forEach(function (trackingObject) {
				var skeleton = trackingObject.skeleton;
				var face = faces[trackingObject.id];
				if (face != null) {
					for (var i = 0; i < 1347; i++) {
						face.shapes[i].render(fbo);
					}
				}
			});
		}

		function sortOutLostTrackingObjects() {
			return; // do it rite or die
			trackingObjects.forEach(function (trackingObject) {
				var threshold = 10;
				if (trackingObject.lastActivationFrame < framecount - threshold) {
					var skeleton = trackingObject.skeleton;
					var before = pendulums.length;
					var index = pendulums.indexOf(skeleton.handLeft.pendulum);
					delete pendulums[index];
					var index = pendulums.indexOf(skeleton.handRight.pendulum);
					delete pendulums[index];
					var after = pendulums.length;
					delete skeleton.handLeft.pendulum;
					delete skeleton.handRight.pendulum;

					// Todo: delete the skeleton and perhaps free the used gl vertex buffery?
				}
			});
		}
	</script>

	<!-- most simple color patch material (for the pendulum triangle strip) -->

	<script id="shader-vs-patch" type="x-shader/x-vertex">
		attribute vec3 aPos;
		attribute vec4 aCol;
		varying vec4 col;
		void main(void) {
		gl_Position = vec4(aPos, 1.);
		col = aCol;
		}
	</script>

	<script id="shader-fs-patch" type="x-shader/x-fragment">
		varying vec4 col;
		void main(void) {
		gl_FragColor = col;
		}
	</script>

	<!-- Pendulum -->

	<script type="text/javascript">
		var StripShape = function (length) {
			this.length = length;
			this.additive = false;
			this.newStreak = [];
			this.oldStreak = [];
			this.setStrip = function (newStreak, oldStreak) {
				this.newStreak = newStreak;
				this.oldStreak = oldStreak;
				this.length = newStreak.length;
			}
			this.render = function (targetFBO) {
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.useProgram(prog_patch);
				// stride = 24, for 6 float values (xyrgba)
				gl.vertexAttribPointer(this.aPosLoc, 2, gl.FLOAT, gl.FALSE, 24, 0);
				gl.vertexAttribPointer(this.aColLoc, 4, gl.FLOAT, gl.FALSE, 24, 8);
				gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
				if (targetFBO == null) {
					gl.viewport(0, 0, viewX, viewY);
				} else {
					gl.viewport(0, 0, sizeX, sizeY);
				}
				gl.enable(gl.BLEND);
				var blendMode = this.additive ? gl.ONE : gl.ONE_MINUS_SRC_ALPHA;
				gl.blendFunc(gl.SRC_ALPHA, blendMode);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, (this.length - 1) * 4);
				gl.disable(gl.BLEND);
			};

			this.update = function () {
				p2d = { x: 0, y: 0 };

				for (var i = 0; i < this.newStreak.length - 1; i++) {

					project(this.newStreak[i], p2d);
					var r = this.newStreak[i].col.r;
					var g = this.newStreak[i].col.g;
					var b = this.newStreak[i].col.b;
					var a = this.newStreak[i].col.a;

					this.data[i * 24 + 0] = p2d.x - 0.5;
					this.data[i * 24 + 1] = -p2d.y + 0.5;
					this.data[i * 24 + 2] = r;
					this.data[i * 24 + 3] = g;
					this.data[i * 24 + 4] = b;
					this.data[i * 24 + 5] = a;

					if (this.oldStreak[i]) {
						project(this.oldStreak[i], p2d);

						this.data[i * 24 + 6] = p2d.x - 0.5;
						this.data[i * 24 + 7] = -p2d.y + 0.5;
						this.data[i * 24 + 8] = r; // at first, these were using the old streak colors but interpolation did not look as good as uniform over the strip width.
						this.data[i * 24 + 9] = g;
						this.data[i * 24 + 10] = b;
						this.data[i * 24 + 11] = a;
					}

					// in a previous version, i took only one pair for one streak point, but fakey quads for pixels look better again
					project(this.newStreak[i + 1], p2d);

					this.data[i * 24 + 12] = p2d.x - 0.5;
					this.data[i * 24 + 13] = -p2d.y + 0.5;
					this.data[i * 24 + 14] = r;
					this.data[i * 24 + 15] = g;
					this.data[i * 24 + 16] = b;
					this.data[i * 24 + 17] = a;

					if (this.oldStreak[i + 1]) {
						project(this.oldStreak[i + 1], p2d);
						this.data[i * 24 + 18] = p2d.x - 0.5;
						this.data[i * 24 + 19] = -p2d.y + 0.5;
						this.data[i * 24 + 20] = r;
						this.data[i * 24 + 21] = g;
						this.data[i * 24 + 22] = b;
						this.data[i * 24 + 23] = a;
					}

				}
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);
			};
			// create initial vertex data
			rawData = [];
			for (var i = 0; i < (length - 1) * 4; i++) {
				rawData.push(0, 0, 0, 0, 0, 0); // x, y, r, g, b, a
			}
			this.data = new Float32Array(rawData);
			this.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
			gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);
			this.aPosLoc = gl.getAttribLocation(prog_patch, "aPos");
			this.aColLoc = gl.getAttribLocation(prog_patch, "aCol");
			this.update();
		}

		var pendulums = [];

		setInterval(function () {
			pendulums.forEach(function (pendulum) {
				pendulum.tick();
			});
		},
		5
		);

		var Pendulum = function () {
			pendulums.push(this);

			this.force = 0.019;
			this.grav = -0.000;
			this.speedFactor = 1.;
			this.friction = 1; // 50
			this.x = 0.5;
			this.y = 0.2;
			this.z = 0.;
			this.points = []; // support points
			for (i = 0; i < 4; i++) {
				shape = new RegularShape(); // perhaps the visible support point shapes will be removed again later
				shape.size = 0.01;
				shape.numSides = 12;
				shape.innerColor = { r: 1, g: 0, b: 0, a: 1 };
				shape.update();
				this.points[i] = { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, shape: shape };
			}

			this.applySpringForce = function (i1, i2) {
				fx = (this.points[i2].x - this.points[i1].x) * this.force;
				fy = (this.points[i2].y - this.points[i1].y) * this.force;
				fz = (this.points[i2].z - this.points[i1].z) * this.force;
				this.points[i1].vx += fx;
				this.points[i2].vx -= fx;
				this.points[i1].vy += fy;
				this.points[i2].vy -= fy;
				this.points[i1].vz += fz;
				this.points[i2].vz -= fz;
			};
			this.frame = 0;
			this.tick = function () {
				// apply spring forces
				for (i = 1; i < 4; i++) {
					this.applySpringForce(i - 1, i);
					var vx = this.points[i].vx;
					var vy = this.points[i].vy;
					var vz = this.points[i].vz;
					var friction = Math.max(0, 1 - (vx * vx + vy * vy + vz * vz) * this.friction); // nonlinear quadratic
					this.points[i].vx *= friction;
					this.points[i].vy *= friction;
					this.points[i].vz *= friction;
					this.points[i].vy -= this.grav;
					this.points[i].x += vx * this.speedFactor; // Verlet integration
					this.points[i].y += vy * this.speedFactor;
					this.points[i].z += vz * this.speedFactor;
				}

				// pin the first point back to the control position
				this.points[0].x = this.x;
				this.points[0].y = this.y;
				this.points[0].z = this.z;

				// add a new streak to the front of the history
				if (this.stripShape != null) {
					var newStreak = [];
					x0 = this.points[0].x; // 4 control points
					y0 = this.points[0].y;
					z0 = this.points[0].z;
					x1 = this.points[1].x;
					y1 = this.points[1].y;
					z1 = this.points[1].z;
					x2 = this.points[2].x;
					y2 = this.points[2].y;
					z2 = this.points[2].z;
					x3 = this.points[3].x;
					y3 = this.points[3].y;
					z3 = this.points[3].z;
					for (i = 0; i < this.streakLength; i++) {
						t = i / this.streakLength;
						u = 1 - t;
						// 6th degree Bernstein polynomial
						var x = (P(t, 5) + 5 * P(t, 4) * u) * x0 + 10 * t * t * t * u * u * x1 + 10 * t * t * u * u * u * x2 + (5 * P(u, 4) * t + P(u, 5)) * x3;
						var y = (P(t, 5) + 5 * P(t, 4) * u) * y0 + 10 * t * t * t * u * u * y1 + 10 * t * t * u * u * u * y2 + (5 * P(u, 4) * t + P(u, 5)) * y3;
						var z = (P(t, 5) + 5 * P(t, 4) * u) * z0 + 10 * t * t * t * u * u * z1 + 10 * t * t * u * u * u * z2 + (5 * P(u, 4) * t + P(u, 5)) * z3;
						newStreak[i] = { x: x, y: y, z: z, frame: this.frame, col: { r: 1, g: 1, b: 1, a: 1 } }; // init white
					}
					this.pushStreak(newStreak);
					this.streakIndex++;
				}
				// advance frame counter
				this.frame++;
			}

			this.streakLength = 256; // number of "pixels"
			this.streakIndex = 0; // column counter for persistence of vision from bitmap or procedurally generated imagery
			this.stripShape = null; // the permanent WebGL renderable
			this.streakHistory = []; // the nonpermanent frame data array history queue
			this.historyLength = 2;
			this.pushStreak = function (streak) {
				this.streakHistory = [streak].concat(this.streakHistory.slice(0, this.historyLength - 1)); // new streak goes in first, truncate history
				this.endpointHistory = [{ x: this.points[3].x, y: this.points[3].y, z: this.points[3].z }].concat(this.endpointHistory.slice(0, this.historyLength - 1));
			}
			this.initStreaks = function (streakLength, historyLength) {
				this.streakLength = streakLength;
				this.stripShape = new StripShape(this.streakLength);
				this.endpointHistory = [];
				this.historyLength = historyLength;
			}
			this.patterns = [];
			this.patterns["transparent"] = function (frame, pos, age, col) {
				col.r = 1;
				col.g = 1;
				col.b = 1;
				col.a = 0;
			};
			this.patterns["white"] = function (frame, pos, age, col) {
				col.r = 1;
				col.g = 1;
				col.b = 1;
				col.a = 1;
			};
			this.patterns["white fadeout"] = function (frame, pos, age, col) {
				col.r = 1;
				col.g = 1;
				col.b = 1;
				col.a = (1 - age / historyLength);
			};
			this.patterns["white stripes"] = function (frame, pos, age, col) {
				var pattern1 = (pos) % 4 == 0;
				var pattern2 = (pos + 1) % 4 == 0;
				var pattern = Math.max(pattern1, pattern2);
				col.r = pattern;
				col.g = pattern;
				col.b = pattern;
				col.a = (pattern - age / historyLength);
			};
			this.patterns["domain map"] = function (frame, pos, age, col) {
				var x = (frame % 64) / 64;
				var y = 2 * pos / this.streakLength;
				col.r = x;
				col.g = y;
				col.b = 0;
				col.a = (1 - 0.5 * age / historyLength);
			};
			this.patterns["rgb sines"] = function (frame, pos, age, col) {
				var x = (frame % 64) / 64;
				var y = 2 * pos / this.streakLength;
				var thickness = 0.05;
				var frequency = 0.25;
				var amplitude = 0.33;
				var sine1 = Math.sin(frame * frequency) * amplitude + 0.5;
				var sine1Mask = (y - sine1 - thickness < 0) * (y - sine1 + thickness > 0);
				var sine2 = Math.sin(frame * frequency + Math.PI * 2 / 3) * amplitude + 0.5;
				var sine2Mask = (y - sine2 - thickness < 0) * (y - sine2 + thickness > 0);
				var sine3 = Math.sin(frame * frequency - Math.PI * 2 / 3) * amplitude + 0.5;
				var sine3Mask = (y - sine3 - thickness < 0) * (y - sine3 + thickness > 0);
				col.r = sine1Mask;
				col.g = sine2Mask;
				col.b = sine3Mask;
				var alphaMask = Math.max(sine1Mask, Math.max(sine2Mask, sine3Mask));
				col.a = alphaMask;
			};
			this.patterns["cmy sines"] = function (frame, pos, age, col) {
				var x = (frame % 64) / 64;
				var y = 2 * pos / this.streakLength;
				var thickness = 0.05;
				var frequency = 0.25;
				var amplitude = 0.33;
				var sine1 = Math.sin(frame * frequency) * amplitude + 0.5;
				var sine1Mask = (y - sine1 - thickness < 0) * (y - sine1 + thickness > 0);
				var sine2 = Math.sin(frame * frequency + Math.PI * 2 / 3) * amplitude + 0.5;
				var sine2Mask = (y - sine2 - thickness < 0) * (y - sine2 + thickness > 0);
				var sine3 = Math.sin(frame * frequency - Math.PI * 2 / 3) * amplitude + 0.5;
				var sine3Mask = (y - sine3 - thickness < 0) * (y - sine3 + thickness > 0);
				col.r = sine1Mask + sine2Mask;
				col.g = sine2Mask + sine3Mask;
				col.b = sine3Mask + sine1Mask;
				var alphaMask = Math.max(sine1Mask, Math.max(sine2Mask, sine3Mask));
				col.a = alphaMask;
			};
			this.patterns["compartments"] = function (frame, pos, age, col) {
				var y = pos / this.streakLength;
				var bandThickness = 0.05;
				// baseline
				var band1Pos = 0.5;
				var thickness = 0.015;
				var band1Mask = (y - band1Pos - thickness < 0) * (y - band1Pos + thickness > 0);
				// divide
				var width = 24;
				var index = frame % width;
				var divide = (index == 0) ? 1 : 0;
				col.r = band1Mask + divide;
				col.g = band1Mask + divide;
				col.b = band1Mask + divide;
				var alphaMask = Math.max(band1Mask, Math.max(divide, 0));
				col.a = alphaMask;
			};
			this.patterns["heart"] = function (frame, pos, age, col) {
				var y = pos / this.streakLength;
				var bandThickness = 0.05;
				var dotMask = (frame % 2 == 0 && pos % 2 == 0) ? 1 : 0;
				// baseline
				var band1Pos = 0.6;
				var thickness = 0.015;
				var band1Mask = (y - band1Pos - thickness < 0) * (y - band1Pos + thickness > 0);
				// divide compartments
				var num = 8;
				var width = 24;
				var index = frame % width;
				var divide = (index == 0) ? 1 : 0;
				var heartFrame = ((frame - index) / width % num == 0) ? 1 : 0;
				var cx = index / width - 0.5;
				var cy = (y - band1Pos) * 3 + Math.abs(index / width - 0.5) * 0.7;
				var d = Math.sqrt(cx * cx + cy * cy);
				var ang = Math.atan2(cy, cx);
				var heartMask = (d < 0.5) ? heartFrame : 0;
				heartFrame = heartMask;
				col.r = band1Mask + divide + heartFrame;
				col.g = band1Mask + divide + heartFrame;
				col.b = band1Mask + divide + heartFrame;
				var alphaMask = Math.max(band1Mask, Math.max(divide, heartFrame * (1 + 0 * dotMask)));
				col.a = alphaMask;
			};

			this.patterns["smiley"] = function (frame, pos, age, col) {
				var width = 16;
				var height = 16;

				var array = [
					[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
					[0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0],
					[0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0],
					[1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0],
					[1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0],
					[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
					[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
					[1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
				];

				var x = (frame % width);
				var offsety = 64;

				var y = pos - offsety;

				var mask = 0;
				if (y >= 0 && y < height) {
					mask = array[y][x];
				}

				col.r = mask;
				col.g = mask;
				col.b = mask;
				col.a = mask;
			};

			this.createTextPatternFn = function (text, bgBlackness) {
				var canvas = document.createElement("canvas");
				var ctx = canvas.getContext("2d");
				var font = "bold italic 18px arial";
				ctx.font = font;
				var l = Math.ceil(ctx.measureText(text).width);
				canvas.width = l;
				canvas.height = 16;

				ctx.fillStyle = "rgba(0,0,0," + bgBlackness + ")";
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				ctx.fillStyle = "#FFF";
				ctx.font = font;
				ctx.fillText(text, 0, 15);
				var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

				var patternFn = function (frame, pos, age, col) {
					var x = (frame % canvas.width);
					var offsety = 32;
					var y = pos - offsety;
					if (y >= 0 && y < canvas.height) {
						var i = (y * canvas.width + x) * 4;
						col.r = data[i + 0] / 256;
						col.g = data[i + 1] / 256;
						col.b = data[i + 2] / 256;
						col.a = data[i + 3] / 256;
					} else {
						col.r = 0;
						col.g = 0;
						col.b = 0;
						col.a = 0;
					}
				};

				return patternFn;
			}

			this.applyColor = this.patterns["white fadeout"]; // replace this anytime at runtime
			function P(m, e) {
				return Math.pow(m, e);
			}

			this.lastRenderFrame = 0;

			this.renderStrips = function (fbo) {
				var framesSinceLastRender = this.frame - this.lastRenderFrame;
				this.lastRenderFrame = this.frame;
				var stripsToRender = Math.min(this.streakHistory.length, framesSinceLastRender + 1);
				// apply colors
				for (i = 0; i < stripsToRender; i++) {
					var streak = this.streakHistory[i];
					for (pos = 0; pos < this.streakLength; pos++) {
						if (streak[pos] != undefined) {
							this.applyColor(streak[pos].frame, pos, i, streak[pos].col);
						}
					}
				}
				// render history from last to first for correct overlay
				for (i = stripsToRender - 1; i > 0; i--) {
					var oldStreak = this.streakHistory[i];
					var newStreak = this.streakHistory[i - 1];
					this.stripShape.setStrip(newStreak, oldStreak);
					this.stripShape.update();
					this.stripShape.render(fbo);
				}
			}
			// the other visualization
			this.numSpringPoints = 1024;
			this.springPoints = [];
			this.initSpringPoints = function (num) {
				this.numSpringPoints = num;
				for (i = 0; i < this.numSpringPoints; i++) {
					t = i / this.numSpringPoints;
					var point = this.springPoints[i] = { x: t, y: t };
					if (i > 0) {
						var line = point.line = new LineShape();
						line.thickness = 0.002;
					}
				}
			}
			this.renderSpringPoints = function (fbo) {
				var p2d = {};
				project(this.points[0], p2d);
				old_x = new_x = x0 = p2d.x;
				old_y = new_y = y0 = p2d.y;
				project(this.points[1], p2d);
				x1 = p2d.x;
				y1 = p2d.y;
				project(this.points[2], p2d);
				x2 = p2d.x;
				y2 = p2d.y;
				project(this.points[3], p2d);
				x3 = p2d.x;
				y3 = p2d.y;
				for (i = 0; i < this.numSpringPoints; i++) {
					t = i / this.numSpringPoints;
					u = 1 - t;
					new_x = (P(t, 5) + 5 * P(t, 4) * u) * x0 + 10 * t * t * t * u * u * x1 + 10 * t * t * u * u * u * x2 + (5 * P(u, 4) * t + P(u, 5)) * x3;
					new_y = (P(t, 5) + 5 * P(t, 4) * u) * y0 + 10 * t * t * t * u * u * y1 + 10 * t * t * u * u * u * y2 + (5 * P(u, 4) * t + P(u, 5)) * y3;
					d = t * u * Math.sin(t * 200) / Math.sqrt(P(new_x - old_x, 2) + P(new_y - old_y, 2)) * 0.1;
					var point = this.springPoints[i];
					new_spring_x = point.x = new_x + (old_y - new_y) * d;
					new_spring_y = point.y = new_y - (old_x - new_x) * d;
					var line = point.line;
					if (line != null) {
						line.x1 = old_spring_x;
						line.y1 = old_spring_y;
						line.x2 = new_spring_x;
						line.y2 = new_spring_y;
						line.update();
						line.render(fbo);
					}
					old_x = new_x;
					old_y = new_y;
					old_spring_x = new_spring_x;
					old_spring_y = new_spring_y;
				}
			};
			this.renderSupportPoints = function (fbo) {
				var p2d = {};
				for (i = 0; i < 4; i++) {
					project(this.points[i], p2d);
					var shape = this.points[i].shape;
					shape.cx = p2d.x;
					shape.cy = 1 - p2d.y;
					shape.update();
					shape.render(fbo);
				}
			};
		}

		var red = { r: 1, g: 0, b: 0, a: 1 };
		var green = { r: 0, g: 1, b: 0, a: 1 };
		var blue = { r: 0, g: 0, b: 1, a: 1 };
		var white = { r: 1, g: 1, b: 1, a: 1 };
		var purple = { r: 0.5, g: 0, b: 0.5, a: 1 };

		var numFishes = 50;
		var fishes = [];
		var kNN = 5;

		var friction = 32;
		var shock = 0.0025;

		var Fish = function () {
			this.angle = 0;
			this.bend = 0;
			this.size = 0.1;
			this.initialColor = this.color = { r: 0.1 + Math.random() * 0.9, g: 0.1 + Math.random() * 0.9, b: 0.1 + Math.random() * 0.9, a: 1 };
			this.x = 0.5;
			this.y = 0.5;

			this.vx = 0;
			this.vy = 0;
			this.rot = 0;

			this.trigger = 0;
			this.response = 0;
			this.turn = 0;

			this.oldTurn = 0;

			this.numShapes = 8;

			this.orientTo = function (x, y) {
				var mX = 0.5 + (mouseX - 0.5) * aspectx;
				var mY = 0.5 + (mouseY - 0.5) * aspecty;
				this.angle = Math.PI + Math.atan2(this.y - mY, this.x - mX);
			}

			this.tick = function () {

				this.trigger = (Math.random() - 0.5) * (Math.random() > 0.985);
				this.response = this.response * 0.94 + (this.trigger - this.turn) * 0.125;
				this.turn += this.response * 0.75;

				// taking the difference in turn for forward acceleration
				var acc = Math.abs(this.turn - this.oldTurn) * 0.005;

				this.vx += Math.cos(this.angle) * acc;
				this.vy += Math.sin(this.angle) * acc;

				this.oldTurn = this.turn;

				this.rot *= Math.max(0, 0.999 - acc * 256);

				var v = Math.sqrt(this.vx * this.vx + this.vy * this.vy);

				// bend
				this.bend = this.bend * 0.95 + this.rot * 0.45 + this.turn;

				// apply friction
				var fric = Math.max(0, 1 - v * v * friction * friction - v * 2); // empirical non-linear
				this.vx *= fric;
				this.vy *= fric;

				// apply direction change
				this.angle += this.rot;

				// apply drive

				// add velocity
				this.x += this.vx;
				this.y += this.vy;

				// surface velocity at the radius
				var vr = Math.sin(this.rot) * this.size;

				// bend
				this.bend = this.bend * 0.94 + this.turn * 0.75 + vr * 2.5;

				// screen space coordinates are normalized so that the unit square is fitted in the center
				// now the screen is likely not a square and the physically availabe world must be extended
				var extx = (aspectx - 1) / 2;
				var exty = (aspecty - 1) / 2;

				// bounce off ceiling
				if (this.y > 1 + exty - this.size * 0.5) {
					this.vy = -shock;
					vr = this.vx;
				}

				// bounce off floor
				if (this.y < -exty + this.size * 0.5) {
					this.vy = shock;
					vr = -this.vx;
				}

				// bounce off left wall
				if (this.x < -extx + this.size * 0.5) {
					this.vx = shock;
					vr = this.vy;
				}

				// bounce off right wall
				if (this.x > 1 + extx - this.size * 0.5) {
					this.vx = -shock;
					vr = -this.vy;
				}

				this.rot = Math.asin(vr / this.size);
			}

			this.shapes = [];
			this.circle;
			this.arrows = [];

			this.initShapes = function () {
				for (var i = 0; i < this.numShapes; i++) {
					var shape = this.shapes[i] = new RegularShape();
					shape.numSides = 3;
				}
				for (var i = 0; i < kNN; i++) {
					var arrow = this.arrows[i] = new RegularShape();
					arrow.numSides = 3;
					arrow.innerColor = red;
					arrow.outerColor = red;
					arrow.size = 0.005;
				}
				this.circle = new RegularShape();
				this.circle.numSides = 24;
			}

			this.updateShapes = function () {
				for (var i = 0; i < this.numShapes; i++) {
					var shape = this.shapes[i];
					var spine = (i - this.numShapes / 2) / this.numShapes - 0.;

					shape.angle = this.angle + this.bend * spine * 2;
					shape.innerColor = this.color;
					var dir = (spine + 0.4) * this.bend * 1.3;
					var c = Math.cos(this.angle + dir);
					var s = Math.sin(this.angle + dir);

					shape.cx = 0.5 + (this.x - 0.5) * 2 / aspectx + (c * (spine - 0.1) + (spine + 0.4) * s * (this.bend) * 0.5) * 2 * this.size / aspectx;
					shape.cy = 0.5 + (this.y - 0.5) * 2 / aspecty + (s * (spine - 0.1) - (spine + 0.4) * c * (this.bend) * 0.5) * 2 * this.size / aspecty;
					shape.size = this.size * (1.25 + spine);

					shape.update();
				}

				// indicating the relative position of the neighbor with an arrow
				for (var i = 0; i < kNN; i++) {
					var arrow = this.arrows[i];
					var theOtherFish = this.nearestNeighbors[i + 1].fish;
					var distance = this.nearestNeighbors[i + 1].d;

					var angle = arrow.angle = Math.atan2(theOtherFish.y - this.y, theOtherFish.x - this.x);
					arrow.cx = 0.5 + (this.x - 0.5 + Math.cos(angle) * this.size * 0.5) * 2 / aspectx;
					arrow.cy = 0.5 + (this.y - 0.5 + Math.sin(angle) * this.size * 0.5) * 2 / aspecty;
					arrow.update();
				}

				// hit "area"
				this.circle.cx = 0.5 + (this.x - 0.5) * 2 / aspectx;
				this.circle.cy = 0.5 + (this.y - 0.5) * 2 / aspecty;
				this.circle.size = this.size;
				this.circle.innerColor = this.color;
				this.circle.outerColor = this.color;
				this.circle.update();
			}

			this.render = function (fbo) {
				for (var i = 0; i < this.numShapes; i++) {
					this.shapes[i].render(fbo);
				}
				//this.circle.render(fbo);
				for (var i = 0; i < kNN; i++) {
					this.arrows[i].render(fbo);
				}
			}
		};

		var cursor;

		function initFishes() {
			return;
			fishes = [];
			for (var i = 0; i < numFishes; i++) {
				var fish = new Fish();
				var n = i / (numFishes - 1);
				fish.size = 0.01 + n * 0.05;
				fish.x = Math.random();
				fish.y = Math.random();
				fish.angle = Math.random() * Math.PI * 2;
				var v = 0.0;
				fish.vx = Math.cos(fish.angle) * v;
				fish.vy = Math.sin(fish.angle) * v;
				fish.initShapes();
				fishes.push(fish);
			}

			cursor = new RegularShape();
			cursor.size = 0.05;
			cursor.numSides = 8;
			cursor.innerColor = white;

			distances = new Float32Array(numFishes * numFishes);
		}

		function updateFishes() {
			return;
			calcDistances();
			computeNearestNeighbors();
			checkIsMouseOverFish()

			doFishyFishyInteraction();

			fishes.forEach(function (fish) {
				fish.tick();
				fish.updateShapes();
			});

			cursor.cx = 0.5 + (mouseX - 0.5) * 2;
			cursor.cy = 0.5 + (mouseY - 0.5) * 2;
			cursor.update();
		}

		function drawFishesOnFBO(fbo) {
			fishes.forEach(function (fish) {
				fish.render(fbo);
			});
			cursor.render(fbo);
		}

		function checkIsMouseOverFish() {
			var hits = [];
			for (var i = 0; i < numFishes; i++) {
				var fish = fishes[i];
				var fishx = 0.5 + (fish.x - 0.5) / aspectx;
				var fishy = 0.5 + (fish.y - 0.5) / aspecty;
				var d = Math.sqrt(Math.pow((fishx - mouseX) * aspectx, 2) + Math.pow((fishy - mouseY) * aspecty, 2));
				if (d < fish.size / 2) {
					hits.push(fish);
				}

				//reset all
				fish.color = fish.initialColor;
				fish.updateShapes();
			}

			// highlight hits and neighbors
			hits.forEach(function (fish) {
				for (var i = 0; i < kNN; i++) {
					fish.nearestNeighbors[i + 1].fish.color = green;
					fish.nearestNeighbors[i + 1].fish.updateShapes();
				}
				fish.color = green;
				fish.updateShapes();
			});
		}

		var distances;

		function getDistance(i, j) {
			if (i < j) {
				return distances[i * numFishes + j];
			} else {
				return distances[j * numFishes + i];
			}
		}

		function calcDistances() {
			for (var i = 0; i < numFishes; i++) {
				var fish = fishes[i];
				for (var j = i + 1; j < numFishes; j++) {
					var theOtherFish = fishes[j];
					var d = Math.sqrt((fish.x - theOtherFish.x) * (fish.x - theOtherFish.x) + (fish.y - theOtherFish.y) * (fish.y - theOtherFish.y));
					distances[i * numFishes + j] = d;
				}
			}
		}

		function computeNearestNeighbors() {
			for (var i = 0; i < numFishes; i++) {
				var fish = fishes[i];
				fish.nearestNeighbors = [];
				for (var j = 0; j < numFishes; j++) {
					var theOtherFish = fishes[j];
					fish.nearestNeighbors.push({ d: getDistance(i, j), fish: theOtherFish }); // push tuples of distance and the other fish
				}
				fish.nearestNeighbors.sort(function (a, b) { return a.d - b.d; }); // order by distance
			}
		}

		function doFishyFishyInteraction() {
			// we could reduce hit tests to only with the top nearest neighbors but then again collision would be detected in doubles
			// bouncing circles with rotation (not physically accurate)
			for (var i = 0; i < numFishes; i++) {
				var fish = fishes[i];
				var vr = Math.sin(fish.rot) * fish.size; // circumference velocity
				var v1 = Math.sqrt(fish.vx * fish.vx + fish.vy * fish.vy); // velocity
				var w1 = Math.atan2(fish.vx, fish.vy); // motion direction

				for (var j = i + 1; j < numFishes; j++) {
					var theOtherFish = fishes[j];
					var distance = getDistance(i, j);

					if (distance * 2 < fish.size + theOtherFish.size) {

						// we have an overlap, now check if they don't drift apart already
						var nextFrameDistance = Math.sqrt(
							Math.pow(fish.x - theOtherFish.x + fish.vx - theOtherFish.vx, 2)
							+ Math.pow(fish.y - theOtherFish.y + fish.vy - theOtherFish.vy, 2));
						if (nextFrameDistance < distance) {

							// momentum transfer
							var ref_ang = Math.atan2(fish.x - theOtherFish.x, (fish.y - theOtherFish.y)) - Math.PI * 0.5; // angle of the common tangent
							var v2 = Math.sqrt(theOtherFish.vx * theOtherFish.vx + theOtherFish.vy * theOtherFish.vy);
							var w2 = Math.atan2(theOtherFish.vx, theOtherFish.vy);

							var vr2 = Math.sin(theOtherFish.rot) * theOtherFish.size; // theOtherFish's circumference velocity
							var m1 = Math.pow(fish.size, 3);
							var m2 = Math.pow(theOtherFish.size, 3);

							var vv1 = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2);
							var vv2 = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2);
							var vrr = ((m1 - m2) * vr + 2 * m2 * vr2) / (m1 + m2);
							var vrr2 = ((m2 - m1) * vr2 + 2 * m1 * vr) / (m1 + m2);

							fish.vx = Math.sin(ref_ang) * v1 * Math.cos(w1 - ref_ang) + ((vr - vr2) - Math.sin(ref_ang) * v1 * Math.cos(w1 - ref_ang)) * 0.15 + Math.cos(ref_ang) * vv1 * Math.sin(w2 - ref_ang);
							fish.vy = Math.cos(ref_ang) * v1 * Math.cos(w1 - ref_ang) + ((vr - vr2) - Math.cos(ref_ang) * v1 * Math.cos(w1 - ref_ang)) * 0.15 - Math.sin(ref_ang) * vv1 * Math.sin(w2 - ref_ang);

							theOtherFish.vx = Math.sin(ref_ang) * v2 * Math.cos(w2 - ref_ang) + ((vr2 - vr) - Math.sin(ref_ang) * v2 * Math.cos(w2 - ref_ang)) * 0.15 + Math.cos(ref_ang) * vv2 * Math.sin(w1 - ref_ang);
							theOtherFish.vy = Math.cos(ref_ang) * v2 * Math.cos(w2 - ref_ang) + ((vr2 - vr) - Math.cos(ref_ang) * v2 * Math.cos(w2 - ref_ang)) * 0.15 - Math.sin(ref_ang) * vv2 * Math.sin(w1 - ref_ang);
							vr = Math.cos(w1 - ref_ang) * (v1 - v2);
							fish.rot = Math.asin(vr / fish.size);

							vr2 = Math.cos(w2 - ref_ang) * (v2 - v1);
							theOtherFish.rot = Math.asin(vr2 / theOtherFish.size);

							/*
							fish.vx = Math.sin(ref_ang) * v1 * Math.cos(w1 - ref_ang) + Math.cos(ref_ang) * vv1 * Math.sin(w2 - ref_ang);
							fish.vy = (Math.cos(ref_ang) * v1 * Math.cos(w1 - ref_ang) - Math.sin(ref_ang) * vv1 * Math.sin(w2 - ref_ang));

							theOtherFish.vx = Math.sin(ref_ang) * v2 * Math.cos(w2 - ref_ang) + Math.cos(ref_ang) * vv2 * Math.sin(w1 - ref_ang);
							theOtherFish.vy = (Math.cos(ref_ang) * v2 * Math.cos(w2 - ref_ang) - Math.sin(ref_ang) * vv2 * Math.sin(w1 - ref_ang));
							*/

						}
					}
				}
				for (var k = 0; k < kNN; k++) {
					var theOtherFish = fish.nearestNeighbors[k + 1].fish;
					var distance = fish.nearestNeighbors[k + 1].d;
					// nearest neighbors are ordered by distance but the index zero points to self
					// implement Boids behavior here
				}
				// or here, you know best
			}
		}

	</script>

	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aPos;
		attribute vec2 aTexCoord;
		varying   vec2 uv;
		varying vec2 uv_orig;
		void main(void) {
		gl_Position = vec4(aPos, 1.);
		uv = aTexCoord;
		uv_orig = uv;
		}
	</script>

	<script id="shader-fs-inc" type="x-shader/x-fragment">
		#ifdef GL_ES
		precision highp float;
		#endif
		varying vec2 uv;
		varying vec2 uv_orig;
		uniform vec2 texSize;
		uniform vec2 pixelSize;
		uniform vec2 aspect;
		uniform vec2 scale;
		uniform vec4 fader;
		uniform vec4 buttons;
		uniform vec4 oldButtons;
		uniform vec4 mover0;
		uniform vec4 pendulum0;
		uniform int moverState0;
		uniform vec4 mover1;
		uniform vec4 pendulum1;
		uniform int moverState1;
		uniform vec4 mover2;
		uniform vec4 pendulum2;
		uniform int moverState2;
		uniform vec4 mover3;
		uniform vec4 pendulum3;
		uniform int moverState3;
		uniform vec4 mover4;
		uniform vec4 pendulum4;
		uniform int moverState4;
		uniform vec4 mover5;
		uniform vec4 pendulum5;
		uniform int moverState5;
		uniform vec4 mover6;
		uniform vec4 pendulum6;
		uniform int moverState6;
		uniform vec4 mover7;
		uniform vec4 pendulum7;
		uniform int moverState7;
		uniform vec4 mover8;
		uniform vec4 pendulum8;
		uniform int moverState8;
		uniform vec4 mover9;
		uniform vec4 pendulum9;
		uniform int moverState9;
		uniform vec2 head0;
		uniform vec4 col0;
		uniform vec2 head1;
		uniform vec4 col1;
		uniform vec2 head2;
		uniform vec4 col2;
		uniform vec2 head3;
		uniform vec4 col3;
		uniform vec2 head4;
		uniform vec4 col4;
		uniform vec2 head5;
		uniform vec4 col5;
		uniform vec2 head6;
		uniform vec4 col6;
		uniform vec2 head7;
		uniform vec4 col7;
		uniform vec2 head8;
		uniform vec4 col8;
		uniform vec2 head9;
		uniform vec4 col9;
		uniform vec4 midifader1;
		uniform vec4 midifader2;
		uniform vec4 midiknob1;
		uniform vec4 midiknob2;

		vec2 uv_zoom_exp(vec2 uv, vec2 center, vec2 aspect, float zoom, float zoom_exp, float zoom_factor){
		vec2 uv_correct = 0.5 + (uv -0.5)* aspect;
		vec2 center_correct = 0.5 + ( center - 0.5) * aspect;
		vec2 zoom_distorted = center_correct + (uv_correct - center_correct)*(1. - zoom * pow(zoom_exp, zoom_factor*length(uv_correct-center_correct)));
		return 0.5 + (zoom_distorted - 0.5) / aspect;
		}

		bool is_onscreen(vec2 uv){
		return (uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.);
		}

		float filter(vec2 uv, vec2 pos){
		return clamp( 1.-length((uv-pos)*texSize)/2., 0. , 1.);
		}

		float border(vec2 uv, float border, vec2 texSize){
		uv*=texSize;
		return (uv.x
		<border || uv.x>
			texSize.x-border || uv.y<border || uv.y>
				texSize.y-border) ? 1.:.0;
				}

				#define pi 3.141592653589793238462643383279
				#define pi_inv 0.318309886183790671537767526745
				#define pi2_inv 0.159154943091895335768883763372

				float border(vec2 domain, float thickness){
				vec2 uv = fract(domain-vec2(0.5));
				uv = min(uv,1.-uv)*2.;
				return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);
				}

				float square_mask(vec2 domain){
				return (domain.x <= 1. && domain.x >= 0. && domain.y <= 1. && domain.y >= 0.) ? 1. : 0.;
				}

				vec2 complex_mul(vec2 factorA, vec2 factorB){
				return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);
				}

				vec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){
				vec2 uv = domain - center;
				float d = length(uv);
				return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;
				}

				vec2 complex_div(vec2 numerator, vec2 denominator){
				return vec2( numerator.x*denominator.x + numerator.y*denominator.y,
				numerator.y*denominator.x - numerator.x*denominator.y)/
				vec2(denominator.x*denominator.x + denominator.y*denominator.y);
				}

				// HSL to RGB converter code from http://www.gamedev.net/topic/465948-hsl-shader-glsl-code/
				float Hue_2_RGB(float v1, float v2, float vH )
				{
				float ret;
				if ( vH < 0.0 )
				vH += 1.0;
				if ( vH > 1.0 )
				vH -= 1.0;
				if ( ( 6.0 * vH ) < 1.0 )
				ret = ( v1 + ( v2 - v1 ) * 6.0 * vH );
				else if ( ( 2.0 * vH ) < 1.0 )
				ret = ( v2 );
				else if ( ( 3.0 * vH ) < 2.0 )
				ret = ( v1 + ( v2 - v1 ) * ( ( 2.0 / 3.0 ) - vH ) * 6.0 );
				else
				ret = v1;
				return ret;
				}

				vec3 hsl2rgb(float H, float S, float L){
				float var_2, var_1, R, G, B;
				if (S == 0.0)
				{
				R = L;
				G = L;
				B = L;
				}
				else
				{
				if ( L < 0.5 )
				{
				var_2 = L * ( 1.0 + S );
				}
				else
				{
				var_2 = ( L + S ) - ( S * L );
				}

				var_1 = 2.0 * L - var_2;

				R = Hue_2_RGB( var_1, var_2, H + ( 1.0 / 3.0 ) );
				G = Hue_2_RGB( var_1, var_2, H );
				B = Hue_2_RGB( var_1, var_2, H - ( 1.0 / 3.0 ) );
				}
				return vec3(R,G,B);
				}

				vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
				vec4 dX = 0.5*texture2D(sampler, uv + vec2(1.,0.)*d) - 0.5*texture2D(sampler, uv - vec2(1.,0.)*d);
				vec4 dY = 0.5*texture2D(sampler, uv + vec2(0.,1.)*d) - 0.5*texture2D(sampler, uv - vec2(0.,1.)*d);
				return vec2( dot(dX, selector), dot(dY, selector) );
				}

				vec2 rot90(vec2 vector){
				return vector.yx*vec2(1,-1);
				}

				float line_segment(vec2 domain, vec2 p1, float d1, vec2 p2, float d2){
				float h = 1./(p2.x-p1.x); // helper registers
				float h1 = (p2.y-p1.y)*h;
				float h2 = 1./h1;
				float xs = (-p1.y+h1*p1.x+h2*domain.x+domain.y)/(h2+h1);// coordinates of the point on the line between p1 and p2,
				float ys = -h2*(xs-domain.x)+domain.y;					// ^ orthogonally to the given point in the domain
				float d = length(domain-vec2(xs,ys));		// the orthogonal distance from the domain point to the line (unlimited)
				float s = 0.; // distance from domain point to p1 relative to p2
				if(p2.x == p1.x){	// division by zero fix
				d = abs(domain.x - p1.x);
				s = (p1.y-ys)/(p1.y-p2.y);
				}else{
				s = (xs-p1.x)*h;
				}
				d = clamp(d*(d1*(1.-s)+d2*s),0., 1.);	// adjusting the line thickness using a linear interpolation with s
				float m1 = 0.; if(s > 0.) m1 = 1.; 		// masking out the segment between p1 and p2
				float m2 = 0.; if(s < 1.) m2 = 1.;
				float result = clamp( m1*m2-d, 0., 1.); // return result as 1-distance in the range [0..1]
				result = clamp(1.-length(domain-vec2(p1.x,p1.y))*d1-m1, result, 1.);	// round corners if you will (half circles)
				//result = clamp(1.-length(domain-vec2(p2.x,p2.y))*d2-m2, result, 1.);

				return result;
				}

				float circle(vec2 uv, vec2 aspect, float scale){
				return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);
				}

				float sigmoid(float x) {
				return 2./(1. + exp2(-x)) - 1.;
				}

				float smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){
				return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;
				}

				float conetip(vec2 uv, vec2 pos, float size, float min)
				{
				return max( min, 1. - length((uv - pos) * aspect / size) );
				}

				float warpFilter(vec2 uv, vec2 pos, float size, float ramp)
				{
				return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;
				}

				vec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)
				{
				vec2 pos_correct = 0.5 + (pos - 0.5);
				vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;
				float filter = warpFilter(uv, pos_correct, size, ramp);
				return mix(uv, rot_uv, filter);
				}

				vec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)
				{
				float ramp = 4.;

				float d = 0.138 / 1024. / pixelSize.y;

				float l = length(vel);
				vec2 p1 = pos;
				vec2 p2 = pos;

				if(l > 0.){
				vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;
				p1 = pos - normal * d / 2.;
				p2 = pos + normal * d / 2.;
				}

				float w = l / d * 2.;

				// two overlapping rotations that would annihilate when they were not displaced.
				vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));
				vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));
				return (circle1 + circle2) / 2.;
				}

	</script>

	<script id="shader-fs-copy" type="x-shader/x-fragment">
		uniform sampler2D source;
		void main(void) {
		gl_FragColor = texture2D(source, uv);
		}
	</script>

	<script id="shader-fs-init" type="x-shader/x-fragment">
		void main(void){
		gl_FragColor = vec4(0.);
		}
	</script>

	<script id="shader-fs-move-particles" type="x-shader/x-fragment">
		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_prev_n;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_blur2;
		uniform sampler2D sampler_blur3;
		uniform sampler2D sampler_blur4;
		uniform sampler2D sampler_blur5;
		uniform sampler2D sampler_blur6;
		uniform sampler2D sampler_noise;
		uniform sampler2D sampler_noise_n;
		uniform sampler2D sampler_fluid;
		uniform sampler2D sampler_particles;

		uniform vec4 rnd;
		uniform float frame;
		uniform vec2 mouse;
		uniform vec2 mouseV;

		vec4 moverCol(int moverState){
		vec4 red = vec4(1,0,0,0);
		vec4 green = vec4(0,1,0,0);
		vec4 blue = vec4(0,0,1,0);

		vec4 cyan = vec4(0,1,1,0);
		vec4 yellow = vec4(1,1,0,0);

		vec4 purple = vec4(0.5,0,.50,0);

		vec4 col = purple; // unknown

		if(moverState == 1){ // lasso
		col = cyan;
		}
		if(moverState == 2){ // open
		col = red;
		}
		if(moverState == 3){ // closed
		col = green;
		}
		if(moverState == 4){ // pointy
		col = yellow;
		}
		return col;
		}

		vec4 applyMoverForce(vec4 p, vec2 f00, int moverState, vec4 mover, vec4 col){
		if(col.a == 1. && (moverState == 2 || moverState == 3)){
		vec2 pos = (p.xy - mover.xy);
		float d = length(pos*aspect);

		float area = smoothcircle(p.xy-mover.xy+0.5, aspect, 0.075, 75.);
		float dir = 1.;
		if( moverState == 3){
		dir = -1.;
		}
		p.zw += pos * area * dir * 0.75;

		//p.xy += mover.zw * float(d < 0.04); // simple window cleaner
		}
		return p;
		}

		vec4 applyMoverForces(vec4 p, vec2 foo){
		p = applyMoverForce(p, foo, moverState0, mover0, col0); // first person, left hand
		p = applyMoverForce(p, foo, moverState1, mover1, col0); // right hand
		p = applyMoverForce(p, foo, moverState2, mover2, col1); // second person
		p = applyMoverForce(p, foo, moverState3, mover3, col1);
		p = applyMoverForce(p, foo, moverState4, mover4, col2); // third
		p = applyMoverForce(p, foo, moverState5, mover5, col2);
		p = applyMoverForce(p, foo, moverState6, mover6, col3);
		p = applyMoverForce(p, foo, moverState7, mover7, col3);
		p = applyMoverForce(p, foo, moverState8, mover8, col4);
		p = applyMoverForce(p, foo, moverState9, mover9, col4);
		p.xy += foo;
		return p;
		}

		void main(void){
		vec4 p = texture2D(sampler_particles, uv); // residual location and velocity of the particle in the previous frame
		vec2 f = texture2D(sampler_fluid, p.xy).xz*pixelSize; // fluid simulation flow vector
		vec4 noise = texture2D(sampler_noise, p.xy)*2. - vec4(1.);

		// apply forces
		p.zw += gradient(sampler_blur6, p.xy, pixelSize*64., vec4(-1.,1.75,0.,0.))*pixelSize; // gradients from red and green

		vec2 oo = vec2(0);
		oo += gradient(sampler_prev, p.xy, pixelSize*1., vec4(-32.,0,0.,0.))*pixelSize; // move away from red, accurate
		oo += gradient(sampler_blur, p.xy, pixelSize*4., vec4(4.,0,0.,0.))*pixelSize; // move toward red, smooth
		oo += rot90(gradient(sampler_blur2, p.xy, pixelSize*8., vec4(-8.,0,0.,0.)))*pixelSize; // move orthogonal to the gradient

		p = applyMoverForces(p, f+oo); // fluid + other offset

		p.zw = p.zw * max(0., 1.- (p.z*p.z + p.w*p.w)*32.); // (non-linear) friction

		p.xy += p.zw; // verlet integration

		/*
		float bounce = 0.999;

		if(p.x < 0.){
		p.x = 0.;
		p.z = abs(p.z)*bounce;
		}else if(p.x > 1.){
		p.x = 1.;
		p.z = -abs(p.z)*bounce;
		}

		if(p.y < 0.){
		p.y = 0.;
		p.w = abs(p.w)*bounce;
		}else if(p.y > 1.){
		p.y = 1.;
		p.w = -abs(p.w)*bounce;
		}

		gl_FragColor = p; // write back
		*/
		gl_FragColor.xy = fract(p.xy); // wrap

		gl_FragColor.zw = p.zw;
		}
	</script>

	<script id="shader-fs-composite" type="x-shader/x-fragment">
		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_prev_n;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_blur2;
		uniform sampler2D sampler_blur3;
		uniform sampler2D sampler_blur4;
		uniform sampler2D sampler_blur5;
		uniform sampler2D sampler_blur6;
		uniform sampler2D sampler_noise;
		uniform sampler2D sampler_noise_n;
		uniform sampler2D sampler_fluid;
		uniform sampler2D sampler_fluid_p;
		uniform sampler2D sampler_particles;
		uniform sampler2D sampler_particle_projection;
		uniform sampler2D sampler_skeletons;

		uniform vec4 rnd;
		uniform vec4 rainbow;
		uniform vec2 mouse;
		uniform vec2 mouseV;
		uniform float fps;
		uniform float time;
		uniform float frame;

		float mouseFilter(vec2 uv){
		return clamp( 1.-length((uv-mouse)*texSize)/16., 0. , 1.);
		}

		vec4 moverCol(int moverState){
		vec4 red = vec4(1,0,0,0);
		vec4 green = vec4(0,1,0,0);
		vec4 blue = vec4(0,0,1,0);

		vec4 cyan = vec4(0,1,1,0);
		vec4 yellow = vec4(1,1,0,0);

		vec4 purple = vec4(0.5,0,.50,0);

		vec4 col = purple; // unknown

		if(moverState == 1){ // lasso
		col = cyan;
		}
		if(moverState == 2){ // open
		col = red;
		}
		if(moverState == 3){ // closed
		col = green;
		}
		if(moverState == 4){ // pointy
		col = yellow;
		}
		return col;
		}

		void mixInMover(int moverState, vec4 mover, vec4 col){
		if(col.a == 1.){
		gl_FragColor = mix(gl_FragColor, moverCol(moverState), smoothcircle(uv-mover.xy+0.5, aspect, 0.025, 96.));
		}
		}

		void mixInMovers(){
		mixInMover(moverState0, mover0, col0); // first person, left hand
		mixInMover(moverState1, mover1, col0); // right hand

		mixInMover(moverState2, mover2, col1); // second person
		mixInMover(moverState3, mover3, col1);

		mixInMover(moverState4, mover4, col2); // third
		mixInMover(moverState5, mover5, col2);
		mixInMover(moverState6, mover6, col3);
		mixInMover(moverState7, mover7, col3);
		mixInMover(moverState8, mover8, col4);
		mixInMover(moverState9, mover9, col4);
		}

		void main(void) {
		vec2 uv_bg = uv	+ (
		gradient(sampler_prev, uv, pixelSize * 1.5, vec4(0.5, 1, 0, 0))
		+ gradient(sampler_blur, uv, pixelSize * 3., vec4(1, 1, 0, 0))
		) * pixelSize * 384.;

		gl_FragColor = mix(vec4(0), vec4(0.25,0.33,0.66,0), texture2D(sampler_blur2, uv_bg).b*1.6);
		//		gl_FragColor = vec4(0);

		gl_FragColor = mix(gl_FragColor, vec4(0.5,0.4,0.5,0), texture2D(sampler_prev, uv).r * (1.- texture2D(sampler_prev, uv).g));

		gl_FragColor = mix(gl_FragColor, mix(vec4(2,2,0,0), vec4(1.,0,0.,0), pow(1.-texture2D(sampler_prev, uv).r,2.)), texture2D(sampler_prev, uv + gradient(sampler_prev, uv, pixelSize * 2., vec4(0, 1, 0, 0))*pixelSize*4.).g);

		//	gl_FragColor = mix(gl_FragColor, vec4(1,1,1,0), texture2D(sampler_skeletons, uv).y);
		mixInMovers();

		gl_FragColor.a = 1.;
		}
	</script>
	<script id="shader-fs-advance" type="x-shader/x-fragment">
		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_prev_n;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_blur2;
		uniform sampler2D sampler_blur3;
		uniform sampler2D sampler_blur4;
		uniform sampler2D sampler_blur5;
		uniform sampler2D sampler_blur6;
		uniform sampler2D sampler_noise;
		uniform sampler2D sampler_noise_n;
		uniform sampler2D sampler_fluid;
		uniform sampler2D sampler_particles;
		uniform sampler2D sampler_particle_projection;

		uniform vec4 rnd;
		uniform vec4 rainbow;
		uniform vec2 mouse;
		uniform vec2 mouseV;
		uniform float fps;
		uniform float time;
		uniform float frame;

		void main(void) {
		float noise = texture2D(sampler_noise, uv + rnd.zw).x*0.5-0.25;
		vec2 f = texture2D(sampler_fluid, uv).xz*pixelSize;

		gl_FragColor = vec4(0.);

		//starting from a simple Turing pattern in red

		float centerFilter = smoothcircle(uv, aspect, 0.25, 128.);
		float zoom = 1.;// 0.999;
		float w = 0.;
		vec2 w2 = vec2(cos(w),sin(w));
		vec2 c = vec2(0.5);
		vec2 uvr = c + complex_mul((uv - c)*zoom, w2) + noise*pixelSize*0. - f;
		uvr +=  gradient(sampler_blur5, uv, pixelSize*64., vec4(0.,6.2,0.,0.))*pixelSize;
		//	uvr +=  rot90(gradient(sampler_blur5, uv, pixelSize*32., vec4(0.,4.,0.,0.)))*pixelSize;
		uvr +=  gradient(sampler_blur2, uv, pixelSize*4., vec4(-2.,0.,0.,0.))*pixelSize;

		uvr = vortex_pair_warp(uv, mouse, mouseV*pixelSize/scale*2.*aspect) - f;

		gl_FragColor.r = texture2D(sampler_prev, uvr + gradient(sampler_blur2, uv, pixelSize*8., vec4(-8.,0.,8.,0.))*pixelSize + rot90(gradient(sampler_blur, uv, pixelSize*4., vec4(-0,0.,16.,0.)))*pixelSize).r;
		gl_FragColor.r += (texture2D(sampler_blur2, uv).r - texture2D(sampler_blur4, uvr).r)*24./256. + 2.5/256. + noise*0.5/256.;

		// then there's the particle projection that's added to the green

		gl_FragColor.g = texture2D(sampler_prev, uvr + gradient(sampler_blur, uv, pixelSize*4., vec4(0.,-2.,-48.*texture2D(sampler_blur2,uv).b,0.))*pixelSize).g ;
		gl_FragColor.g += (texture2D(sampler_blur, uv).g - texture2D(sampler_blur2, uvr).g)*32./256. + 0./256.+ 5./256.*(texture2D(sampler_blur2, uv).b - 0.5) + noise*0./256.;

		gl_FragColor.b = texture2D(sampler_prev, uvr + gradient(sampler_blur, uv, pixelSize*3., vec4(0.,0.,4.,0.))*pixelSize).b;
		gl_FragColor.b += (texture2D(sampler_prev, uv).b - texture2D(sampler_blur, uvr).b)*10./256. - 1./256. + noise*1./256.;

		gl_FragColor = clamp(gl_FragColor, 0., 1.);
		gl_FragColor.a = 1.;
		}
	</script>

	<script id="shader-fs-blur-horizontal" type="x-shader/x-fragment">
		// original shader from http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
		// horizontal blur fragment shader
		uniform sampler2D src_tex;

		void main(void) // fragment
		{
		float h = pixelSize.x;
		vec4 sum = vec4(0.0);
		sum += texture2D(src_tex, vec2(uv.x - 4.0*h, uv.y) ) * 0.05;
		sum += texture2D(src_tex, vec2(uv.x - 3.0*h, uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x - 2.0*h, uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x - 1.0*h, uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x + 0.0*h, uv.y) ) * 0.16;
		sum += texture2D(src_tex, vec2(uv.x + 1.0*h, uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x + 2.0*h, uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x + 3.0*h, uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x + 4.0*h, uv.y) ) * 0.05;
		gl_FragColor.xyz = sum.xyz/0.98; // normalize
		gl_FragColor.a = 1.;
		}
	</script>

	<script id="shader-fs-blur-vertical" type="x-shader/x-fragment">
		uniform sampler2D src_tex;

		void main(void) // fragment
		{
		float v = pixelSize.y;
		vec4 sum = vec4(0.0);
		sum += texture2D(src_tex, vec2(uv.x, - 4.0*v + uv.y) ) * 0.05;
		sum += texture2D(src_tex, vec2(uv.x, - 3.0*v + uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x, - 2.0*v + uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x, - 1.0*v + uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x, + 0.0*v + uv.y) ) * 0.16;
		sum += texture2D(src_tex, vec2(uv.x, + 1.0*v + uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x, + 2.0*v + uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x, + 3.0*v + uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x, + 4.0*v + uv.y) ) * 0.05;
		gl_FragColor.xyz = sum.xyz/0.98;
		gl_FragColor.a = 1.;
		}
	</script>

	<script id="shader-fs-add-mouse-motion" type="x-shader/x-fragment">
		uniform sampler2D sampler_fluid;
		uniform vec2 mouse; // mouse coordinate
		uniform vec2 mouseV; // mouse velocity
		void main(void){
		vec2 v = texture2D(sampler_fluid, uv).xz;
		if(length(mouseV) > 0.){
		v = mix(v, mouseV*2., filter(uv, mouse)*0.85);
		}
		float scale = 8.;
		// first person left hand
		if(length(mover0.zw) > 0.){
		v = mix(v, mover0.zw*scale*texSize, filter(uv, mover0.xy)*0.85);
		}
		// first person right hand
		if(length(mover1.zw) > 0.){
		v = mix(v, mover1.zw*scale*texSize, filter(uv, mover1.xy)*0.85);
		}

		// second person left hand
		if(length(mover2.zw) > 0.){
		v = mix(v, mover2.zw*scale*texSize, filter(uv, mover2.xy)*0.85);
		}
		// second person right hand
		if(length(mover3.zw) > 0.){
		v = mix(v, mover3.zw*scale*texSize, filter(uv, mover3.xy)*0.85);
		}
		// third person left hand
		if(length(mover4.zw) > 0.){
		v = mix(v, mover4.zw*scale*texSize, filter(uv, mover4.xy)*0.85);
		}
		// third person right hand
		if(length(mover5.zw) > 0.){
		v = mix(v, mover5.zw*scale*texSize, filter(uv, mover5.xy)*0.85);
		}
		// 4th person left hand
		if(length(mover6.zw) > 0.){
		v = mix(v, mover6.zw*scale*texSize, filter(uv, mover6.xy)*0.85);
		}
		// 4th person right hand
		if(length(mover7.zw) > 0.){
		v = mix(v, mover7.zw*scale*texSize, filter(uv, mover7.xy)*0.85);
		}

		gl_FragColor.xz = v;
		}
	</script>

	<script id="shader-fs-advect" type="x-shader/x-fragment">

		uniform sampler2D sampler_fluid;

		const float dt = .0005;

		void main(void){
		vec2 v = texture2D(sampler_fluid, uv).xz;

		vec2 D = -texSize*vec2(v.x, v.y)*dt;

		vec2 Df = floor(D),   Dd = D - Df;
		vec2 uv = uv + Df*pixelSize;

		vec2 uv0, uv1, uv2, uv3;

		uv0 = uv + pixelSize*vec2(0.,0.);
		uv1 = uv + pixelSize*vec2(1.,0.);
		uv2 = uv + pixelSize*vec2(0.,1.);
		uv3 = uv + pixelSize*vec2(1.,1.);

		vec2 v0 = texture2D(sampler_fluid, uv0).xz;
		vec2 v1 = texture2D(sampler_fluid, uv1).xz;
		vec2 v2 = texture2D(sampler_fluid, uv2).xz;
		vec2 v3 = texture2D(sampler_fluid, uv3).xz;

		v = mix( mix( v0, v1, Dd.x), mix( v2, v3, Dd.x), Dd.y);

		gl_FragColor.xz = v*(1.-border(uv, 1., texSize));
		}

	</script>

	<script id="shader-fs-p" type="x-shader/x-fragment">
		uniform sampler2D sampler_v;
		uniform sampler2D sampler_p;
		const float h = 1./1024.;

		void main(void){

		vec2 v = texture2D(sampler_v, uv).xz;
		float v_x = texture2D(sampler_v, uv - vec2(1.,0.)*pixelSize).r;
		float v_y = texture2D(sampler_v, uv - vec2(0.,1.)*pixelSize).b;

		float n = texture2D(sampler_p, uv- pixelSize*vec2(0.,1.)).r;
		float w = texture2D(sampler_p, uv + pixelSize*vec2(1.,0.)).r;
		float s = texture2D(sampler_p, uv + pixelSize*vec2(0.,1.)).r;
		float e = texture2D(sampler_p, uv - pixelSize*vec2(1.,0.)).r;

		float p = ( n + w + s + e - (v.x - v_x + v.y - v_y)*h ) * .25;

		gl_FragColor.r = p;
		gl_FragColor.ba = vec2(0.); // unused
		}
	</script>

	<script id="shader-fs-div" type="x-shader/x-fragment">
		uniform sampler2D sampler_v;
		uniform sampler2D sampler_p;

		void main(void){
		float p = texture2D(sampler_p, uv).r;
		vec2 v = texture2D(sampler_v, uv).xz;
		float p_x = texture2D(sampler_p, uv + vec2(1.,0.)*pixelSize).r;
		float p_y = texture2D(sampler_p, uv + vec2(0.,1.)*pixelSize).r;

		v -= (vec2(p_x, p_y)-p)*512.;

		gl_FragColor.xz = v;
		}
	</script>

	<script type="x-shader/x-vertex" id="shader-particle-renderer-vs">
		attribute vec2 uv; // particle position lookup vector
		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_particles; // particle positions in a float texture
		uniform vec2 mouse;

		uniform vec2 pixelSize;

		vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
		vec4 dX = 0.5*texture2D(sampler, uv + vec2(1.,0.)*d) - 0.5*texture2D(sampler, uv - vec2(1.,0.)*d);
		vec4 dY = 0.5*texture2D(sampler, uv + vec2(0.,1.)*d) - 0.5*texture2D(sampler, uv - vec2(0.,1.)*d);
		return vec2( dot(dX, selector), dot(dY, selector) );
		}

		void main() {
		gl_Position = (texture2D(sampler_particles, uv) - 0.5)*2.; // pass em flat
		//	gl_Position.xy += gradient(sampler_blur, gl_Position.xy*0.5+0.5, pixelSize*3., vec4(1,-0.,0,0))*pixelSize*32.;

		gl_Position.zw = vec2(0,1);
		gl_PointSize = 4.;
		}
	</script>
	<script type="x-shader/x-fragment" id="shader-particle-renderer-fs">
		void main() {
		gl_FragColor = vec4(1.0, 0.1, 0.025, 0.05);
		}
	</script>

	<script type="text/javascript">
		var toHalf = (function () {
			var floatView = new Float32Array(1);
			var int32View = new Int32Array(floatView.buffer);

			return function toHalf(fval) {
				floatView[0] = fval;
				var fbits = int32View[0];
				var sign = (fbits >> 16) & 0x8000;
				var val = (fbits & 0x7fffffff) + 0x1000;
				if (val >= 0x47800000) {
					if ((fbits & 0x7fffffff) >= 0x47800000) {
						if (val < 0x7f800000) {
							return sign | 0x7c00;
						}
						return sign | 0x7c00 |
								(fbits & 0x007fffff) >> 13;
					}
					return sign | 0x7bff;
				}
				if (val >= 0x38800000) {
					return sign | val - 0x38000000 >> 13;
				}
				if (val < 0x33000000) {
					return sign;
				}
				val = (fbits & 0x7fffffff) >> 23;
				return sign | ((fbits & 0x7fffff | 0x800000)
						 + (0x800000 >>> val - 102)
						 >> 126 - val);
			};
		}());

		function getShader(gl, id, addInc) {
			if (addInc == undefined) {
				addInc = true;
			}
			var shaderScript = document.getElementById(id);
			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					str += k.textContent;
				k = k.nextSibling;
			}

			var fsIncScript = document.getElementById("shader-fs-inc");
			var incStr = "";
			k = fsIncScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					incStr += k.textContent;
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				if (addInc) {
					str = incStr + str;
				}
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex")
				shader = gl.createShader(gl.VERTEX_SHADER);
			else
				return null;
			gl.shaderSource(shader, str);
			gl.compileShader(shader);
			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
				alert("error compiling shader '" + id + "'\n\n" + gl.getShaderInfoLog(shader));
			return shader;
		}

		window.requestAnimFrame = (function () {
			return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame
					|| window.msRequestAnimationFrame || function (callback) {
						window.setTimeout(callback, 1000 / desiredFramerate);
					};
		})();

		var gl;
		var ext;

		var prog_copy;
		var prog_advance;
		var prog_composite;
		var prog_blur_horizontal;
		var prog_blur_vertical;
		var prog_black;
		var prog_fluid_add_mouse_motion;
		var prog_fluid_advect;
		var prog_fluid_p;
		var prog_fluid_div;
		var prog_move_particles;
		var prog_render_particles;
		var prog_shape;
		var prog_patch;

		var FBO_main;
		var FBO_main2;
		var FBO_noise;
		var FBO_blur;
		var FBO_blur2;
		var FBO_blur3;
		var FBO_blur4;
		var FBO_blur5;
		var FBO_blur6;
		var FBO_helper;
		var FBO_helper2;
		var FBO_helper3;
		var FBO_helper4;
		var FBO_helper5;
		var FBO_helper6;
		var FBO_fluid_v;
		var FBO_fluid_p;
		var FBO_fluid_store;
		var FBO_fluid_backbuffer;
		var FBO_particles; // particle positions in a texture
		var FBO_particles2; // double buffer
		var FBO_particle_projection; // particle render target for projection feedback effects
		var FBO_skeletons;

		var texture_main_n; // main, nearest pixel
		var texture_main_l; // main, linear interpolated access on the same buffer
		var texture_main2_n; // main double buffer, nearest
		var texture_main2_l; // main double buffer, linear
		var texture_blur; // full resolution blur result
		var texture_blur2; // double blur
		var texture_blur3; // quad blur
		var texture_blur4; // use low resolutions wisely ;)
		var texture_blur5;
		var texture_blur6;
		var texture_helper; // needed for multi-pass shader programs (2-pass Gaussian blur)
		var texture_helper2; // (1/4 resolution )
		var texture_helper3; // (1/16 resolution )
		var texture_helper4; // (1/256 resolution )
		var texture_helper5;
		var texture_helper6;
		var texture_noise_n; // nearest pixel access
		var texture_noise_l; // linear interpolated
		var texture_fluid_v; // velocities
		var texture_fluid_p; // pressure
		var texture_fluid_store;
		var texture_fluid_backbuffer;
		var texture_particles;
		var texture_particles2;
		var texture_particle_projection;
		var texture_skeletons;

		// main texture loop dimensions
		var sizeX = 1024; // must be powers of 2
		var sizeY = 512;
		var viewX = sizeX; // viewport size (ideally exactly the texture size)
		var viewY = sizeY;

		// particle positions will be stored in a texture of that size
		var particlesWidth = 1024;
		var particlesHeight = 512;
		var particleCount = particlesWidth * particlesHeight; // can also be set to lower than particlesWidth * particlesHeight

		var useParticles = false;
		var useProjectionFeedback = false; // rendering half a million points can slow things down significantly, don't render to texture if not needed
		var useFluidSimulation = true; // the textures will be initialized anyway
		var simScale = 16; // for better performance, the fluid simulation will be calculated for cells this times bigger than the main texture's pixels (powers of 2)
		var maxGaussianBlurLevelUsed = 4; // not yet implemented, but doesn't cost much either. ;)

		var desiredFramerate = 100; // more like a limit
		var startFullpage = true;
		var renderParticlesOnly = false;

		var alwaysUseFlush = true; // experimental setting to toggle finite time execution forces (false was ok on Win7 here, but glitches on MacOS X)

		// don't change vars below
		var aspectx = 1;
		var aspecty = 1;
		var frame = 0; // frame counter to be resetted every 1000ms
		var framecount = 0; // not resetted
		var mainBufferToggle = 1;
		var halted = false;
		var fps, fpsDisplayUpdateTimer;
		var time, starttime = new Date().getTime();
		var isFullScreen = false; // must be user requested initially

		var mouseX = 0.5;
		var mouseY = 0.5;
		var oldMouseX = 0;
		var oldMouseY = 0;
		var mouseDx = 0;
		var mouseDy = 0;

		var pendulum; // TODO: remove again?

		// geometry
		var particleBuffer, squareBuffer;

		function updateApectRatio() {
			aspectx = Math.max(1, viewX / viewY);
			aspecty = Math.max(1, viewY / viewX);
		}

		function load() {
			clearInterval(fpsDisplayUpdateTimer);
			var c = document.getElementById("c");
			try {
				gl = c.getContext("webgl", {
					depth: false
				});
			} catch (e) {
			}
			if (!gl) {
				alert("Meh! Y u no support experimental WebGL !?!");
				return;
			}

			["OES_texture_half_float", "OES_standard_derivatives", "OES_texture_half_float_linear"].forEach(function (name) {
				console.log("check " + name);
				try {
					ext = gl.getExtension(name);
					gl[name] = ext;
				} catch (e) {
					alert(e);
				}
				if (!ext) {
					alert("Meh! Y u no support " + name + " !?!");
					return;
				}
				ext = false;
			});

			if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0) {
				alert("Meh! Y u no support vertex shader textures !?!");
				return;
			}

			document.onmousemove = function (evt) {
				mouseX = evt.pageX / viewX;
				mouseY = 1 - evt.pageY / viewY;
			};

			document.addEventListener("orientationchange", window.onresize = function () {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
				c.width = viewX;
				c.height = viewY;
				updateApectRatio();
			});

			document.addEventListener('touchstart', onmousedown = function (p) {
				if (p.touches) {
				}
			});

			document.addEventListener('touchend', onmouseup = function () {
			});

			document.addEventListener('touchmove', gofullscreen = function (p) {
				if (!isFullScreen) {
					var requestFullScreen = document.body.requestFullScreen || document.body.webkitRequestFullScreen || document.body.mozRequestFullScreen || document.body.msRequestFullscreen;
					if (requestFullScreen) {
						requestFullScreen.call(document.body);
						viewX = window.innerWidth;
						viewY = window.innerHeight;
						c.width = viewX;
						c.height = viewY;
						updateApectRatio();
					}
				}
				p.preventDefault();
				document.onmousemove(p.touches[0]);
			});

			viewX = window.innerWidth;
			viewY = window.innerHeight;

			c.width = viewX;
			c.height = viewY;
			updateApectRatio();
			prog_copy = createAndLinkProgram("shader-fs-copy");
			prog_advance = createAndLinkProgram("shader-fs-advance");
			prog_composite = createAndLinkProgram("shader-fs-composite");
			prog_blur_horizontal = createAndLinkProgram("shader-fs-blur-horizontal");
			prog_blur_vertical = createAndLinkProgram("shader-fs-blur-vertical");
			prog_black = createAndLinkProgram("shader-fs-init");
			prog_fluid_add_mouse_motion = createAndLinkProgram("shader-fs-add-mouse-motion");
			prog_fluid_advect = createAndLinkProgram("shader-fs-advect");
			prog_fluid_p = createAndLinkProgram("shader-fs-p");
			prog_fluid_div = createAndLinkProgram("shader-fs-div");
			prog_move_particles = createAndLinkProgram("shader-fs-move-particles");
			prog_shape = createAndLinkProgram("shader-fs-shape", "shader-vs-shape");
			prog_patch = createAndLinkProgram("shader-fs-patch", "shader-vs-patch");

			triangleStripGeometry = {
				vertices: new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]),
				texCoords: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
				vertexSize: 3,
				vertexCount: 4,
				type: gl.TRIANGLE_STRIP
			};

			createTexturedGeometryBuffer(triangleStripGeometry);

			squareBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer);

			var aPosLoc = gl.getAttribLocation(prog_advance, "aPos");
			var aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");

			gl.enableVertexAttribArray(aPosLoc);
			gl.enableVertexAttribArray(aTexLoc);

			var verticesAndTexCoords = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1, // one square of a quad!
			0, 0, 1, 0, 0, 1, 1, 1] // hello texture, you be full
			);

			gl.bufferData(gl.ARRAY_BUFFER, verticesAndTexCoords, gl.STATIC_DRAW);
			gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 8, 0);
			gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 8, 32);

			var noisePixels = [], pixels = [], simpixels = [], pixels2 = [], pixels3 = [], pixels4 = [], pixels5 = [], pixels6 = [], particles = [], particlesIdx = [];
			var dX = 1 / particlesWidth;
			var dY = 1 / particlesHeight;
			for (var j = 0; j < sizeY; j++) {
				for (var i = 0; i < sizeX; i++) {
					noisePixels.push(toHalf(Math.random()), toHalf(Math.random()), toHalf(Math.random()), 1);
					//noisePixels.push(14336, 14336, 14336, 15360);
					pixels.push(0, 0, 0, 1);
					if (i < sizeX / simScale && j < sizeY / simScale)
						simpixels.push(0, 0, 0, 1);
					if (i < sizeX / 2 && j < sizeY / 2)
						pixels2.push(0, 0, 0, 1);
					if (i < sizeX / 4 && j < sizeY / 4)
						pixels3.push(0, 0, 0, 1);
					if (i < sizeX / 8 && j < sizeY / 8)
						pixels4.push(0, 0, 0, 1);
					if (i < sizeX / 16 && j < sizeY / 16)
						pixels5.push(0, 0, 0, 1);
					if (i < sizeX / 32 && j < sizeY / 32)
						pixels6.push(0, 0, 0, 1);
					if (i < particlesWidth && j < particlesHeight) {
						particles.push(toHalf(dX / 2 + i * dX), toHalf(dY / 2 + j * dY), toHalf(0), toHalf(0)); // initial particle positions, here: uniform distribution
					}
				}
			}

			for (var i = 0; i < particlesHeight; i++) {
				for (var j = 0; j < particlesWidth; j++) {
					particlesIdx.push(dX / 2 + j * dX, dY / 2 + i * dY); // coordinate lookup vectors (center of pixels)
				}
			}

			FBO_main = gl.createFramebuffer();
			FBO_main2 = gl.createFramebuffer();
			var glPixels;
			glPixels = new Uint16Array(noisePixels);
			texture_main_n = createAndBindTexture(glPixels, 1, FBO_main, gl.NEAREST);
			texture_main2_n = createAndBindTexture(glPixels, 1, FBO_main2, gl.NEAREST);
			glPixels = new Uint16Array(noisePixels);
			texture_main_l = createAndBindTexture(glPixels, 1, FBO_main, gl.LINEAR);
			texture_main2_l = createAndBindTexture(glPixels, 1, FBO_main2, gl.LINEAR);

			FBO_fluid_p = gl.createFramebuffer();
			FBO_fluid_v = gl.createFramebuffer();
			FBO_fluid_store = gl.createFramebuffer();
			FBO_fluid_backbuffer = gl.createFramebuffer();
			texture_fluid_v = createAndBindSimulationTexture(new Uint16Array(simpixels), FBO_fluid_v);
			texture_fluid_p = createAndBindSimulationTexture(new Uint16Array(simpixels), FBO_fluid_p);
			texture_fluid_store = createAndBindSimulationTexture(new Uint16Array(simpixels), FBO_fluid_store);
			texture_fluid_backbuffer = createAndBindSimulationTexture(new Uint16Array(simpixels), FBO_fluid_backbuffer);

			FBO_particle_projection = gl.createFramebuffer();
			texture_particle_projection = createAndBindTexture(new Uint16Array(pixels), 1, FBO_particle_projection, gl.LINEAR);

			FBO_helper = gl.createFramebuffer();
			FBO_helper2 = gl.createFramebuffer();
			FBO_helper3 = gl.createFramebuffer();
			FBO_helper4 = gl.createFramebuffer();
			FBO_helper5 = gl.createFramebuffer();
			FBO_helper6 = gl.createFramebuffer();
			texture_helper = createAndBindTexture(new Uint16Array(pixels), 1, FBO_helper, gl.NEAREST); // helper buffers for the two-pass Gaussian blur calculation basically
			texture_helper2 = createAndBindTexture(new Uint16Array(pixels2), 2, FBO_helper2, gl.NEAREST);
			texture_helper3 = createAndBindTexture(new Uint16Array(pixels3), 4, FBO_helper3, gl.NEAREST);
			texture_helper4 = createAndBindTexture(new Uint16Array(pixels4), 8, FBO_helper4, gl.NEAREST);
			texture_helper5 = createAndBindTexture(new Uint16Array(pixels5), 16, FBO_helper5, gl.NEAREST);
			texture_helper6 = createAndBindTexture(new Uint16Array(pixels6), 32, FBO_helper6, gl.NEAREST);

			FBO_blur = gl.createFramebuffer();
			FBO_blur2 = gl.createFramebuffer();
			FBO_blur3 = gl.createFramebuffer();
			FBO_blur4 = gl.createFramebuffer();
			FBO_blur5 = gl.createFramebuffer();
			FBO_blur6 = gl.createFramebuffer();
			texture_blur = createAndBindTexture(new Uint16Array(pixels), 1, FBO_blur, gl.LINEAR);
			texture_blur2 = createAndBindTexture(new Uint16Array(pixels2), 2, FBO_blur2, gl.LINEAR);
			texture_blur3 = createAndBindTexture(new Uint16Array(pixels3), 4, FBO_blur3, gl.LINEAR);
			texture_blur4 = createAndBindTexture(new Uint16Array(pixels4), 8, FBO_blur4, gl.LINEAR);
			texture_blur5 = createAndBindTexture(new Uint16Array(pixels5), 16, FBO_blur5, gl.LINEAR);
			texture_blur6 = createAndBindTexture(new Uint16Array(pixels6), 32, FBO_blur6, gl.LINEAR);

			FBO_skeletons = gl.createFramebuffer();
			texture_skeletons = createAndBindTexture(null, 1, FBO_skeletons, gl.NEAREST); // use blocky nearest pixel view

			FBO_noise = gl.createFramebuffer();
			glPixels = new Uint16Array(noisePixels);
			texture_noise_n = createAndBindTexture(glPixels, 1, FBO_noise, gl.NEAREST);
			texture_noise_l = createAndBindTexture(glPixels, 1, FBO_noise, gl.LINEAR);

			FBO_particles = gl.createFramebuffer();
			texture_particles = createAndBindParticleTexture(new Uint16Array(particles), FBO_particles);

			FBO_particles2 = gl.createFramebuffer();
			texture_particles2 = createAndBindParticleTexture(new Uint16Array(particles), FBO_particles2);

			// lesson learned: the (frame) buffer location that we pass to the vertex shader has to be bound to the program before linking!

			var aParticleLoc = 2; // no getAttributeLoc
			prog_render_particles = createAndLinkParticleRenderer(aParticleLoc);

			gl.useProgram(prog_render_particles);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 0);

			gl.enableVertexAttribArray(aParticleLoc);
			particleBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particlesIdx), gl.STATIC_DRAW);
			gl.vertexAttribPointer(aParticleLoc, 2, gl.FLOAT, false, 0, 0);

			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur);
			gl.activeTexture(gl.TEXTURE3);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur2);
			gl.activeTexture(gl.TEXTURE4);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur3);
			gl.activeTexture(gl.TEXTURE5);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur4);
			gl.activeTexture(gl.TEXTURE6);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur5);
			gl.activeTexture(gl.TEXTURE7);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur6);
			gl.activeTexture(gl.TEXTURE8);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_l);
			gl.activeTexture(gl.TEXTURE9);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_n);
			gl.activeTexture(gl.TEXTURE10);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE11);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.activeTexture(gl.TEXTURE12);
			gl.bindTexture(gl.TEXTURE_2D, texture_particles); // to be swapped anyways
			gl.activeTexture(gl.TEXTURE13);
			gl.bindTexture(gl.TEXTURE_2D, texture_particle_projection);
			gl.activeTexture(gl.TEXTURE14);
			gl.bindTexture(gl.TEXTURE_2D, texture_skeletons);

			calculateBlurTexture();

			fluidInit(FBO_fluid_v);
			fluidInit(FBO_fluid_p);
			fluidInit(FBO_fluid_store);
			fluidInit(FBO_fluid_backbuffer);

			fpsDisplayUpdateTimer = setInterval(fr, 1000);
			time = new Date().getTime() - starttime;

			gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			gl.clearColor(0, 0, 0, 1);

			pendulum = new Pendulum();
			streakLength = 80; // number of lights
			historyLength = 16; // number of memorized frames
			pendulum.initStreaks(streakLength, historyLength);
			//pendulum.applyColor = pendulum.patterns["smiley"];
			//pendulum.applyColor = pendulum.createTextPatternFn("www.cake23.de +++ www.hack-hro.de +++ www.warnow-valley.de +++ ");
			//pendulum.applyColor = pendulum.createTextPatternFn("                        PERSISTENCE OF VISION",0.5);
			//pendulum.applyColor = pendulum.createTextPatternFn("CAKE23    POI TOY    ", 0.04);
			pendulum.applyColor = pendulum.createTextPatternFn("WARNOW VALLEY  ", 0.033);
			pendulum.applyColor = pendulum.createTextPatternFn("HACKSPACE HRO  ", 0.033);
			pendulum.applyColor = pendulum.createTextPatternFn("PERSISTENCE OF VISION Of ", 0.0001);
			//pendulum.applyColor = pendulum.patterns["compartments"];
			pendulum.applyColor = pendulum.patterns["transparent"];

			initFishes();

			anim();
		}

		function createTexturedGeometryBuffer(geometry) {
			geometry.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			geometry.aPosLoc = gl.getAttribLocation(prog_advance, "aPos"); // we could take any program here, they all use the same vertex shader
			gl.enableVertexAttribArray(geometry.aPosLoc);
			geometry.aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");
			gl.enableVertexAttribArray(geometry.aTexLoc);
			geometry.texCoordOffset = geometry.vertices.byteLength;
			gl.bufferData(gl.ARRAY_BUFFER, geometry.texCoordOffset + geometry.texCoords.byteLength, gl.STATIC_DRAW);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, geometry.vertices);
			gl.bufferSubData(gl.ARRAY_BUFFER, geometry.texCoordOffset, geometry.texCoords);
			setGeometryVertexAttribPointers(geometry);
		}

		function setGeometryVertexAttribPointers(geometry) {
			gl.vertexAttribPointer(geometry.aPosLoc, geometry.vertexSize, gl.FLOAT, gl.FALSE, 0, 0);
			gl.vertexAttribPointer(geometry.aTexLoc, 2, gl.FLOAT, gl.FALSE, 0, geometry.texCoordOffset);
		}

		function createAndLinkProgram(fsId, vsId) {
			if (vsId == undefined) {
				vsId = "shader-vs";
			}
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, vsId));
			gl.attachShader(program, getShader(gl, fsId));
			gl.linkProgram(program);
			var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
			if (!linked) {
				alert("error linking program " + fsId + ": " + gl.getProgramInfoLog(program));
			}
			return program;
		}

		function createAndLinkParticleRenderer(aParticleLoc) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-vs"));
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-fs", false));
			gl.bindAttribLocation(program, aParticleLoc, "uv"); // can't use getAttribLocation later so we must bind before linking
			gl.linkProgram(program);
			return program;
		}

		function createAndBindTexture(glPixels, scale, fbo, filter) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / scale, sizeY / scale, 0, gl.RGBA, gl.OES_texture_half_float.HALF_FLOAT_OES, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindParticleTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, particlesWidth, particlesHeight, 0, gl.RGBA, gl.OES_texture_half_float.HALF_FLOAT_OES, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindSimulationTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / simScale, sizeY / simScale, 0, gl.RGBA, gl.OES_texture_half_float.HALF_FLOAT_OES, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function blacken(fbo) {
			gl.viewport(0, 0, sizeX, sizeY);
			gl.useProgram(prog_black);
			renderAsTriangleStrip(fbo);
		}

		function fluidInit(fbo) {
			gl.viewport(0, 0, sizeX / simScale, sizeY / simScale);
			gl.useProgram(prog_black);
			renderAsTriangleStrip(fbo);
		}

		function setUniforms(program) {
			gl.uniform4f(gl.getUniformLocation(program, "rnd"), Math.random(), Math.random(), Math.random(), Math.random());
			gl.uniform4f(gl.getUniformLocation(program, "rainbow"), rainbowR, rainbowG, rainbowB, 1);
			gl.uniform2f(gl.getUniformLocation(program, "texSize"), sizeX, sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(program, "scale"), viewX / sizeX, viewY / sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(program, "mouseV"), mouseDx, mouseDy);
			gl.uniform1f(gl.getUniformLocation(program, "fps"), fps);
			gl.uniform1f(gl.getUniformLocation(program, "time"), time);
			gl.uniform1f(gl.getUniformLocation(program, "frame"), framecount);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur"), 2);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur2"), 3);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur3"), 4);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur4"), 5);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur5"), 6);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur6"), 7);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise"), 8);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise_n"), 9);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid"), 10);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid_p"), 11);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particles"), 12);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particle_projection"), 13);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_skeletons"), 14);

			gl.uniform4f(gl.getUniformLocation(program, "midifader1"), getMidi(0), getMidi(1), getMidi(2), getMidi(3));
			gl.uniform4f(gl.getUniformLocation(program, "midifader2"), getMidi(4), getMidi(5), getMidi(6), getMidi(7));
			gl.uniform4f(gl.getUniformLocation(program, "midiknob1"), getMidi(16), getMidi(17), getMidi(18), getMidi(19));
			gl.uniform4f(gl.getUniformLocation(program, "midiknob2"), getMidi(20), getMidi(21), getMidi(22), getMidi(23));

			// we used to wire up Ableton to pipe fader values from an orbitkontrol via osc
			if (osc['/fad']) {
				var fad = osc['/fad'];
				gl.uniform4f(gl.getUniformLocation(program, "fader"), fad[0], fad[1], fad[2], 1);
			} else {
				gl.uniform4f(gl.getUniformLocation(program, "fader"), 1, 1, 1, 1);
			}

			setMoverUniforms(program);
		}

		function setMoverUniforms(program) {
			// push it
			var moverIndex = 0;
			var bodyIndex = 0;
			// project it
			var p3d = {};
			var p2d = {};
			activeTrackingObjects.forEach(function (trackingObject) {
				var skeleton = trackingObject.skeleton;
				var body = trackingObject.body;
				var x = 0.5 + (skeleton.joints['Head'].x - 0.5) * 0.5;
				var y = 0.5 + (skeleton.joints['Head'].y - 0.5) * 0.5;
				gl.uniform2f(gl.getUniformLocation(program, "head" + bodyIndex), x, y);
				var col = colors[bodyIndex];
				gl.uniform4f(gl.getUniformLocation(program, "col" + bodyIndex), col[0], col[1], col[2], 1);
				bodyIndex++;
				// left hand
				project(skeleton.handLeft, p2d); // current projection
				var x = 0.5 + (p2d.x - 0.5) * 0.5;
				var y = 0.5 - (p2d.y - 0.5) * 0.5;
				project(skeleton.handLeft.old, p2d); // previous projection
				var prevX = 0.5 + (p2d.x - 0.5) * 0.5;
				var prevY = 0.5 - (p2d.y - 0.5) * 0.5;
				var dx = (x - prevX); // difference = velocity
				var dy = (y - prevY);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				var state = body.handLeft.state;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), x, y, dx, dy);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), state);
				// left pendulum endpoint
				var pendulum = trackingObject.skeleton.handLeft.pendulum;
				project(pendulum.points[3], p2d)
				x = 0.5 + (p2d.x - 0.5) * 0.5;
				y = 0.5 + (p2d.y - 0.5) * 0.5;
				var framesSinceLastRender = pendulum.frame - pendulum.lastRenderFrame;
				var oldEndpoint = pendulum.endpointHistory[framesSinceLastRender];
				if (oldEndpoint != null) {
					project(oldEndpoint, p2d);
					prevX = 0.5 + (p2d.x - 0.5) * 0.5;
					prevY = 0.5 + (p2d.y - 0.5) * 0.5;
					dx = (x - prevX);
					dy = (y - prevY);
				} else {
					// occurs only on the very first frame ^^
					dx = 0;
					dy = 0;
				}
				//gl.uniform4f(gl.getUniformLocation(program, "pendulum" + moverIndex), x, 1 - y, dx, -dy);
				moverIndex++;
				// right hand
				project(skeleton.handRight, p2d);
				x = 0.5 + (p2d.x - 0.5) * 0.5;
				y = 0.5 - (p2d.y - 0.5) * 0.5;
				project(skeleton.handRight.old, p2d);
				prevX = 0.5 + (p2d.x - 0.5) * 0.5;
				prevY = 0.5 - (p2d.y - 0.5) * 0.5;
				dx = (x - prevX);
				dy = (y - prevY);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				state = body.handRight.state;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), x, y, dx, dy);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), state);
				var pendulum = trackingObject.skeleton.handRight.pendulum;
				project(pendulum.points[3], p2d)
				x = 0.5 + (p2d.x - 0.5) * 0.5;
				y = 0.5 + (p2d.y - 0.5) * 0.5;
				var framesSinceLastRender = pendulum.frame - pendulum.lastRenderFrame;
				var oldEndpoint = pendulum.endpointHistory[framesSinceLastRender];
				if (oldEndpoint != null) {
					project(oldEndpoint, p2d);
					prevX = 0.5 + (p2d.x - 0.5) * 0.5;
					prevY = 0.5 + (p2d.y - 0.5) * 0.5;
					dx = (x - prevX);
					dy = (y - prevY);
				} else {
					dx = 0;
					dy = 0;
				}
				gl.uniform4f(gl.getUniformLocation(program, "pendulum" + moverIndex), x, 1 - y, dx, -dy);
				moverIndex++;
			});
			// init untracked players
			for (var index = moverIndex; index < 12; index++) {
				gl.uniform4f(gl.getUniformLocation(program, "col" + bodyIndex), 0, 0, 0, 0);
				bodyIndex++;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), 0);
				gl.uniform4f(gl.getUniformLocation(program, "pendulum" + moverIndex), 0, 0, 0, 0);
				moverIndex++;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), 0);
				gl.uniform4f(gl.getUniformLocation(program, "pendulum" + moverIndex), 0, 0, 0, 0);
				moverIndex++
			}
		}

		function useGeometry(geometry) {
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			setGeometryVertexAttribPointers(geometry);
		}

		function renderGeometry(geometry, targetFBO) {
			useGeometry(geometry);
			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.drawArrays(geometry.type, 0, geometry.vertexCount);
			if (alwaysUseFlush)
				gl.flush();
		}

		function renderAsTriangleStrip(targetFBO) {
			renderGeometry(triangleStripGeometry, targetFBO);
		}

		function renderParticles(targetFBO) {
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);

			if (targetFBO == null)
				gl.viewport(0, 0, viewX, viewY);
			else
				gl.viewport(0, 0, sizeX, sizeY);

			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.useProgram(prog_render_particles);

			gl.activeTexture(gl.TEXTURE12);
			if (mainBufferToggle < 0) {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
			} else {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
			}

			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 12); // input for the vertex shader
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_blur"), 2);

			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			gl.enable(gl.BLEND);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			gl.drawArrays(gl.POINTS, 0, particleCount);
			gl.disable(gl.BLEND);

			if (alwaysUseFlush)
				gl.flush();
		}

		function renderAsHLines(targetFBO) {
			useGeometry(hLineGeometry);
			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			for (var y = 1; y < sizeY; y++) {
				gl.drawArrays(gl.LINES, y * 2, 2);
				if (alwaysUseFlush)
					gl.flush();
			}
		}

		function renderAsVLines(targetFBO) {
			useGeometry(vLineGeometry);
			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			for (var x = 1; x < sizeX; x++) {
				gl.drawArrays(gl.LINES, x * 2, 2);
				if (alwaysUseFlush)
					gl.flush();
			}
		}

		function calculateBlurTextures(texture_source) {
			calculateBlurTexture(texture_source, texture_blur, FBO_blur, texture_helper, FBO_helper, 1);
			calculateBlurTexture(texture_blur, texture_blur2, FBO_blur2, texture_helper2, FBO_helper2, 2);
			calculateBlurTexture(texture_blur2, texture_blur3, FBO_blur3, texture_helper3, FBO_helper3, 4);
			calculateBlurTexture(texture_blur3, texture_blur4, FBO_blur4, texture_helper4, FBO_helper4, 8);
			calculateBlurTexture(texture_blur4, texture_blur5, FBO_blur5, texture_helper5, FBO_helper5, 16);
			calculateBlurTexture(texture_blur5, texture_blur6, FBO_blur6, texture_helper6, FBO_helper6, 32);
		}

		function calculateBlurTexture(sourceTex, targetTex, targetFBO, helperTex, helperFBO, scale) {
			// copy source
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, sourceTex);
			renderAsTriangleStrip(targetFBO);

			// blur vertically
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_vertical);
			gl.uniform2f(gl.getUniformLocation(prog_blur_vertical, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, targetTex);
			renderAsTriangleStrip(helperFBO);

			// blur horizontally
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_horizontal);
			gl.uniform2f(gl.getUniformLocation(prog_blur_horizontal, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, helperTex);
			renderAsTriangleStrip(targetFBO);

		}

		function stepParticles() {
			gl.viewport(0, 0, particlesWidth, particlesHeight);
			gl.useProgram(prog_move_particles);
			gl.uniform4f(gl.getUniformLocation(prog_move_particles, "rnd"), Math.random(), Math.random(), Math.random(), Math.random());
			gl.uniform1f(gl.getUniformLocation(prog_move_particles, "frame"), framecount);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "texSize"), sizeX, sizeY);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "mouseV"), mouseDx, mouseDy);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(prog_move_particles, "scale"), 2. / simScale / particlesWidth, 2. / simScale / particlesHeight);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur"), 2);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur2"), 3);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur3"), 4);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur4"), 5);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur5"), 6);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_blur6"), 7);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_noise"), 8);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_noise_n"), 9);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_fluid"), 10);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_fluid_p"), 11);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_particles"), 12);
			gl.uniform1i(gl.getUniformLocation(prog_move_particles, "sampler_particle_projection"), 13);
			setMoverUniforms(prog_move_particles);

			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				renderAsTriangleStrip(FBO_particles2)
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				renderAsTriangleStrip(FBO_particles);
			}
		}

		function fluidSimulationStep() {
			addMouseMotion();
			advect();
			diffuse();
		}

		var colors = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1], [0, 1, 1]]; // red green blue yellow magenta cyan
		function addMouseMotion() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_add_mouse_motion);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "aspect"), aspectx, aspecty);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mouseV"), mouseDx / aspectx, mouseDy / aspecty);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "texSize"), (sizeX / simScale), (sizeY / simScale));
			// push it
			var moverIndex = 0;
			var bodyIndex = 0;
			// project it
			var p3d = {};
			var p2d = {};
			activeTrackingObjects.forEach(function (trackingObject) {
				var skeleton = trackingObject.skeleton;
				var body = trackingObject.body;
				project(skeleton.head, p2d);
				var x = 0.5 + (p2d.x - 0.5) * 0.5;
				var y = 0.5 - (p2d.y - 0.5) * 0.5;
				gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "head" + bodyIndex), x, y);
				var col = colors[bodyIndex];
				gl.uniform4f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "col" + bodyIndex), col[0], col[1], col[2], 1);
				bodyIndex++;
				// left hand
				project(skeleton.handLeft, p2d); // current projection
				var x = 0.5 + (p2d.x - 0.5) * 0.5;
				var y = 0.5 - (p2d.y - 0.5) * 0.5;
				project(skeleton.handLeft.old, p2d); // previous projection
				var prevX = 0.5 + (p2d.x - 0.5) * 0.5;
				var prevY = 0.5 - (p2d.y - 0.5) * 0.5;
				var dx = (x - prevX); // difference = velocity
				var dy = (y - prevY);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				var state = body.handLeft.state;
				gl.uniform4f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mover" + moverIndex), x, y, dx, dy);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_add_mouse_motion, "moverState" + moverIndex), state);
				// left pendulum endpoint
				var pendulum = trackingObject.skeleton.handLeft.pendulum;
				project(pendulum.points[3], p2d)
				x = 0.5 + (p2d.x - 0.5) * 0.5;
				y = 0.5 + (p2d.y - 0.5) * 0.5;

				var framesSinceLastRender = pendulum.frame - pendulum.lastRenderFrame;
				var oldEndpoint = pendulum.endpointHistory[framesSinceLastRender];
				if (oldEndpoint != null) {
					project(oldEndpoint, p2d);
					prevX = 0.5 + (p2d.x - 0.5) * 0.5;
					prevY = 0.5 + (p2d.y - 0.5) * 0.5;
					dx = (x - prevX);
					dy = (y - prevY);
				} else {
					// occurs only on the very first frame ^^
					dx = 0;
					dy = 0;
				}
				gl.uniform4f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "pendulum" + moverIndex), x, 1 - y, dx, -dy);
				moverIndex++;
				// right hand
				project(skeleton.handRight, p2d);
				x = 0.5 + (p2d.x - 0.5) * 0.5;
				y = 0.5 - (p2d.y - 0.5) * 0.5;
				project(skeleton.handRight.old, p2d);
				prevX = 0.5 + (p2d.x - 0.5) * 0.5;
				prevY = 0.5 - (p2d.y - 0.5) * 0.5;
				dx = (x - prevX);
				dy = (y - prevY);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				state = body.handRight.state;
				gl.uniform4f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mover" + moverIndex), x, y, dx, dy);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_add_mouse_motion, "moverState" + moverIndex), state);
				var pendulum = trackingObject.skeleton.handRight.pendulum;
				project(pendulum.points[3], p2d)
				x = 0.5 + (p2d.x - 0.5) * 0.5;
				y = 0.5 + (p2d.y - 0.5) * 0.5;
				var framesSinceLastRender = pendulum.frame - pendulum.lastRenderFrame;
				var oldEndpoint = pendulum.endpointHistory[framesSinceLastRender];
				if (oldEndpoint != null) {
					project(oldEndpoint, p2d);
					prevX = 0.5 + (p2d.x - 0.5) * 0.5;
					prevY = 0.5 + (p2d.y - 0.5) * 0.5;
					dx = (x - prevX);
					dy = (y - prevY);
				} else {
					dx = 0;
					dy = 0;
				}
				gl.uniform4f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "pendulum" + moverIndex), x, 1 - y, dx, -dy);
				moverIndex++;
			});
			// init untracked players
			for (var index = moverIndex; index < 12; index++) {
				gl.uniform4f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_add_mouse_motion, "moverState" + moverIndex), 0);
				gl.uniform4f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "pendulum" + moverIndex), 0, 0, 0, 0);
				moverIndex++;
				gl.uniform4f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_add_mouse_motion, "moverState" + moverIndex), 0);
				gl.uniform4f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "pendulum" + moverIndex), 0, 0, 0, 0);
				moverIndex++
			}
			renderAsTriangleStrip(FBO_fluid_backbuffer);
		}


		function advect() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_advect);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "texSize"), (sizeX / simScale), (sizeY / simScale));
			renderAsTriangleStrip(FBO_fluid_v);
		}

		function diffuse() {
			for (var i = 0; i < 8; i++) {
				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_backbuffer);

				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_p);
			}


			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_div);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "texSize"), (sizeX / simScale), (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_v"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_p"), 1);
			renderAsTriangleStrip(FBO_fluid_backbuffer);

			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			renderAsTriangleStrip(FBO_fluid_v);
		}

		// main texture feedback warp
		function advance() {
			gl.viewport(0, 0, sizeX, sizeY);
			gl.useProgram(prog_advance);
			setUniforms(prog_advance);
			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l); // interpolated input
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n); // "nearest" input
				renderAsTriangleStrip(FBO_main2);
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l); // interpolated
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n); // "nearest"
				renderAsTriangleStrip(FBO_main);
			}
			mainBufferToggle = -mainBufferToggle;
		}

		function composite() {
			gl.viewport(0, 0, viewX, viewY);
			gl.useProgram(prog_composite);
			setUniforms(prog_composite);
			if (mainBufferToggle < 0) {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n);
			} else {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n);
			}
			renderAsTriangleStrip(null);
		}

		var rainbowR, rainbowG, rainbowB, w = Math.PI * 2 / 3;

		function anim() {
			setTimeout("requestAnimationFrame(anim)", 1000 / desiredFramerate);

			time = new Date().getTime() - starttime;

			var t = time / 150;

			rainbowR = 0.5 + 0.5 * Math.sin(t);
			rainbowG = 0.5 + 0.5 * Math.sin(t + w);
			rainbowB = 0.5 + 0.5 * Math.sin(t - w);

			if (oldMouseX != 0 && oldMouseY != 0) {
				mouseDx = (mouseX - oldMouseX) * viewX;
				mouseDy = (mouseY - oldMouseY) * viewY;
			}

			if (!halted) {
				blacken(FBO_skeletons);
				updateKinectSkeletons();
				sortOutLostTrackingObjects();
				drawKinectSkeletons(FBO_skeletons);
				drawKinectFaces(FBO_skeletons);

				if (useProjectionFeedback)
					renderParticles(FBO_particle_projection);

				if (useFluidSimulation)
					fluidSimulationStep();

				if (useParticles)
					stepParticles();

				advance();

				var srcTex = (mainBufferToggle < 0) ? texture_main2_l : texture_main_l;

				calculateBlurTextures(srcTex);

				frame++;
				framecount++;
			}

			if (renderParticlesOnly)
				renderParticles(null);
			else
				composite();

			//pendulum.renderSupportPoints(null);
			//pendulum.renderSpringPoints(null);
			var feedback_FBO = (mainBufferToggle > 0) ? FBO_main : FBO_main2;

			//if (activeTrackingObjects.length == 0) {
			//pendulum.renderStrips(feedback_FBO);
			pendulum.renderStrips(null);
			//}

			//drawKinectSkeletons(null);
			drawKinectSkeletonPendulums(null);
			//drawKinectSkeletonPendulums(feedback_FBO);
			//drawKinectFaces(null);

			updateFishes();
			drawFishesOnFBO(null);

			frames++;

			oldMouseX = mouseX;
			oldMouseY = mouseY;

		}

		function fr() { // updates every second
			document.getElementById("fps").textContent = frame;
			frame = 0; // reset the frame counter
		}

		var hidden = false;
		function hide() {
			hidden = !hidden;
			document.getElementById("desc").style.setProperty('visibility', hidden ? 'hidden' : 'visible');
		}

	</script>
	<style type="text/css">
		body {
			/*			position: absolute;
					top: 0;
					left: 0;
		*/ background-color: #000000;
			color: #FFFFFF;
			font-family: 'Lucida Console';
			font-size: 12pt;
		}

		#c {
			position: absolute;
			top: 0;
			left: 0;
			z-index: -1;
		}

		a {
			color: #FFFFFF;
			font-weight: bold;
		}

		#desc {
			background-color: rgba(0, 0, 0, 0.2);
			width: 1024px;
		}
	</style>
</head>
<body onload="load()" ondblclick="hide()">
	<div id="desc">
		50 fish, 24 triangles each, on coupled Turing patterns with a fluid simulation.<br />
		Neither the bouncing circles physics nor the distance sorting are GPU-computed yet.<br />
		The fish acceleration response is only triggered by an impulse at random intervals.<br />
		Each fish here has a list of pointers to its neighbors ordered by distance.<br />
		This is a computational Zen garden for swarm simulation experiments. <br />
		Listening recommendation: <a href="https://soundcloud.com/tippermusic/bubble-control" target="sc">Tipper - Bubble Control</a><p />

		<a href="#" onclick="gofullscreen()">Click here</a> to go fullscreen. Doubleclick to hide this box. <span id="fps"></span>fps.
	</div>
	<canvas id="c"></canvas>
</body>
</html>
