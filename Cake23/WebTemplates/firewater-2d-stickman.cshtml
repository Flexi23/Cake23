<html>
<head>
	<title>Turing pattern + particle projection feedback + blur gradient composite | WebGL GPGPU</title>
	<script src="@(Model.Host.URL)/Scripts/jquery-1.6.4.min.js"></script>
	<script src="@(Model.Host.URL)/Scripts/jquery.signalR-2.2.0.min.js"></script>
	<script src="@(Model.Host.URL)/signalr/hubs"></script>
	<script type="text/javascript">
		$(function () {
			$.connection.hub.url = "@(Model.Host.URL)/signalr"; var kinect = $.connection.kinect2Hub;

			kinect.client.onBody = function (bodyJson, projectionMappedPointsJson) {
				body = JSON.parse(bodyJson);
				// bodysampler = JSON.parse(projectionMappedPointsJson); // this would be the inbuilt mapping of the 3d coordinates to the 1080p video camera
				body.head = {
					x: body.Joints["Head"].Position.X,
					y: body.Joints["Head"].Position.Y,
					z: body.Joints["Head"].Position.Z,
					old: { "x": -1, "y": -1, "z": -1 }
				};
				body.handRight = { old: { "x": -1, "y": -1, "z": -1 }, grab: false, point: false, object: null };
				switch (body.handRight.state = body.HandRightState) {
					case 3:
						body.handRight.grab = true;
						break;
					case 4:
						body.handRight.point = true;
						break;
				}
				body.handRight.id = "hr" + body.TrackingId;
				//if (body.handRight.grab) {
				body.handRight.x = (body.Joints["HandTipRight"].Position.X * 2 + body.Joints["HandRight"].Position.X + body.Joints["ThumbRight"].Position.X * 2) / 5;
				body.handRight.y = (body.Joints["HandTipRight"].Position.Y * 2 + body.Joints["HandRight"].Position.Y + body.Joints["ThumbRight"].Position.Y * 2) / 5;
				body.handRight.z = (body.Joints["HandTipRight"].Position.Z * 2 + body.Joints["HandRight"].Position.Z + body.Joints["ThumbRight"].Position.Z * 2) / 5;
				//} else
				if (body.handRight.point) {
					body.handRight.x = body.Joints["HandTipRight"].Position.X;
					body.handRight.y = body.Joints["HandTipRight"].Position.Y;
					body.handRight.z = body.Joints["HandTipRight"].Position.Z;
				}
				body.handLeft = { old: { "x": -1, "y": -1, "z": -1 }, grab: false, point: false, object: null };
				switch (body.handLeft.state = body.HandLeftState) {
					case 3:
						body.handLeft.grab = true;
						break;
					case 4:
						body.handLeft.point = true;
						break;
				}
				body.handLeft.id = "hl" + body.TrackingId;
				//if (body.handLeft.grab) {
				body.handLeft.x = (body.Joints["HandTipLeft"].Position.X * 2 + body.Joints["HandLeft"].Position.X + body.Joints["ThumbLeft"].Position.X * 2) / 5;
				body.handLeft.y = (body.Joints["HandTipLeft"].Position.Y * 2 + body.Joints["HandLeft"].Position.Y + body.Joints["ThumbLeft"].Position.Y * 2) / 5;
				body.handLeft.z = (body.Joints["HandTipLeft"].Position.Z * 2 + body.Joints["HandLeft"].Position.Z + body.Joints["ThumbLeft"].Position.Z * 2) / 5;
				//} else
				if (body.handLeft.point) {
					body.handLeft.x = body.Joints["HandTipLeft"].Position.X;
					body.handLeft.y = body.Joints["HandTipLeft"].Position.Y;
					body.handLeft.z = body.Joints["HandTipLeft"].Position.Z;
				}
				var trackingObject = getTrackingObject(body.TrackingId);
				if (trackingObject.body == null) {
					trackingObject.body = body;
				} else {
					var oldBody = trackingObject.body;
					body.head.old.x = oldBody.head.x; // collapse?
					body.head.old.y = oldBody.head.y;
					body.head.old.z = oldBody.head.z;
					body.handRight.old.x = oldBody.handRight.x;
					body.handRight.old.y = oldBody.handRight.y;
					body.handRight.old.z = oldBody.handRight.z;
					body.handLeft.old.x = oldBody.handLeft.x;
					body.handLeft.old.y = oldBody.handLeft.y;
					body.handLeft.old.z = oldBody.handLeft.z;
					if (oldBody.handRight.grab) {
						body.handRight.object = oldBody.handRight.object;
					}
					if (oldBody.handLeft.grab) {
						body.handLeft.object = oldBody.handLeft.object;
					}
				}
				trackingObject.body = body; // update
			};
			kinect.client.onBodies = function (trackingIdsJson, frame) {
				var trackingIds = null;
				if (trackingIdsJson != null) {
					trackingIds = JSON.parse(trackingIdsJson);
				}
				onBodies(trackingObjects, trackingIds, frame);
			};
			kinect.client.onFace = onFace;

			var midi = $.connection.midiHub;
			midi.client.onMidi = onMidi;

			$.connection.hub.start().done(function () {
			});

		});

		var trackingObjects = [], bodyFrameIndex;
		function getTrackingObject(id) {
			var hit = null;
			trackingObjects.forEach(function (trackingObject) { // perhaps not the most efficient way, but don't expect too many tracked bodies anyway
				if (trackingObject.id == id) {
					hit = trackingObject;
				}
			});
			if (hit) {
				return hit;
			}
			// create new trackingObject
			console.log("create tracking object " + id);
			var trackingObject = { id: id, body: null }; // init as object that can be easily extended with additional properties
			trackingObjects.push(trackingObject);
			return trackingObject;
		}

		// Kinect body frame arrived
		var activeTrackingObjects = [];
		function onBodies(trackingObjects, trackedBodyIds, frame) {
			bodyFrameIndex = frame;
			activeTrackingObjects = [];
			trackedBodyIds.forEach(function (id) {
				var trackingObject = getTrackingObject(id);
				activeTrackingObjects.push(trackingObject);
			});
		}

		var midi = [];
		function onMidi(channel, data1, data2) {
			//for now, just ignore the channel information
			midi[data1] = data2 / 127.;
			console.log("midi msg: channel " + channel + " , data: " + data1 + " => " + data2);
		}

		var faces = [];

		function onFace(verticesJSON, status, TrackingId) {
			var trackingObject = getTrackingObject(TrackingId);
			var before = Date.now();
			var vertices = JSON.parse(verticesJSON);
			var dur = Date.now() - before;
			var face = faces[TrackingId];
			if (face == undefined) {
				face = {
					points2d: []
				};
				for (var i = 0; i < 1347; i++) {
					face.points2d[i] = {};
				}
				faces[TrackingId] = face;
			}

			if (trackingObject.body) {
				var head = trackingObject.body.head;
				if (head) {
					var p2d = {};
					var p3d = {};
					var scale = 1.3;
					for (var i = 0; i < 1347; i++) {

						p3d.x = head.x + (vertices[i * 3 + 0] - head.x) * scale;
						p3d.y = head.y + (vertices[i * 3 + 1] - head.y) * scale;
						p3d.z = head.z + (vertices[i * 3 + 2] - head.z) * scale;

						project(p3d, p2d);

						var shape = face.points2d[i];

						shape.x = p2d.x;
						shape.y = p2d.y;

						if (shape.update) {
							shape.update();
						}
					}
				}
			}
			//console.log("face mesh deserialize and update time: " + dur);
		}

		function getMidi(id) {

			if (midi[id] == undefined)
				midi[id] = 0;

			return midi[id];
		}

		var joints = ["SpineBase", "SpineMid", "Neck", "Head", "ShoulderLeft",
			"ElbowLeft", "WristLeft", "HandLeft", "ShoulderRight", "ElbowRight",
			"WristRight", "HandRight", "HipLeft", "KneeLeft", "AnkleLeft",
			"FootLeft", "HipRight", "KneeRight", "AnkleRight", "FootRight",
			"SpineShoulder", "HandTipLeft", "ThumbLeft", "HandTipRight", "ThumbRight"];

		var members = [
//		["SpineBase", "SpineMid"],
//		["SpineMid", "SpineShoulder"],
			["SpineShoulder", "Neck"],
			["Neck", "Head"],
			["SpineShoulder", "ShoulderLeft"],
			["ShoulderLeft", "ElbowLeft"],
			["ElbowLeft", "WristLeft"],
			["WristLeft", "HandLeft"],
			["HandLeft", "HandTipLeft"],
			["HandLeft", "ThumbLeft"],
//		["SpineBase", "HipLeft"],
			["SpineBase", "KneeLeft"],
			["SpineBase", "KneeRight"],
//		["HipLeft", "ShoulderLeft"],
			["HipLeft", "KneeLeft"],
			["KneeLeft", "AnkleLeft"],
			["AnkleLeft", "FootLeft"],
			["SpineShoulder", "ShoulderRight"],
			["ShoulderRight", "ElbowRight"],
			["ElbowRight", "WristRight"],
			["WristRight", "HandRight"],
			["HandRight", "HandTipRight"],
			["HandRight", "ThumbRight"],
//		["SpineBase", "HipRight"],
//		["HipRight", "ShoulderRight"],
			["HipRight", "KneeRight"],
			["KneeRight", "AnkleRight"],
			["AnkleRight", "FootRight"],
			["SpineMid", "ShoulderRight"],
			["SpineMid", "ShoulderLeft"],
			["SpineMid", "HipRight"],
			["SpineMid", "HipLeft"]
		];

		// perspective projection (virtual camera 
		function project(p3d, p2d) {
			p2d.x = p3d.x;
			p2d.y = p3d.y;
			var w = Math.atan2(-p3d.x, -p3d.y);
			var l = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y);
			var d = 3.;
			var zoom = 3;
			var p = Math.tan(Math.PI / 2 + Math.atan2(d + p3d.z, l));
			d = Math.sqrt(p3d.x * p3d.x + p3d.y * p3d.y + (p3d.z + d) * (p3d.z + d));
			p2d.x = zoom * Math.sin(w) * p / aspectx + 0.5;
			p2d.y = zoom * Math.cos(w) * p / aspecty + 0.5;
			p2d.y = 1 - p2d.y;
			p2d.x *= sizeX;
			p2d.y *= sizeY;
		}

		var Joint = function () {
			this.x = 0.5;
			this.y = 0.5;
			this.z = 1;
			this.state = 0;
			this.old = {};
			this.old.x = 0.5;
			this.old.y = 0.5;
			this.old.z = 1;
			this.old.state = 0;
			this.update = function (pos) {
				this.old.x = this.x;
				this.old.y = this.y;
				this.old.z = this.z;
				this.old.state = this.state;
				this.x = pos.x;
				this.y = pos.y;
				this.z = pos.z;
				this.state = pos.state;
			};
		};

		var Bone = function (joint1, joint2) {
			this.joint1 = joint1;
			this.joint2 = joint2;
		}

		var Stickman = function () {
			this.joints = [];
			this.bones = [];
			var self = this;
			joints.forEach(function (name) {
				self.joints[name] = new Joint();
			});
			members.forEach(function (member) {
				self.bones[member] = new Bone(self.joints[member[0]], self.joints[member[1]]);
			});
		};

		function updateStickMen() {
			activeTrackingObjects.forEach(function (trackingObject) {

				var stickman = trackingObject.stickman;
				if (stickman == null) {
					stickman = new Stickman();
					trackingObject.stickman = stickman;
				}

				joints.forEach(function (id) {
					stickman.joints[id].update({
						x: trackingObject.body.Joints[id].Position.X,
						y: trackingObject.body.Joints[id].Position.Y,
						z: trackingObject.body.Joints[id].Position.Z,
						state: body.Joints[id].TrackingState
					});
				});
			});
		}

		function drawStickMen(context) {
			activeTrackingObjects.forEach(function (trackingObject) {

				var stickman = trackingObject.stickman;
				if (stickman == null) {
					stickman = new Stickman();
					trackingObject.stickman = stickman;
				}

				// draw the bones
				context.strokeStyle = "#FFF";
				context.beginPath();

				members.forEach(function (member) {
					var joint1 = stickman.joints[member[0]];
					var joint2 = stickman.joints[member[1]];
					if (joint1.state == 2 && joint2.state == 2) {
						var p1 = {};
						var p2 = {};
						project(joint1, p1);
						project(joint2, p2);
						context.moveTo(p1.x, p1.y);
						context.lineTo(p2.x, p2.y);
					}
				});

				context.lineWidth = 1 / 256;
				context.stroke();

				// draw the hands

				var handLeft = {};
				var handRight = {};
				project(trackingObject.body.handLeft, handLeft);
				project(trackingObject.body.handRight, handRight);

				context.beginPath();
				context.strokeStyle = "#FFF";
				if (trackingObject.body.handLeft.grab) {
					context.strokeStyle = "#0F0";
				}
				context.rect(handLeft.x - 25, handLeft.y - 25, 50, 50);
				context.lineWidth = 1 / 32
				context.stroke();

				context.beginPath();
				context.strokeStyle = "#FFF";
				if (trackingObject.body.handRight.grab) {
					context.strokeStyle = "#0F0";
				}
				context.rect(handRight.x - 25, handRight.y - 25, 50, 50);
				context.lineWidth = 1 / 32
				context.stroke();

				/*
				joints.forEach(function (id) {
					var joint = stickman.joints[id];
				});
				*/

				// draw the face
				context.fillStyle = "#FFF";
				var face = faces[trackingObject.id];
				if (face) {
					face.points2d.forEach(function (p) {
						context.fillRect(p.x, p.y, 1 / 64, 1 / 64);
					});
				}
			});
		}
	</script>
	<script id="shader-vs" type="x-shader/x-vertex"> 
		attribute vec3 aPos;
		attribute vec2 aTexCoord;
		varying   vec2 uv;
		void main(void) {
			gl_Position = vec4(aPos, 1.);
			uv = aTexCoord;
		}
	</script>

	<script id="shader-fs-inc" type="x-shader/x-fragment">
		#ifdef GL_ES
		precision mediump float;
		#endif

		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_prev_n;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_blur2;
		uniform sampler2D sampler_blur3;
		uniform sampler2D sampler_blur4;
		uniform sampler2D sampler_blur5;
		uniform sampler2D sampler_blur6;
		uniform sampler2D sampler_noise;
		uniform sampler2D sampler_noise_n;
		uniform sampler2D sampler_fluid;
		uniform sampler2D sampler_fluid_p;
		uniform sampler2D sampler_particles;
		uniform sampler2D sampler_particle_projection;
		uniform sampler2D sampler_canvas2d;

		varying vec2 uv;
		uniform vec2 texSize;
		uniform vec2 pixelSize;
		uniform vec2 aspect;
		uniform vec2 scale;

		uniform vec2 mouse;
		uniform vec2 mouseV;

		uniform float fps;
		uniform float time;
		uniform float frame;

		uniform vec4 rnd;
		uniform vec4 rainbow;

		uniform vec4 mover0;
		uniform int moverState0;
		uniform vec4 mover1;
		uniform int moverState1;
		uniform vec4 mover2;
		uniform int moverState2;
		uniform vec4 mover3;
		uniform int moverState3;
		uniform vec4 mover4;
		uniform int moverState4;
		uniform vec4 mover5;
		uniform int moverState5;
		uniform vec4 mover6;
		uniform int moverState6;
		uniform vec4 mover7;
		uniform int moverState7;
		uniform vec4 mover8;
		uniform int moverState8;
		uniform vec4 mover9;
		uniform int moverState9;
		uniform vec2 head0;
		uniform vec4 col0;
		uniform vec2 head1;
		uniform vec4 col1;
		uniform vec2 head2;
		uniform vec4 col2;
		uniform vec2 head3;
		uniform vec4 col3;
		uniform vec2 head4;
		uniform vec4 col4;
		uniform vec2 head5;
		uniform vec4 col5;
		uniform vec2 head6;
		uniform vec4 col6;
		uniform vec2 head7;
		uniform vec4 col7;
		uniform vec2 head8;
		uniform vec4 col8;
		uniform vec2 head9;
		uniform vec4 col9;

		uniform vec4 midifader1;
		uniform vec4 midifader2;
		uniform vec4 midiknob1;
		uniform vec4 midiknob2;
		
		vec4 BlurA(vec2 uv, int level)
		{
			if(level == 0)
			{
				return texture2D(sampler_prev, fract(uv));
			}
			if(level == 1)
			{
				return texture2D(sampler_blur, fract(uv));
			}
			if(level == 2)
			{
				return texture2D(sampler_blur2, fract(uv));
			}
			if(level == 3)
			{
				return texture2D(sampler_blur3, fract(uv));
			}
			if(level == 4)
			{
				return texture2D(sampler_blur4, fract(uv));
			}
			if(level == 5)
			{
				return texture2D(sampler_blur5, fract(uv));
			}
			return texture2D(sampler_blur6, uv);
		}

		vec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){
			vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);
			vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);
			return vec2( dot(dX, selector), dot(dY, selector) );
		}

		vec2 uv_zoom_exp(vec2 uv, vec2 center, vec2 aspect, float zoom, float zoom_exp, float zoom_factor){
			vec2 uv_correct = 0.5 + (uv -0.5)* aspect;
			vec2 center_correct = 0.5 + ( center - 0.5) * aspect;
			vec2 zoom_distorted = center_correct + (uv_correct - center_correct)*(1. - zoom * pow(zoom_exp, zoom_factor*length(uv_correct-center_correct)));
			return 0.5 + (zoom_distorted - 0.5) / aspect;
		}	
					
		bool is_onscreen(vec2 uv){
			return (uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.);
		}

		float filter(vec2 uv, vec2 pos){
			return clamp( 1.-length((uv-pos)*texSize)/2., 0. , 1.);
		}

		float border(vec2 uv, float border, vec2 texSize){
			uv*=texSize;
			return (uv.x<border || uv.x>texSize.x-border || uv.y<border || uv.y >texSize.y-border) ? 1.:.0;
		}

		#define pi 3.141592653589793238462643383279
		#define pi_inv 0.318309886183790671537767526745
		#define pi2_inv 0.159154943091895335768883763372

		float border(vec2 domain, float thickness){
			 vec2 uv = fract(domain-vec2(0.5));
			 uv = min(uv,1.-uv)*2.;
			 return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);
		}

		float square_mask(vec2 domain){
			return (domain.x <= 1. && domain.x >= 0. && domain.y <= 1. && domain.y >= 0.) ? 1. : 0.; 
		}

		vec2 complex_mul(vec2 factorA, vec2 factorB){
			 return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);
		}

		vec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){
			vec2 uv = domain - center;
			float d = length(uv);
			return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;
		}

		vec2 complex_div(vec2 numerator, vec2 denominator){
			 return vec2( numerator.x*denominator.x + numerator.y*denominator.y,
										numerator.y*denominator.x - numerator.x*denominator.y)/
							vec2(denominator.x*denominator.x + denominator.y*denominator.y);
		}

		// HSL to RGB converter code from http://www.gamedev.net/topic/465948-hsl-shader-glsl-code/
		float Hue_2_RGB(float v1, float v2, float vH )
		{
			float ret;
			 if ( vH < 0.0 )
				 vH += 1.0;
			 if ( vH > 1.0 )
				 vH -= 1.0;
			 if ( ( 6.0 * vH ) < 1.0 )
				 ret = ( v1 + ( v2 - v1 ) * 6.0 * vH );
			 else if ( ( 2.0 * vH ) < 1.0 )
				 ret = ( v2 );
			 else if ( ( 3.0 * vH ) < 2.0 )
				 ret = ( v1 + ( v2 - v1 ) * ( ( 2.0 / 3.0 ) - vH ) * 6.0 );
			 else
				 ret = v1;
			 return ret;
		}

		vec3 hsl2rgb(float H, float S, float L){
			float var_2, var_1, R, G, B;	
			if (S == 0.0)
			{
				 R = L;
				 G = L;
				 B = L;
			}
			else
			{
				 if ( L < 0.5 )
				 {
					 var_2 = L * ( 1.0 + S );
				 }
				 else
				 {
					 var_2 = ( L + S ) - ( S * L );
				 }

				 var_1 = 2.0 * L - var_2;

				 R = Hue_2_RGB( var_1, var_2, H + ( 1.0 / 3.0 ) );
				 G = Hue_2_RGB( var_1, var_2, H );
				 B = Hue_2_RGB( var_1, var_2, H - ( 1.0 / 3.0 ) );
			}
			return vec3(R,G,B);
		}

		vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
			vec4 dX = 0.5*texture2D(sampler, uv + vec2(1.,0.)*d) - 0.5*texture2D(sampler, uv - vec2(1.,0.)*d);
			vec4 dY = 0.5*texture2D(sampler, uv + vec2(0.,1.)*d) - 0.5*texture2D(sampler, uv - vec2(0.,1.)*d);
			return vec2( dot(dX, selector), dot(dY, selector) );
		}

		vec2 rot90(vec2 vector){
			return vector.yx*vec2(1,-1);
		}

		float circle(vec2 uv, vec2 aspect, float scale){
			return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);
		}

		float sigmoid(float x) {
			return 2./(1. + exp2(-x)) - 1.;
		}

		float smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){
			return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;
		}

	</script>

	<script id="shader-fs-copy" type="x-shader/x-fragment"> 
		uniform sampler2D source;
		void main(void) {
			gl_FragColor = texture2D(source, uv);
		}
	</script>

	<script id="shader-fs-init" type="x-shader/x-fragment"> 
		void main(void){
			gl_FragColor = vec4(0.);
		}
	</script>

	<script id="shader-fs-move-particles" type="x-shader/x-fragment"> 

		vec4 applyMoverForce(vec4 p, vec2 f00, int moverState, vec4 mover, vec4 col){
			if(col.a == 1. && (moverState == 4 || moverState == 3)){
				vec2 pos = (p.xy - mover.xy);
				float d = length(pos*aspect);

				float area = smoothcircle(p.xy-mover.xy+0.5, aspect, 0.66, 64.);
				float dir = 0.002;
				if( moverState == 3){
					dir = -0.004;
				}
				p.zw += pos * area * dir;
		
				//p.xy += mover.zw * float(d < 0.04); // simple window cleaner
			}
			return p;
		}

		vec4 applyMoverForces(vec4 p, vec2 foo){
			p = applyMoverForce(p, foo, moverState0, mover0, col0); // first person, left hand
			p = applyMoverForce(p, foo, moverState1, mover1, col0); // right hand
			p = applyMoverForce(p, foo, moverState2, mover2, col1); // second person
			p = applyMoverForce(p, foo, moverState3, mover3, col1);
			p = applyMoverForce(p, foo, moverState4, mover4, col2); // third
			p = applyMoverForce(p, foo, moverState5, mover5, col2);
			p = applyMoverForce(p, foo, moverState6, mover6, col3);
			p = applyMoverForce(p, foo, moverState7, mover7, col3);
			p = applyMoverForce(p, foo, moverState8, mover8, col4);
			p = applyMoverForce(p, foo, moverState9, mover9, col4);
			p.xy += foo;
			return p;
		}

		void main(void){
			vec4 p = texture2D(sampler_particles, uv); // residual location and velocity of the particle in the previous frame
			vec2 f = texture2D(sampler_fluid, p.xy).xz*pixelSize; // fluid simulation flow vector
			vec4 noise = texture2D(sampler_noise, p.xy)*2. - vec4(1.);

			// apply forces
			p.zw += gradient(sampler_blur6, p.xy, pixelSize*64., vec4(-1.,1.75,0.,0.))*pixelSize; // gradients from red and green

			vec2 oo = vec2(0);
			oo += gradient(sampler_prev, p.xy, pixelSize*1., vec4(-32.,0,0.,0.))*pixelSize; // move away from red, accurate
			oo += gradient(sampler_blur, p.xy, pixelSize*4., vec4(4.,0,0.,0.))*pixelSize; // move toward red, smooth
			oo += rot90(gradient(sampler_blur2, p.xy, pixelSize*8., vec4(-8.,0,0.,0.)))*pixelSize; // move orthogonal to the gradient

			p = applyMoverForces(p, f+oo); // fluid + other offset
			p.zw = p.zw * max(0., 1.- (p.z*p.z + p.w*p.w)*32.); // (non-linear) friction
			p.xy += p.zw; // verlet integration

			gl_FragColor.xy = fract(p.xy); // wrap

			gl_FragColor.zw = p.zw; 
		}
	</script>

	<script id="shader-fs-composite" type="x-shader/x-fragment"> 

		vec4 moverCol(int moverState){
			vec4 red = vec4(1,0,0,0);
			vec4 green = vec4(0,1,0,0);
			vec4 blue = vec4(0,0,1,0);

			vec4 cyan = vec4(0,1,1,0);
			vec4 yellow = vec4(1,1,0,0);

			vec4 purple = vec4(0.5,0,.50,0);

			vec4 col = purple; // unknown

			if(moverState == 1){ // lasso
				col = cyan;
			}
			if(moverState == 2){ // open
				col = red;
			}
			if(moverState == 3){ // closed
				col = green;
			}
			if(moverState == 4){ // pointy
				col = yellow;
			}
			return col;
		}

		void mixInMover(int moverState, vec4 mover, vec4 col){
			if(col.a == 1.){
				gl_FragColor = mix(gl_FragColor, moverCol(moverState), smoothcircle(uv-mover.xy+0.5, aspect, 0.025, 96.));
			}
		}

		void mixInMovers(){
			mixInMover(moverState0, mover0, col0); // first person, left hand
			mixInMover(moverState1, mover1, col0); // right hand

			mixInMover(moverState2, mover2, col1); // second person
			mixInMover(moverState3, mover3, col1);

			mixInMover(moverState4, mover4, col2); // third
			mixInMover(moverState5, mover5, col2);
			mixInMover(moverState6, mover6, col3);
			mixInMover(moverState7, mover7, col3);
			mixInMover(moverState8, mover8, col4);
			mixInMover(moverState9, mover9, col4);
		}

		float mouseFilter(vec2 uv){
			return clamp( 1.-length((uv-mouse)*texSize)/16., 0. , 1.);
		}

		void main(void) {
			vec2 lightSize=vec2(0.5);

			vec2 d = pixelSize*2.;
			vec4 dx = (BlurA(uv + vec2(1,0)*d, 1) - BlurA(uv - vec2(1,0)*d, 1))*0.5;
			vec4 dy = (BlurA(uv + vec2(0,1)*d, 1) - BlurA(uv - vec2(0,1)*d, 1))*0.5;

			d = pixelSize*1.;
			dx += BlurA(uv + vec2(1,0)*d, 0) - BlurA(uv - vec2(1,0)*d, 0);
			dy += BlurA(uv + vec2(0,1)*d, 0) - BlurA(uv - vec2(0,1)*d, 0);

			gl_FragColor = BlurA(uv+vec2(dx.x,dy.x)*pixelSize*8., 0).x * vec4(0.7,1.66,2.0,1.0) - vec4(0.3,1.0,1.0,1.0);
			gl_FragColor = mix(gl_FragColor,vec4(8.0,6.,2.,1.), BlurA(uv + vec2(dx.x,dy.x)*lightSize, 3).y*0.4*0.75*vec4(1.-BlurA(uv+vec2(dx.x,dy.x)*pixelSize*8., 0).x));
			gl_FragColor = mix(gl_FragColor, vec4(0.1,0.,0.4,0.), BlurA(uv, 1).a*length(GradientA(uv, pixelSize*2., vec4(0.,0.,0.,1.), 0))*5.);
			gl_FragColor = mix(gl_FragColor, vec4(1.25,1.35,1.4,0.), BlurA(uv, 0).x*BlurA(uv + GradientA(uv, pixelSize*2.5, vec4(-256.,32.,-128.,32.), 1)*pixelSize, 2).y);
			gl_FragColor = mix(gl_FragColor, vec4(0.25,0.75,1.,0.), BlurA(uv, 1).x*length(GradientA(uv+GradientA(uv, pixelSize*2., vec4(0.,0.,128.,0.), 1)*pixelSize, pixelSize*2., vec4(0.,0.,0.,1.), 0))*5.);
			gl_FragColor = mix(gl_FragColor, vec4(1.,1.25,1.5,0.), 0.5*(1.-BlurA(uv, 0)*1.).a*length(GradientA(uv+GradientA(uv, pixelSize*2., vec4(0.,128.,0.,0.), 1)*pixelSize, pixelSize*1.5, vec4(0.,0.,16.,0.), 0)));
			gl_FragColor = mix(gl_FragColor, vec4(0.,0.,0.,1.), texture2D(sampler_canvas2d, uv+vec2(2,2)*pixelSize).y);
			gl_FragColor = mix(gl_FragColor, vec4(1.,1.,1.,1.), texture2D(sampler_canvas2d, uv).y);

		//	gl_FragColor = texture2D(sampler_prev, uv); // bypass
	
			mixInMovers();
			gl_FragColor.a = 1.;
		}
	</script>

	<script id="shader-fs-advance" type="x-shader/x-fragment"> 

		void main(void) {
			float noise = texture2D(sampler_noise, uv + rnd.zw).x*2.;
			vec2 f = texture2D(sampler_fluid, uv).xz*pixelSize;
			vec2 uv = uv - f;

			//zooms on head position;
			float zoom = -1.;
			float zoom_exp = 1./8.;
			float zoom_factor = 12.;
			
			//zoom = 2.;
			//zoom_exp = 1./10.;
			//zoom_factor = 20.;
		
			zoom = 1./8.;
			zoom_exp = 1./4.;
			zoom_factor = 8.;
			
			vec2 uvr = uv;

			if(col0.a == 1.){
				uvr = uv_zoom_exp(uvr, head0.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col1.a == 1.){
				uvr = uv_zoom_exp(uvr, head1.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col2.a == 1.){
				uvr = uv_zoom_exp(uvr, head2.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col3.a == 1.){
				uvr = uv_zoom_exp(uvr, head3.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col4.a == 1.){
				uvr = uv_zoom_exp(uvr, head4.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
			if(col5.a == 1.){
				uvr = uv_zoom_exp(uvr, head5.xy, aspect, zoom, zoom_exp, zoom_factor);
			}
		
			uv = uvr;

			// expansion
			vec2 gradientLookupDistance = pixelSize*3.;
			float expansionFactor = 1.;

			// reaction-diffusion
			float differentialFactor = 13.5/256.;
			float increment = - 4./256.;
			float noiseFactor = 2./256.;

			// rock-paper-scissor
			float feedBack = 6./256.;
			float feedForward = 6./256.;

			gl_FragColor.r = BlurA(uv + GradientA(uv, gradientLookupDistance, vec4(4.,0.,-2.,0.), 1)*pixelSize*expansionFactor, 0).r;
			gl_FragColor.g = BlurA(uv + GradientA(uv, gradientLookupDistance, vec4(0.,4.,0.,-2.), 1)*pixelSize*expansionFactor, 0).g;
			gl_FragColor.b = BlurA(uv + GradientA(uv, gradientLookupDistance, vec4(-2.,0.,4.,0.), 1)*pixelSize*expansionFactor, 0).b;
			gl_FragColor.a = BlurA(uv + GradientA(uv, gradientLookupDistance, vec4(0.,-2.,0.,4.), 1)*pixelSize*expansionFactor, 0).a;

			gl_FragColor += (BlurA(uv, 1) - BlurA(uv, 2))*differentialFactor;

			gl_FragColor += increment + noise * noiseFactor;

			gl_FragColor -= BlurA(uv, 0).argb * feedBack;
			gl_FragColor += BlurA(uv, 0).gbar * feedForward;

			gl_FragColor = clamp(gl_FragColor, 0., 1.);
		}
	</script>

	<script id="shader-fs-blur-horizontal" type="x-shader/x-fragment">
		// original shader from http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
		// horizontal blur fragment shader
		uniform sampler2D src_tex;

		void main(void) // fragment
		{
			float h = pixelSize.x;
			vec4 sum = vec4(0.0);
			sum += texture2D(src_tex, vec2(uv.x - 4.0*h, uv.y) ) * 0.05;
			sum += texture2D(src_tex, vec2(uv.x - 3.0*h, uv.y) ) * 0.09;
			sum += texture2D(src_tex, vec2(uv.x - 2.0*h, uv.y) ) * 0.12;
			sum += texture2D(src_tex, vec2(uv.x - 1.0*h, uv.y) ) * 0.15;
			sum += texture2D(src_tex, vec2(uv.x + 0.0*h, uv.y) ) * 0.16;
			sum += texture2D(src_tex, vec2(uv.x + 1.0*h, uv.y) ) * 0.15;
			sum += texture2D(src_tex, vec2(uv.x + 2.0*h, uv.y) ) * 0.12;
			sum += texture2D(src_tex, vec2(uv.x + 3.0*h, uv.y) ) * 0.09;
			sum += texture2D(src_tex, vec2(uv.x + 4.0*h, uv.y) ) * 0.05;
			gl_FragColor.xyz = sum.xyz/0.98; // normalize
			gl_FragColor.a = 1.;
		} 
	</script>

	<script id="shader-fs-blur-vertical" type="x-shader/x-fragment">
	uniform sampler2D src_tex;

	void main(void) // fragment
	{
		float v = pixelSize.y;
		vec4 sum = vec4(0.0);
		sum += texture2D(src_tex, vec2(uv.x, - 4.0*v + uv.y) ) * 0.05;
		sum += texture2D(src_tex, vec2(uv.x, - 3.0*v + uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x, - 2.0*v + uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x, - 1.0*v + uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x, + 0.0*v + uv.y) ) * 0.16;
		sum += texture2D(src_tex, vec2(uv.x, + 1.0*v + uv.y) ) * 0.15;
		sum += texture2D(src_tex, vec2(uv.x, + 2.0*v + uv.y) ) * 0.12;
		sum += texture2D(src_tex, vec2(uv.x, + 3.0*v + uv.y) ) * 0.09;
		sum += texture2D(src_tex, vec2(uv.x, + 4.0*v + uv.y) ) * 0.05;
		gl_FragColor.xyz = sum.xyz/0.98;
		gl_FragColor.a = 1.;
	}
	</script>

	<script id="shader-fs-add-mouse-motion" type="x-shader/x-fragment"> 

		void main(void){
			vec2 v = texture2D(sampler_fluid, uv).xz;
			if(length(mouseV) > 0.){
				v = mix(v, mouseV, filter(uv, mouse)*0.85);
			}
			float scale = 8.;
			// first person left hand
			if(length(mover0.zw) > 0.){
				v = mix(v, mover0.zw*scale*texSize, filter(uv, mover0.xy)*0.85);
			}
			// first person right hand
			if(length(mover1.zw) > 0.){
				v = mix(v, mover1.zw*scale*texSize, filter(uv, mover1.xy)*0.85);
			}

			// second person left hand
			if(length(mover2.zw) > 0.){
				v = mix(v, mover2.zw*scale*texSize, filter(uv, mover2.xy)*0.85);
			}
			// second person right hand
			if(length(mover3.zw) > 0.){
				v = mix(v, mover3.zw*scale*texSize, filter(uv, mover3.xy)*0.85);
			}
			// third person left hand
			if(length(mover4.zw) > 0.){
				v = mix(v, mover4.zw*scale*texSize, filter(uv, mover4.xy)*0.85);
			}
			// third person right hand
			if(length(mover5.zw) > 0.){
				v = mix(v, mover5.zw*scale*texSize, filter(uv, mover5.xy)*0.85);
			}
			// 4th person left hand
			if(length(mover6.zw) > 0.){
				v = mix(v, mover6.zw*scale*texSize, filter(uv, mover6.xy)*0.85);
			}
			// 4th person right hand
			if(length(mover7.zw) > 0.){
				v = mix(v, mover7.zw*scale*texSize, filter(uv, mover7.xy)*0.85);
			}

			gl_FragColor.xz = v;
		}
	</script>

	<script id="shader-fs-advect" type="x-shader/x-fragment"> 

		const float dt = .0005;

		void main(void){
			vec2 v = texture2D(sampler_fluid, uv).xz;

			vec2 D = -texSize*vec2(v.x, v.y)*dt;

			 vec2 Df = floor(D),   Dd = D - Df;
			 vec2 uv = uv + Df*pixelSize;

			vec2 uv0, uv1, uv2, uv3;

			uv0 = uv + pixelSize*vec2(0.,0.);
			uv1 = uv + pixelSize*vec2(1.,0.);
			uv2 = uv + pixelSize*vec2(0.,1.);
			uv3 = uv + pixelSize*vec2(1.,1.);

			vec2 v0 = texture2D(sampler_fluid, uv0).xz;
			vec2 v1 = texture2D(sampler_fluid, uv1).xz;
			vec2 v2 = texture2D(sampler_fluid, uv2).xz;
			vec2 v3 = texture2D(sampler_fluid, uv3).xz;

			v = mix( mix( v0, v1, Dd.x), mix( v2, v3, Dd.x), Dd.y);

			gl_FragColor.xz = v*(1.-border(uv, 1., texSize));
		}
	</script>

	<script id="shader-fs-p" type="x-shader/x-fragment"> 
		uniform sampler2D sampler_v;
		uniform sampler2D sampler_p;
		const float h = 1./1024.;

		void main(void){

			vec2 v = texture2D(sampler_v, uv).xz;
			float v_x = texture2D(sampler_v, uv - vec2(1.,0.)*pixelSize).r;
			float v_y = texture2D(sampler_v, uv - vec2(0.,1.)*pixelSize).b;

			float n = texture2D(sampler_p, uv- pixelSize*vec2(0.,1.)).r;
			float w = texture2D(sampler_p, uv + pixelSize*vec2(1.,0.)).r;
			float s = texture2D(sampler_p, uv + pixelSize*vec2(0.,1.)).r;
			float e = texture2D(sampler_p, uv - pixelSize*vec2(1.,0.)).r;

			float p = ( n + w + s + e - (v.x - v_x + v.y - v_y)*h ) * .25;

			gl_FragColor.r = p;
			gl_FragColor.ba = vec2(0.); // unused
		}
	</script>

	<script id="shader-fs-div" type="x-shader/x-fragment"> 
		uniform sampler2D sampler_v;
		uniform sampler2D sampler_p;

		void main(void){
			float p = texture2D(sampler_p, uv).r;
			vec2 v = texture2D(sampler_v, uv).xz;
			float p_x = texture2D(sampler_p, uv + vec2(1.,0.)*pixelSize).r;
			float p_y = texture2D(sampler_p, uv + vec2(0.,1.)*pixelSize).r;

			v -= (vec2(p_x, p_y)-p)*512.;

			gl_FragColor.xz = v;
		}
	</script>

	<script type="x-shader/x-vertex" id="shader-particle-renderer-vs"> 
		attribute vec2 uv; // particle position lookup vector
		uniform sampler2D sampler_prev;
		uniform sampler2D sampler_blur;
		uniform sampler2D sampler_particles; // particle positions in a float texture
		uniform vec2 mouse;
		uniform vec2 pixelSize;
			
		vec2 gradient(sampler2D sampler, vec2 uv, vec2 d, vec4 selector){
			vec4 dX = 0.5*texture2D(sampler, uv + vec2(1.,0.)*d) - 0.5*texture2D(sampler, uv - vec2(1.,0.)*d);
			vec4 dY = 0.5*texture2D(sampler, uv + vec2(0.,1.)*d) - 0.5*texture2D(sampler, uv - vec2(0.,1.)*d);
			return vec2( dot(dX, selector), dot(dY, selector) );
		}

		void main() {
			gl_Position = (texture2D(sampler_particles, uv) - 0.5)*2.; // pass em flat
			gl_Position.xy += gradient(sampler_blur, gl_Position.xy*0.5+0.5, pixelSize*3., vec4(1,-0.,0,0))*pixelSize*32.;

			gl_Position.zw = vec2(0,1);
			gl_PointSize = 1.;	
		}
	</script>

	<script type="x-shader/x-fragment" id="shader-particle-renderer-fs"> 
		void main() {
			gl_FragColor = vec4(1.0, 0.5, 0.166, 0.33);
		}
	</script>

	<script type="text/javascript">
		function getShader(gl, id, addInc) {
			if (addInc == undefined) {
				addInc = true;
			}

			var shaderScript = document.getElementById(id);
			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					str += k.textContent;
				k = k.nextSibling;
			}

			var fsIncScript = document.getElementById("shader-fs-inc");
			var incStr = "";
			k = fsIncScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					incStr += k.textContent;
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				if (addInc) {
					str = incStr + str;
				}
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex")
				shader = gl.createShader(gl.VERTEX_SHADER);
			else
				return null;
			gl.shaderSource(shader, str);
			gl.compileShader(shader);
			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
				alert("error compiling shader '" + id + "'\n\n" + gl.getShaderInfoLog(shader));
			return shader;
		}

		window.requestAnimFrame = (function () {
			return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame
					|| window.msRequestAnimationFrame || function (callback) {
						window.setTimeout(callback, 1000 / desiredFramerate);
					};
		})();

		var gl;
		var ext;

		var prog_copy;
		var prog_advance;
		var prog_composite;
		var prog_blur_horizontal;
		var prog_blur_vertical;
		var prog_fluid_init;
		var prog_fluid_add_mouse_motion;
		var prog_fluid_advect;
		var prog_fluid_p;
		var prog_fluid_div;
		var prog_move_particles;
		var prog_render_particles;

		var FBO_main;
		var FBO_main2;
		var FBO_noise;
		var FBO_blur;
		var FBO_blur2;
		var FBO_blur3;
		var FBO_blur4;
		var FBO_blur5;
		var FBO_blur6;
		var FBO_helper;
		var FBO_helper2;
		var FBO_helper3;
		var FBO_helper4;
		var FBO_helper5;
		var FBO_helper6;
		var FBO_fluid_v;
		var FBO_fluid_p;
		var FBO_fluid_store;
		var FBO_fluid_backbuffer;
		var FBO_particles; // particle positions in a texture
		var FBO_particles2; // double buffer
		var FBO_particle_projection; // particle render target for projection feedback effects
		var FBO_canvas2d; // we will copy a 2d drawn scene to a webgl texture using this, or not

		var texture_main_n; // main, nearest pixel
		var texture_main_l; // main, linear interpolated access on the same buffer
		var texture_main2_n; // main double buffer, nearest
		var texture_main2_l; // main double buffer, linear
		var texture_blur; // full resolution blur result
		var texture_blur2; // double blur
		var texture_blur3; // quad blur
		var texture_blur4; // use low resolutions wisely ;)
		var texture_blur5;
		var texture_blur6;
		var texture_helper; // needed for multi-pass shader programs (2-pass Gaussian blur)
		var texture_helper2; // (1/4 resolution )
		var texture_helper3; // (1/16 resolution )
		var texture_helper4; // (1/256 resolution )
		var texture_helper5;
		var texture_helper6;
		var texture_noise_n; // nearest pixel access
		var texture_noise_l; // linear interpolated
		var texture_fluid_v; // velocities
		var texture_fluid_p; // pressure
		var texture_fluid_store;
		var texture_fluid_backbuffer;
		var texture_particles;
		var texture_particles2;
		var texture_particle_projection;
		var texture_canvas2d;

		// main texture loop dimensions
		var sizeX = 1024; // must be powers of 2
		var sizeY = 512;
		var viewX = sizeX; // viewport size (ideally exactly the texture size)
		var viewY = sizeY;

		// particle positions will be stored in a texture of that size
		var particlesWidth = 1024;
		var particlesHeight = 512;
		var particleCount = particlesWidth * particlesHeight; // can also be set to lower than particlesWidth * particlesHeight

		var useParticles = true;
		var useProjectionFeedback = true; // rendering half a million points can slow things down significantly, don't render to texture if not needed
		var useFluidSimulation = true; // the textures will be initialized anyway
		var simScale = 8; // for better performance, the fluid simulation will be calculated for cells this times bigger than the main texture's pixels (powers of 2)

		var desiredFramerate = 100; // more like a limit
		var startFullpage = true;
		var renderParticlesOnly = false;

		// don't change vars below
		var canvas2d;
		var canvas2dContext;

		var frame = 0; // frame counter to be resetted every 1000ms
		var framecount = 0; // not resetted
		var mainBufferToggle = 1;
		var halted = false;
		var fps, fpsDisplayUpdateTimer;
		var time, starttime = new Date().getTime();

		var mouseX = 0.5;
		var mouseY = 0.5;
		var oldMouseX = 0;
		var oldMouseY = 0;
		var mouseDx = 0;
		var mouseDy = 0;

		var aspectx = 2;
		var aspecty = 1;

		// geometry
		var particleBuffer, squareBuffer, hLineBuffer, vLineBuffer;

		function updateApectRatio() {
			aspectx = Math.max(1, viewX / viewY);
			aspecty = Math.max(1, viewY / viewX);
		}

		function load() {
			clearInterval(fpsDisplayUpdateTimer);
			canvas2d = document.createElement("canvas");
			canvas2d.width = sizeX;
			canvas2d.height = sizeY;
			canvas2dContext = canvas2d.getContext("2d");
			var c = document.getElementById("c");
			try {
				gl = c.getContext("experimental-webgl", {
					depth: false
				});
			} catch (e) {
			}
			if (!gl) {
				alert("Meh! Y u no support experimental WebGL !?!");
				return;
			}

			["OES_texture_float", "OES_standard_derivatives", "OES_texture_float_linear"].forEach(function (name) {
				console.log("check " + name);
				try {
					ext = gl.getExtension(name);
				} catch (e) {
					alert(e);
				}
				if (!ext) {
					alert("Meh! Y u no support " + name + " !?!)");
					return;
				}
				ext = false;
			});

			if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0) {
				alert("Meh! Y u no support vertex shader textures !?!");
				return;
			}

			document.onmousemove = function (evt) {
				mouseX = evt.pageX / viewX;
				mouseY = 1 - evt.pageY / viewY;
			};

			document.addEventListener("orientationchange", window.onresize = function () {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
				c.width = viewX;
				c.height = viewY;
				updateApectRatio();
			});


			if (startFullpage) {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
			}

			c.width = viewX;
			c.height = viewY;

			prog_copy = createAndLinkProgram("shader-fs-copy");
			prog_advance = createAndLinkProgram("shader-fs-advance");
			prog_composite = createAndLinkProgram("shader-fs-composite");
			prog_blur_horizontal = createAndLinkProgram("shader-fs-blur-horizontal");
			prog_blur_vertical = createAndLinkProgram("shader-fs-blur-vertical");
			prog_fluid_init = createAndLinkProgram("shader-fs-init");
			prog_fluid_add_mouse_motion = createAndLinkProgram("shader-fs-add-mouse-motion");
			prog_fluid_advect = createAndLinkProgram("shader-fs-advect");
			prog_fluid_p = createAndLinkProgram("shader-fs-p");
			prog_fluid_div = createAndLinkProgram("shader-fs-div");
			prog_move_particles = createAndLinkProgram("shader-fs-move-particles");

			triangleStripGeometry = {
				vertices: new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]),
				texCoords: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
				vertexSize: 3,
				vertexCount: 4,
				type: gl.TRIANGLE_STRIP
			};

			createTexturedGeometryBuffer(triangleStripGeometry);

			hLineVertices = [];
			hLineTexCoords = [];
			for (var y = 0; y < sizeY; y++) {
				hLineVertices.push(-1, -1 + 2 * y / sizeY, 0, 1, -1 + 2 * y / sizeY, 0);
				hLineTexCoords.push(0. / sizeX, (y - 0.5) / sizeY, (sizeX + 0.) / sizeX, (y - 0.5) / sizeY);
			}
			hLineGeometry = {
				vertices: new Float32Array(hLineVertices),
				texCoords: new Float32Array(hLineTexCoords),
				vertexSize: 3,
				vertexCount: sizeY * 2,
				type: gl.LINES
			};

			vLineVertices = [];
			vLineTexCoords = [];
			for (var x = 0; x < sizeX; x++) {
				vLineVertices.push(-1 + 2 * x / sizeX, -1, 0, -1 + 2 * x / sizeX, 1, 0);
				vLineTexCoords.push((x - 0.5) / sizeX, 0. / sizeY, (x - 0.5) / sizeX, (sizeY + 0.) / sizeY);
			}
			vLineGeometry = {
				vertices: new Float32Array(vLineVertices),
				texCoords: new Float32Array(vLineTexCoords),
				vertexSize: 3,
				vertexCount: sizeX * 2,
				type: gl.LINES
			};

			createTexturedGeometryBuffer(hLineGeometry);
			createTexturedGeometryBuffer(vLineGeometry);

			squareBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer);

			var aPosLoc = gl.getAttribLocation(prog_advance, "aPos");
			var aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");

			gl.enableVertexAttribArray(aPosLoc);
			gl.enableVertexAttribArray(aTexLoc);

			var verticesAndTexCoords = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1, // one square of a quad!
			0, 0, 1, 0, 0, 1, 1, 1] // hello texture, you be full
			);

			gl.bufferData(gl.ARRAY_BUFFER, verticesAndTexCoords, gl.STATIC_DRAW);
			gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 8, 0);
			gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 8, 32);

			var noisePixels = [], pixels = [], simpixels = [], pixels2 = [], pixels3 = [], pixels4 = [], pixels5 = [], pixels6 = [], particles = [], particlesIdx = [];
			var dX = 1 / particlesWidth;
			var dY = 1 / particlesHeight;
			for (var j = 0; j < sizeY; j++) {
				for (var i = 0; i < sizeX; i++) {
					noisePixels.push(Math.random(), Math.random(), Math.random(), 1);
					pixels.push(0, 0, 0, 1);
					if (i < sizeX / simScale && j < sizeY / simScale)
						simpixels.push(0, 0, 0, 1);
					if (i < sizeX / 2 && j < sizeY / 2)
						pixels2.push(0, 0, 0, 1);
					if (i < sizeX / 4 && j < sizeY / 4)
						pixels3.push(0, 0, 0, 1);
					if (i < sizeX / 8 && j < sizeY / 8)
						pixels4.push(0, 0, 0, 1);
					if (i < sizeX / 16 && j < sizeY / 16)
						pixels5.push(0, 0, 0, 1);
					if (i < sizeX / 32 && j < sizeY / 32)
						pixels6.push(0, 0, 0, 1);
					if (i < particlesWidth && j < particlesHeight) {
						particles.push(dX / 2 + i * dX, dY / 2 + j * dY, 0, 0); // initial particle positions, here: uniform distribution
					}
				}
			}

			for (var i = 0; i < particlesHeight; i++) {
				for (var j = 0; j < particlesWidth; j++) {
					particlesIdx.push(dX / 2 + j * dX, dY / 2 + i * dY); // coordinate lookup vectors (center of pixels)
				}
			}

			FBO_main = gl.createFramebuffer();
			FBO_main2 = gl.createFramebuffer();
			var glPixels;
			glPixels = new Float32Array(noisePixels);
			texture_main_n = createAndBindTexture(glPixels, 1, FBO_main, gl.NEAREST);
			texture_main2_n = createAndBindTexture(glPixels, 1, FBO_main2, gl.NEAREST);
			glPixels = new Float32Array(noisePixels);
			texture_main_l = createAndBindTexture(glPixels, 1, FBO_main, gl.LINEAR);
			texture_main2_l = createAndBindTexture(glPixels, 1, FBO_main2, gl.LINEAR);

			FBO_fluid_p = gl.createFramebuffer();
			FBO_fluid_v = gl.createFramebuffer();
			FBO_fluid_store = gl.createFramebuffer();
			FBO_fluid_backbuffer = gl.createFramebuffer();
			texture_fluid_v = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_v);
			texture_fluid_p = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_p);
			texture_fluid_store = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_store);
			texture_fluid_backbuffer = createAndBindSimulationTexture(new Float32Array(simpixels), FBO_fluid_backbuffer);

			FBO_particle_projection = gl.createFramebuffer();
			texture_particle_projection = createAndBindTexture(new Float32Array(pixels), 1, FBO_particle_projection, gl.LINEAR);

			FBO_helper = gl.createFramebuffer();
			FBO_helper2 = gl.createFramebuffer();
			FBO_helper3 = gl.createFramebuffer();
			FBO_helper4 = gl.createFramebuffer();
			FBO_helper5 = gl.createFramebuffer();
			FBO_helper6 = gl.createFramebuffer();
			texture_helper = createAndBindTexture(new Float32Array(pixels), 1, FBO_helper, gl.NEAREST); // helper buffers for the two-pass Gaussian blur calculation basically
			texture_helper2 = createAndBindTexture(new Float32Array(pixels2), 2, FBO_helper2, gl.NEAREST);
			texture_helper3 = createAndBindTexture(new Float32Array(pixels3), 4, FBO_helper3, gl.NEAREST);
			texture_helper4 = createAndBindTexture(new Float32Array(pixels4), 8, FBO_helper4, gl.NEAREST);
			texture_helper5 = createAndBindTexture(new Float32Array(pixels5), 16, FBO_helper5, gl.NEAREST);
			texture_helper6 = createAndBindTexture(new Float32Array(pixels6), 32, FBO_helper6, gl.NEAREST);

			FBO_blur = gl.createFramebuffer();
			FBO_blur2 = gl.createFramebuffer();
			FBO_blur3 = gl.createFramebuffer();
			FBO_blur4 = gl.createFramebuffer();
			FBO_blur5 = gl.createFramebuffer();
			FBO_blur6 = gl.createFramebuffer();
			texture_blur = createAndBindTexture(new Float32Array(pixels), 1, FBO_blur, gl.LINEAR);
			texture_blur2 = createAndBindTexture(new Float32Array(pixels2), 2, FBO_blur2, gl.LINEAR);
			texture_blur3 = createAndBindTexture(new Float32Array(pixels3), 4, FBO_blur3, gl.LINEAR);
			texture_blur4 = createAndBindTexture(new Float32Array(pixels4), 8, FBO_blur4, gl.LINEAR);
			texture_blur5 = createAndBindTexture(new Float32Array(pixels5), 16, FBO_blur5, gl.LINEAR);
			texture_blur6 = createAndBindTexture(new Float32Array(pixels6), 32, FBO_blur6, gl.LINEAR);

			FBO_canvas2d = gl.createFramebuffer();
			texture_canvas2d = createAndBindTexture(new Float32Array(pixels), 1, FBO_canvas2d, gl.LINEAR);

			FBO_noise = gl.createFramebuffer();
			glPixels = new Float32Array(noisePixels);
			texture_noise_n = createAndBindTexture(glPixels, 1, FBO_noise, gl.NEAREST);
			texture_noise_l = createAndBindTexture(glPixels, 1, FBO_noise, gl.LINEAR);

			FBO_particles = gl.createFramebuffer();
			texture_particles = createAndBindParticleTexture(new Float32Array(particles), FBO_particles);

			FBO_particles2 = gl.createFramebuffer();
			texture_particles2 = createAndBindParticleTexture(new Float32Array(particles), FBO_particles2);

			// lesson learned: the (frame) buffer location that we pass to the vertex shader has to be bound to the program before linking!

			var aParticleLoc = 2; // no getAttributeLoc
			prog_render_particles = createAndLinkParticleRenderer(aParticleLoc);

			gl.useProgram(prog_render_particles);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 0);

			gl.enableVertexAttribArray(aParticleLoc);
			particleBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particlesIdx), gl.STATIC_DRAW);
			gl.vertexAttribPointer(aParticleLoc, 2, gl.FLOAT, false, 0, 0);

			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur);
			gl.activeTexture(gl.TEXTURE3);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur2);
			gl.activeTexture(gl.TEXTURE4);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur3);
			gl.activeTexture(gl.TEXTURE5);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur4);
			gl.activeTexture(gl.TEXTURE6);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur5);
			gl.activeTexture(gl.TEXTURE7);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur6);
			gl.activeTexture(gl.TEXTURE8);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_l);
			gl.activeTexture(gl.TEXTURE9);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_n);
			gl.activeTexture(gl.TEXTURE10);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE11);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.activeTexture(gl.TEXTURE12);
			gl.bindTexture(gl.TEXTURE_2D, texture_particles); // to be swapped anyways
			gl.activeTexture(gl.TEXTURE13);
			gl.bindTexture(gl.TEXTURE_2D, texture_particle_projection);
			gl.activeTexture(gl.TEXTURE14);
			gl.bindTexture(gl.TEXTURE_2D, texture_canvas2d);

			fluidInit(FBO_fluid_v);
			fluidInit(FBO_fluid_p);
			fluidInit(FBO_fluid_store);
			fluidInit(FBO_fluid_backbuffer);

			fpsDisplayUpdateTimer = setInterval(fr, 1000);
			time = new Date().getTime() - starttime;

			gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			gl.clearColor(0, 0, 0, 1);

			anim();
		}

		function createTexturedGeometryBuffer(geometry) {
			geometry.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			geometry.aPosLoc = gl.getAttribLocation(prog_advance, "aPos"); // we could take any program here, they all use the same vertex shader
			gl.enableVertexAttribArray(geometry.aPosLoc);
			geometry.aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");
			gl.enableVertexAttribArray(geometry.aTexLoc);
			geometry.texCoordOffset = geometry.vertices.byteLength;
			gl.bufferData(gl.ARRAY_BUFFER, geometry.texCoordOffset + geometry.texCoords.byteLength, gl.STATIC_DRAW);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, geometry.vertices);
			gl.bufferSubData(gl.ARRAY_BUFFER, geometry.texCoordOffset, geometry.texCoords);
			setGeometryVertexAttribPointers(geometry);
		}

		function setGeometryVertexAttribPointers(geometry) {
			gl.vertexAttribPointer(geometry.aPosLoc, geometry.vertexSize, gl.FLOAT, gl.FALSE, 0, 0);
			gl.vertexAttribPointer(geometry.aTexLoc, 2, gl.FLOAT, gl.FALSE, 0, geometry.texCoordOffset);
		}

		function createAndLinkProgram(fsId) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-vs"));
			gl.attachShader(program, getShader(gl, fsId));
			gl.linkProgram(program);
			return program;
		}

		function createAndLinkParticleRenderer(aParticleLoc) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-vs"));
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-fs", false));
			gl.bindAttribLocation(program, aParticleLoc, "uv"); // can't use getAttribLocation later so we must bind before linking
			gl.linkProgram(program);
			return program;
		}

		function createAndBindTexture(glPixels, scale, fbo, filter) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / scale, sizeY / scale, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindParticleTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, particlesWidth, particlesHeight, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function createAndBindSimulationTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / simScale, sizeY / simScale, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			return texture;
		}

		function fluidInit(fbo) {
			gl.viewport(0, 0, sizeX / simScale, sizeY / simScale);
			gl.useProgram(prog_fluid_init);
			renderAsTriangleStrip(fbo);
		}

		function setUniforms(program) {
			gl.uniform4f(gl.getUniformLocation(program, "rnd"), Math.random(), Math.random(), Math.random(), Math.random());
			gl.uniform4f(gl.getUniformLocation(program, "rainbow"), rainbowR, rainbowG, rainbowB, 1);
			gl.uniform2f(gl.getUniformLocation(program, "texSize"), sizeX, sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(program, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(program, "mouseV"), mouseDx, mouseDy);
			gl.uniform1f(gl.getUniformLocation(program, "fps"), fps);
			gl.uniform1f(gl.getUniformLocation(program, "time"), time);
			gl.uniform1f(gl.getUniformLocation(program, "frame"), framecount);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur"), 2);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur2"), 3);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur3"), 4);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur4"), 5);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur5"), 6);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur6"), 7);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise"), 8);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise_n"), 9);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid"), 10);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_fluid_p"), 11);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particles"), 12);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particle_projection"), 13);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_canvas2d"), 14);

			setMoverUniforms(program);
		}

		var colors = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1], [0, 1, 1]]; // red green blue yellow magenta cyan

		function setMoverUniforms(program) {
			// push it
			var moverIndex = 0;
			var bodyIndex = 0;
			// project it
			var p3d = {};
			var p2d = {};
			activeTrackingObjects.forEach(function (trackingObject) {
				var stickman = trackingObject.stickman;
				var body = trackingObject.body;
				project(body.head, p2d); // current projection
				var x = p2d.x / sizeX;
				var y = 1 - p2d.y / sizeY;
				gl.uniform2f(gl.getUniformLocation(program, "head" + bodyIndex), x, y);
				var col = colors[bodyIndex];
				gl.uniform4f(gl.getUniformLocation(program, "col" + bodyIndex), col[0], col[1], col[2], 1);
				bodyIndex++;
				// left hand
				project(body.handLeft, p2d); // current projection
				var x = p2d.x / sizeX;
				var y = 1 - p2d.y / sizeY;
				project(body.handLeft.old, p2d); // previous projection
				var old = {};
				old.x = p2d.x / sizeX;
				old.y = 1 - p2d.y / sizeY;
				var dx = (x - old.x); // difference = velocity
				var dy = (y - old.y);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				var state = body.handLeft.state;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), x, y, dx*sizeX, dy*sizeY);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), state);
				moverIndex++;
				// right hand
				project(body.handRight, p2d);
				x = p2d.x / sizeX;
				y = 1 - p2d.y / sizeY;
				project(body.handRight.old, p2d);
				old.x = p2d.x / sizeX;
				old.y = 1 - p2d.y / sizeY;
				dx = (x - old.x);
				dy = (y - old.y);
				if (Math.abs(dx) > 0.2) {
					dx = 0.2 * dx / Math.abs(dx);
				}
				if (Math.abs(dy) > 0.2) {
					dy = 0.2 * dy / Math.abs(dy);
				}
				state = body.handRight.state;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), x, y, dx*sizeX, dy*sizeY);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), state);
				moverIndex++;
			});
			// init untracked players
			for (var index = moverIndex; index < 12; index++) {
				gl.uniform4f(gl.getUniformLocation(program, "col" + bodyIndex), 0, 0, 0, 0);
				bodyIndex++;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), 0);
				moverIndex++;
				gl.uniform4f(gl.getUniformLocation(program, "mover" + moverIndex), 0, 0, 0, 0);
				gl.uniform1i(gl.getUniformLocation(program, "moverState" + moverIndex), 0);
				moverIndex++
			}
		}

		function useGeometry(geometry) {
			gl.bindBuffer(gl.ARRAY_BUFFER, geometry.buffer);
			setGeometryVertexAttribPointers(geometry);
		}

		function renderGeometry(geometry, targetFBO) {
			useGeometry(geometry);
			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.drawArrays(geometry.type, 0, geometry.vertexCount);
			gl.flush();
		}

		function renderAsTriangleStrip(targetFBO) {
			renderGeometry(triangleStripGeometry, targetFBO);
		}

		function renderParticles(targetFBO) {
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);

			if (targetFBO == null)
				gl.viewport(0, 0, viewX, viewY);
			else
				gl.viewport(0, 0, sizeX, sizeY);

			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.useProgram(prog_render_particles);

			gl.activeTexture(gl.TEXTURE12);
			if (mainBufferToggle < 0) {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
			} else {
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
			}

			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 12); // input for the vertex shader
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(prog_render_particles, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_blur"), 2);

			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			gl.enable(gl.BLEND);
			gl.drawArrays(gl.POINTS, 0, particleCount);
			gl.disable(gl.BLEND);

			gl.flush();
		}

		function updateCanvas2dTexture() {
			gl.activeTexture(gl.TEXTURE14);
			gl.bindTexture(gl.TEXTURE_2D, texture_canvas2d);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2d);
			gl.bindTexture(gl.TEXTURE_2D, texture_canvas2d);
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_canvas2d);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_canvas2d, 0);
		}

		function calculateBlurTextures(texture_source) {
			calculateBlurTexture(texture_source, texture_blur, FBO_blur, texture_helper, FBO_helper, 1);
			calculateBlurTexture(texture_blur, texture_blur2, FBO_blur2, texture_helper2, FBO_helper2, 2);
			calculateBlurTexture(texture_blur2, texture_blur3, FBO_blur3, texture_helper3, FBO_helper3, 4);
			calculateBlurTexture(texture_blur3, texture_blur4, FBO_blur4, texture_helper4, FBO_helper4, 8);
			calculateBlurTexture(texture_blur4, texture_blur5, FBO_blur5, texture_helper5, FBO_helper5, 16);
			calculateBlurTexture(texture_blur5, texture_blur6, FBO_blur6, texture_helper6, FBO_helper6, 32);
		}

		function calculateBlurTexture(sourceTex, targetTex, targetFBO, helperTex, helperFBO, scale) {
			// copy source
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, sourceTex);
			renderAsTriangleStrip(targetFBO);

			// blur vertically
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_vertical);
			gl.uniform2f(gl.getUniformLocation(prog_blur_vertical, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, targetTex);
			renderAsTriangleStrip(helperFBO);

			// blur horizontally
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_horizontal);
			gl.uniform2f(gl.getUniformLocation(prog_blur_horizontal, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, helperTex);
			renderAsTriangleStrip(targetFBO);

		}

		function stepParticles() {
			gl.viewport(0, 0, particlesWidth, particlesHeight);
			gl.useProgram(prog_move_particles);
			setUniforms(prog_move_particles);

			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				renderAsTriangleStrip(FBO_particles2)
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				renderAsTriangleStrip(FBO_particles);
			}
		}

		function fluidSimulationStep() {
			addMouseMotion();
			advect();
			diffuse();
		}

		function addMouseMotion() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_add_mouse_motion);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "mouseV"), mouseDx, mouseDy);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_add_mouse_motion, "texSize"), (sizeX / simScale), (sizeY / simScale));
			renderAsTriangleStrip(FBO_fluid_backbuffer);
		}

		function advect() {
			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_advect);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_advect, "texSize"), (sizeX / simScale), (sizeY / simScale));
			renderAsTriangleStrip(FBO_fluid_v);
		}

		function diffuse() {
			for (var i = 0; i < 8; i++) {
				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_backbuffer);

				gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
				gl.useProgram(prog_fluid_p);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "texSize"), (sizeX / simScale), (sizeY / simScale));
				gl.uniform2f(gl.getUniformLocation(prog_fluid_p, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_v"), 0);
				gl.uniform1i(gl.getUniformLocation(prog_fluid_p, "sampler_p"), 1);
				renderAsTriangleStrip(FBO_fluid_p);
			}


			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_fluid_div);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_v);
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_p);
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "texSize"), (sizeX / simScale), (sizeY / simScale));
			gl.uniform2f(gl.getUniformLocation(prog_fluid_div, "pixelSize"), 1. / (sizeX / simScale), 1. / (sizeY / simScale));
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_v"), 0);
			gl.uniform1i(gl.getUniformLocation(prog_fluid_div, "sampler_p"), 1);
			renderAsTriangleStrip(FBO_fluid_backbuffer);

			gl.viewport(0, 0, (sizeX / simScale), (sizeY / simScale));
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture_fluid_backbuffer);
			renderAsTriangleStrip(FBO_fluid_v);
		}

		// main texture feedback warp
		function advance() {
			gl.viewport(0, 0, sizeX, sizeY);
			gl.useProgram(prog_advance);
			setUniforms(prog_advance);
			if (mainBufferToggle > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l); // interpolated input
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n); // "nearest" input
				renderAsTriangleStrip(FBO_main2);
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l); // interpolated
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n); // "nearest"
				renderAsTriangleStrip(FBO_main);
			}
			mainBufferToggle = -mainBufferToggle;
		}

		function composite() {
			gl.viewport(0, 0, viewX, viewY);
			gl.useProgram(prog_composite);
			setUniforms(prog_composite);
			if (mainBufferToggle < 0) {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n);
			} else {
				gl.activeTexture(gl.TEXTURE12);
				gl.bindTexture(gl.TEXTURE_2D, texture_particles2);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n);
			}
			renderAsTriangleStrip(null);
		}

		var rainbowR, rainbowG, rainbowB, w = Math.PI * 2 / 3;

		function anim() {
			setTimeout("requestAnimationFrame(anim)", 1000 / desiredFramerate);

			updateStickMen();

			canvas2dContext.clearRect(0, 0, sizeX, sizeY);

			drawStickMen(canvas2dContext);

			updateCanvas2dTexture();

			time = new Date().getTime() - starttime;

			var t = time / 150;

			rainbowR = 0.5 + 0.5 * Math.sin(t);
			rainbowG = 0.5 + 0.5 * Math.sin(t + w);
			rainbowB = 0.5 + 0.5 * Math.sin(t - w);

			x1 = 0.5;
			thickness = (2 - mouseY * 1.) / 0.025;
			y1 = 0.035;

			x2 = 0.5 + (mouseX - 0.5) * 0.25;
			y2 = 0.07 + mouseY * 0.14;
			w1 = (0.5 - mouseX) * 0.15;

			if (oldMouseX != 0 && oldMouseY != 0) {
				mouseDx = (mouseX - oldMouseX) * viewX;
				mouseDy = (mouseY - oldMouseY) * viewY;
			}

			if (!halted) {

				if (useProjectionFeedback)
					renderParticles(FBO_particle_projection);

				if (useFluidSimulation)
					fluidSimulationStep();

				if (useParticles)
					stepParticles();

				advance();

				var srcTex = (mainBufferToggle < 0) ? texture_main2_l : texture_main_l;

				calculateBlurTextures(srcTex);

				frame++;
				framecount++;
			}

			if (renderParticlesOnly)
				renderParticles(null);
			else
				composite();

			frames++;

			oldMouseX = mouseX;
			oldMouseY = mouseY;

		}

		function fr() { // updates every second
			document.getElementById("fps").textContent = frame;
			frame = 0; // reset the frame counter
		}

		var hidden = false;
		function hide() {
			hidden = !hidden;
			document.getElementById("desc").style.setProperty('visibility', hidden ? 'hidden' : 'visible');
		}

		function goFull(cb) {
			if (cb.checked) {
				viewX = window.innerWidth;
				viewY = window.innerHeight;
			} else {
				viewX = sizeX;
				viewY = sizeY;
			}
			c.width = viewX;
			c.height = viewY;
		}

		function setDesiredFps(tb) {
			desiredFramerate = tb.value;
			if (desiredFramerate < 1)
				desiredFPS = 1;
		}

		function switchRenderer(particlesOnly) {
			renderParticlesOnly = particlesOnly;
		}
	</script>
	<style type="text/css">
		body {
			background-color: #000000;
			color: #FFFFFF;
		}

		#c {
			position: absolute;
			top: 0;
			left: 0;
			z-index: -1;
		}

		a {
			color: #FFFFFF;
			font-weight: bold;
		}

		#desc {
			background-color: rgba(0, 0, 0, 0.2);
			width: 1024;
		}
	</style>
</head>
<body onload="load()" ondblclick="hide()">
	<div id="desc">
		Post-processing variant forked from <a href="turing-fluid-particle-projection-feedback.html">turing-fluid-particle-projection-feedback.html</a>
		fps: <span id="fps"></span>
		<form>
			<!-- 
			limit fps <input type="text" name="desiredFPS" size="3" value="50"
				onKeyUp="setDesiredFps(this)"></input> 
		 -->
			<br>
			<input type="radio" name="render"
				onclick="switchRenderer(false)" checked="checked">blur
			gradient composite</input>
			<br>
			<input type="radio" name="render"
				onclick="switchRenderer(true)">only particles</input>
			<br>
			<input
				type="checkbox" onclick="goFull(this)" checked="checked">full
			</input>
		</form>
	</div>
	<canvas id="c"></canvas>
</body>
</html>
